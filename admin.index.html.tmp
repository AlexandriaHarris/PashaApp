<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Teacher's Pet - Admin Dashboard</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
    }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }

    /* Auth */
    #auth-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    .auth-box {
      background: #16213e;
      padding: 40px;
      border-radius: 12px;
      width: 100%;
      max-width: 400px;
    }
    .auth-box h1 { text-align: center; margin-bottom: 30px; color: #4f8cff; }
    .auth-box input {
      width: 100%;
      padding: 12px;
      margin-bottom: 15px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #1a1a2e;
      color: #fff;
      font-size: 16px;
    }
    .auth-box button {
      width: 100%;
      padding: 14px;
      background: #4f8cff;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
    }
    .auth-box button:hover { background: #3d7ae8; }
    .error { color: #ff6b6b; margin-bottom: 15px; text-align: center; }

    /* Header */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 0;
      border-bottom: 1px solid #333;
      margin-bottom: 20px;
    }
    header h1 { color: #4f8cff; }
    .user-info { display: flex; align-items: center; gap: 15px; }
    .user-info span { opacity: 0.7; }
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
    }
    .btn-primary { background: #4f8cff; color: #fff; }
    .btn-secondary { background: #333; color: #fff; }
    .btn-danger { background: #ff6b6b; color: #fff; }
    .btn-success { background: #4caf50; color: #fff; }
    .btn:hover { opacity: 0.9; }
    .btn-small {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 6px;
    }
    .editor-layout {
      display: grid;
      grid-template-columns: 260px 1fr;
      gap: 16px;
      margin-top: 16px;
    }
    .editor-list {
      background: #10192f;
      border-radius: 12px;
      padding: 12px;
      max-height: 75vh;
      overflow: auto;
    }
    .editor-list input {
      width: 100%;
      margin-bottom: 10px;
      padding: 8px 10px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #16213e;
      color: #fff;
      font-size: 12px;
    }
    .editor-list .list-item {
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      margin-bottom: 6px;
      background: #16213e;
    }
    .editor-list .list-item.active {
      background: #4f8cff;
      color: #fff;
    }
    .editor-main {
      background: #10192f;
      border-radius: 12px;
      padding: 16px;
    }
    .editor-fields {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    .editor-fields input, .editor-fields textarea {
      padding: 8px 10px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #16213e;
      color: #fff;
      font-size: 12px;
    }
    .editor-fields textarea {
      min-height: 60px;
      resize: vertical;
    }
    .editor-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-bottom: 12px;
    }
    .editor-split {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .editor-split textarea {
      width: 100%;
      min-height: 55vh;
      padding: 12px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #0f1a33;
      color: #fff;
      font-size: 13px;
      line-height: 1.5;
      resize: vertical;
    }
    .editor-preview {
      background: #0f1a33;
      border-radius: 8px;
      padding: 16px;
      max-height: 55vh;
      overflow: auto;
    }
    .editor-preview h1 { font-size: 22px; margin: 14px 0 10px; }
    .editor-preview h2 { font-size: 18px; margin: 14px 0 8px; }
    .editor-preview h3 { font-size: 16px; margin: 12px 0 6px; }
    .editor-preview p { font-size: 13px; line-height: 1.5; margin: 8px 0; }
    .editor-preview ul { padding-left: 18px; margin: 8px 0; }
    .editor-preview li { margin: 6px 0; }
    .editor-preview table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: 12px;
    }
    .editor-preview th, .editor-preview td {
      border: 1px solid rgba(255,255,255,0.1);
      padding: 6px 8px;
      vertical-align: top;
    }
    .editor-preview tbody tr:nth-child(even) {
      background: rgba(255,255,255,0.03);
    }
    .editor-preview input[type="checkbox"] {
      margin-right: 6px;
    }

    /* Stats */
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      margin-bottom: 30px;
    }
    .stat-card {
      background: #16213e;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
    }
    .stat-card h3 { font-size: 28px; color: #4f8cff; }
    .stat-card p { opacity: 0.7; margin-top: 5px; font-size: 13px; }

    /* Filters */
    .filters {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .filters input, .filters select {
      padding: 10px 15px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #16213e;
      color: #fff;
      font-size: 14px;
    }
    .filters input { flex: 1; min-width: 200px; }

    /* Item Lists */
    .item-list { margin-bottom: 30px; }
    .item-card {
      background: #16213e;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 15px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .item-card:hover { transform: translateX(5px); }
    .item-card .id {
      font-size: 12px;
      color: #4f8cff;
      margin-bottom: 8px;
      font-family: monospace;
    }
    .item-card .title {
      font-size: 15px;
      line-height: 1.5;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .item-card .preview {
      font-size: 14px;
      opacity: 0.7;
      margin-top: 8px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .item-card .meta {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.7;
      flex-wrap: wrap;
    }
    .item-card .actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .item-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .bulk-actions {
      background: #10192f;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 16px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    .bulk-actions input, .bulk-actions select {
      padding: 8px 10px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #16213e;
      color: #fff;
      font-size: 12px;
    }
    .quick-edit {
      margin-top: 12px;
      padding: 12px;
      background: #0f1a33;
      border-radius: 10px;
      display: none;
    }
    .quick-edit textarea, .quick-edit input, .quick-edit select {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #16213e;
      color: #fff;
      font-size: 12px;
      margin-bottom: 8px;
    }
    .quick-edit-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    .trash-tag { background: #ff6b6b33; color: #ff6b6b; }
    .item-card .report-title {
      font-size: 14px;
      margin-top: 6px;
      color: #cbd6ff;
      font-weight: 600;
    }
    .item-card .report-content {
      font-size: 13px;
      opacity: 0.75;
      margin-top: 6px;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .reports-ops-panel {
      text-align: left;
      margin-bottom: 16px;
      padding: 16px;
    }
    .reports-ops-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }
    .reports-ops-header h3 {
      font-size: 18px;
      color: #4f8cff;
    }
    .reports-ops-copy {
      opacity: 0.75;
      margin-bottom: 12px;
      font-size: 13px;
    }
    .reports-ops-kpis {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    .reports-ops-kpi {
      background: #10192f;
      border: 1px solid #2a3558;
      border-radius: 10px;
      padding: 10px;
    }
    .reports-ops-kpi span {
      display: block;
      font-size: 11px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      opacity: 0.7;
    }
    .reports-ops-kpi strong {
      display: block;
      font-size: 17px;
      margin-top: 4px;
      color: #fff;
    }
    .reports-ops-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 10px;
    }
    .reports-ops-summary {
      background: #10192f;
      border-radius: 10px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.5;
      white-space: pre-wrap;
      min-height: 72px;
    }
    .tag {
      padding: 3px 8px;
      border-radius: 4px;
    }
    .tag-blue { background: #4f8cff33; color: #4f8cff; }
    .tag-green { background: #4caf5033; color: #4caf50; }
    .tag-orange { background: #ff980033; color: #ff9800; }
    .tag-purple { background: #9c27b033; color: #ce93d8; }
    .tag-red { background: #ff6b6b33; color: #ff6b6b; }

    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      overflow-y: auto;
      padding: 20px;
    }
    .modal-overlay.active { display: block; }
    .modal {
      background: #16213e;
      border-radius: 12px;
      max-width: 900px;
      margin: 20px auto;
      padding: 30px;
    }
    .modal.wide { max-width: 1100px; }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #333;
    }
    .modal-header h2 { color: #4f8cff; }
    .close-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
    }

    .form-group { margin-bottom: 20px; }
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #4f8cff;
    }
    .form-group input, .form-group textarea, .form-group select {
      width: 100%;
      padding: 12px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #1a1a2e;
      color: #fff;
      font-size: 14px;
      font-family: inherit;
    }
    .form-group textarea { min-height: 100px; resize: vertical; }
    .form-group textarea.large { min-height: 300px; }
    .form-group .hint { font-size: 12px; opacity: 0.6; margin-top: 5px; }
    .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }

    .options-group { margin-top: 20px; }
    .option-item {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      margin-bottom: 15px;
    }
    .option-item input[type="text"] { flex: 1; }
    .option-item input[type="checkbox"] {
      width: 20px;
      height: 20px;
      margin-top: 10px;
    }
    .option-label { font-size: 12px; opacity: 0.7; margin-top: 10px; }

    .modal-actions {
      display: flex;
      gap: 15px;
      justify-content: flex-end;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #333;
    }

    /* Tags input */
    .tags-container {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px;
      background: #1a1a2e;
      border: 1px solid #333;
      border-radius: 8px;
      min-height: 50px;
    }
    .tag-item {
      background: #4f8cff33;
      color: #4f8cff;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .tag-item .remove { cursor: pointer; }
    .tags-input {
      border: none !important;
      background: transparent !important;
      flex: 1;
      min-width: 100px;
      padding: 5px !important;
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }
    .pagination button {
      padding: 10px 20px;
      background: #16213e;
      border: 1px solid #333;
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
    }
    .pagination button:disabled { opacity: 0.5; cursor: not-allowed; }
    .pagination span { padding: 10px; }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .tab {
      padding: 12px 24px;
      background: #16213e;
      border: none;
      color: #fff;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      opacity: 0.6;
    }
    .tab.active { opacity: 1; background: #4f8cff; }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 15px 25px;
      background: #4caf50;
      color: #fff;
      border-radius: 8px;
      display: none;
      z-index: 2000;
    }
    .toast.error { background: #ff6b6b; }
    .toast.show { display: block; }

    .loading { text-align: center; padding: 40px; opacity: 0.7; }

    /* Flashcard preview */
    .flashcard-preview {
      background: #1a1a2e;
      border-radius: 12px;
      padding: 20px;
      margin-top: 15px;
    }
    .flashcard-preview .side {
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 10px;
    }
    .flashcard-preview .front-side {
      background: #4f8cff22;
      border-left: 3px solid #4f8cff;
    }
    .flashcard-preview .back-side {
      background: #4caf5022;
      border-left: 3px solid #4caf50;
    }
    .flashcard-preview .side-label {
      font-size: 11px;
      text-transform: uppercase;
      opacity: 0.6;
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <!-- Auth Container -->
  <div id="auth-container">
    <div class="auth-box">
      <h1>Admin Login</h1>
      <div id="auth-error" class="error" style="display: none;"></div>
      <input type="email" id="email" placeholder="Email" />
      <input type="password" id="password" placeholder="Password" />
      <button onclick="login()">Sign In</button>
    </div>
  </div>

  <!-- Main Dashboard -->
  <div id="dashboard" style="display: none;">
    <div class="container">
      <header>
        <h1>Teacher's Pet Admin</h1>
        <div class="user-info">
          <span id="user-email"></span>
          <button class="btn btn-secondary" onclick="logout()">Sign Out</button>
        </div>
      </header>

      <!-- Stats -->
      <div class="stats">
        <div class="stat-card">
          <h3 id="total-questions">0</h3>
          <p>Questions</p>
        </div>
        <div class="stat-card">
          <h3 id="total-flashcards">0</h3>
          <p>Flashcards</p>
        </div>
        <div class="stat-card">
          <h3 id="total-readings">0</h3>
          <p>Readings</p>
        </div>
        <div class="stat-card">
          <h3 id="total-linked">0</h3>
          <p>Linked Items</p>
        </div>
        <div class="stat-card">
          <h3 id="total-reports">0</h3>
          <p>Pending Reports</p>
        </div>
      </div>

      <!-- Tabs -->
      <div class="tabs">
        <button class="tab active" data-tab="questions" onclick="switchTab('questions', this)">Questions</button>
        <button class="tab" data-tab="flashcards" onclick="switchTab('flashcards', this)">Flashcards</button>
        <button class="tab" data-tab="readings" onclick="switchTab('readings', this)">Readings</button>
        <button class="tab" data-tab="reading-editor" onclick="switchTab('reading-editor', this)">Reading Editor</button>
        <button class="tab" data-tab="trash" onclick="switchTab('trash', this)">Trash</button>
        <button class="tab" data-tab="reports" onclick="switchTab('reports', this)">Reports</button>
        <button class="tab" data-tab="linker" onclick="switchTab('linker', this)">Linker</button>
        <button class="tab" data-tab="assignments" onclick="switchTab('assignments', this)">Assignments</button>
        <button class="tab" data-tab="users" onclick="switchTab('users', this)">Users</button>
        <button class="tab" data-tab="upload" onclick="switchTab('upload', this)">Upload</button>
      </div>

      <datalist id="tag-options"></datalist>

      <!-- Questions Tab -->
      <div id="questions-tab">
        <div class="filters">
          <input type="text" id="q-search" placeholder="Search questions..." oninput="filterQuestions()" />
          <select id="q-category-filter" onchange="filterQuestions()">
            <option value="">All Categories</option>
          </select>
          <button class="btn btn-primary" onclick="openNewQuestion()">+ New Question</button>
          <button class="btn btn-secondary" onclick="openPrefixModal()">ID Prefixes</button>
        </div>
        <div class="bulk-actions">
          <strong style="font-size:12px; opacity:0.7;">Bulk</strong>
          <input type="text" id="q-bulk-add-tags" placeholder="Add tags (comma)" list="tag-options" />
          <input type="text" id="q-bulk-remove-tags" placeholder="Remove tags (comma)" list="tag-options" />
          <input type="text" id="q-bulk-category" placeholder="Set category" />
          <input type="text" id="q-bulk-subcategory" placeholder="Set subcategory" />
          <button class="btn btn-secondary btn-small" onclick="selectPageItems('questions')">Select Page</button>
          <button class="btn btn-secondary btn-small" onclick="clearSelections('questions')">Clear</button>
          <button class="btn btn-primary btn-small" onclick="applyBulkChanges('questions')">Apply</button>
          <button class="btn btn-success btn-small" onclick="exportCollection('questions', 'json')">Export JSON</button>
          <button class="btn btn-success btn-small" onclick="exportCollection('questions', 'js')">Export JS</button>
        </div>
        <div id="question-list" class="item-list">
          <div class="loading">Loading questions...</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center; margin:10px 0;">
          <button class="btn btn-secondary" onclick="loadMoreQuestions()">Load More</button>
          <button class="btn btn-secondary" onclick="loadAllQuestions()">Load All</button>
          <span id="q-load-status" style="opacity:0.7;"></span>
        </div>
        <div class="pagination">
          <button onclick="prevPage('questions')" id="q-prev-btn" disabled>Previous</button>
          <span id="q-page-info">Page 1</span>
          <button onclick="nextPage('questions')" id="q-next-btn">Next</button>
        </div>
      </div>

      <!-- Flashcards Tab -->
      <div id="flashcards-tab" style="display: none;">
        <div class="filters">
          <input type="text" id="fc-search" placeholder="Search flashcards..." oninput="filterFlashcards()" />
          <select id="fc-category-filter" onchange="filterFlashcards()">
            <option value="">All Categories</option>
          </select>
          <button class="btn btn-primary" onclick="openNewFlashcard()">+ New Flashcard</button>
        </div>
        <div class="bulk-actions">
          <strong style="font-size:12px; opacity:0.7;">Bulk</strong>
          <input type="text" id="fc-bulk-add-tags" placeholder="Add tags (comma)" list="tag-options" />
          <input type="text" id="fc-bulk-remove-tags" placeholder="Remove tags (comma)" list="tag-options" />
          <input type="text" id="fc-bulk-category" placeholder="Set category" />
          <input type="text" id="fc-bulk-subcategory" placeholder="Set subcategory" />
          <button class="btn btn-secondary btn-small" onclick="selectPageItems('flashcards')">Select Page</button>
          <button class="btn btn-secondary btn-small" onclick="clearSelections('flashcards')">Clear</button>
          <button class="btn btn-primary btn-small" onclick="applyBulkChanges('flashcards')">Apply</button>
          <button class="btn btn-success btn-small" onclick="exportCollection('flashcards', 'json')">Export JSON</button>
          <button class="btn btn-success btn-small" onclick="exportCollection('flashcards', 'js')">Export JS</button>
        </div>
        <div id="flashcard-list" class="item-list">
          <div class="loading">Loading flashcards...</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center; margin:10px 0;">
          <button class="btn btn-secondary" onclick="loadMoreFlashcards()">Load More</button>
          <button class="btn btn-secondary" onclick="loadAllFlashcards()">Load All</button>
          <span id="fc-load-status" style="opacity:0.7;"></span>
        </div>
        <div class="pagination">
          <button onclick="prevPage('flashcards')" id="fc-prev-btn" disabled>Previous</button>
          <span id="fc-page-info">Page 1</span>
          <button onclick="nextPage('flashcards')" id="fc-next-btn">Next</button>
        </div>
      </div>

      <!-- Readings Tab -->
      <div id="readings-tab" style="display: none;">
        <div class="filters">
          <input type="text" id="r-search" placeholder="Search readings..." oninput="filterReadings()" />
          <select id="r-category-filter" onchange="filterReadings()">
            <option value="">All Categories</option>
          </select>
          <button class="btn btn-primary" onclick="openNewReading()">+ New Reading</button>
        </div>
        <div class="bulk-actions">
          <strong style="font-size:12px; opacity:0.7;">Bulk</strong>
          <input type="text" id="r-bulk-add-tags" placeholder="Add tags (comma)" list="tag-options" />
          <input type="text" id="r-bulk-remove-tags" placeholder="Remove tags (comma)" list="tag-options" />
          <input type="text" id="r-bulk-category" placeholder="Set category" />
          <button class="btn btn-secondary btn-small" onclick="selectPageItems('readings')">Select Page</button>
          <button class="btn btn-secondary btn-small" onclick="clearSelections('readings')">Clear</button>
          <button class="btn btn-primary btn-small" onclick="applyBulkChanges('readings')">Apply</button>
          <button class="btn btn-success btn-small" onclick="exportCollection('readings', 'json')">Export JSON</button>
          <button class="btn btn-success btn-small" onclick="exportCollection('readings', 'js')">Export JS</button>
        </div>
        <div id="reading-list" class="item-list">
          <div class="loading">Loading readings...</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center; margin:10px 0;">
          <button class="btn btn-secondary" onclick="loadMoreReadings()">Load More</button>
          <button class="btn btn-secondary" onclick="loadAllReadings()">Load All</button>
          <span id="r-load-status" style="opacity:0.7;"></span>
        </div>
        <div class="pagination">
          <button onclick="prevPage('readings')" id="r-prev-btn" disabled>Previous</button>
          <span id="r-page-info">Page 1</span>
          <button onclick="nextPage('readings')" id="r-next-btn">Next</button>
        </div>
      </div>

      <div id="reading-editor-tab" style="display: none;">
        <div class="bulk-actions">
          <strong style="font-size:13px;">Reading Markdown Editor</strong>
          <span style="opacity:0.7;font-size:12px;">Edit Markdown with live preview (supports Obsidian callouts + checkboxes)</span>
        </div>
        <div class="editor-layout">
          <div class="editor-list">
            <input id="reading-editor-search" type="text" placeholder="Search readings..." oninput="renderReadingEditorList()" />
            <div id="reading-editor-list"></div>
          </div>
          <div class="editor-main">
            <div class="editor-fields">
              <input id="reading-editor-title" type="text" placeholder="Title" />
              <input id="reading-editor-category" type="text" placeholder="Category (e.g., laryngology)" />
              <input id="reading-editor-tags" type="text" placeholder="Tags (comma-separated)" />
              <textarea id="reading-editor-question-ids" placeholder="Question IDs (comma or newline separated)"></textarea>
            </div>
            <div class="editor-actions">
              <button class="btn btn-secondary btn-small" onclick="refreshReadingPreview()">Refresh Preview</button>
              <button class="btn btn-primary btn-small" onclick="saveReadingEditor()">Save Reading</button>
            </div>
            <div class="editor-split">
              <textarea id="reading-editor-content" placeholder="Paste Markdown here..." oninput="refreshReadingPreview()"></textarea>
              <div id="reading-editor-preview" class="editor-preview"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Trash Tab -->
      <div id="trash-tab" style="display: none;">
        <div class="filters">
          <select id="trash-type-filter" onchange="renderTrash()">
            <option value="questions">Questions</option>
            <option value="flashcards">Flashcards</option>
            <option value="readings">Readings</option>
          </select>
          <button class="btn btn-secondary" onclick="renderTrash()">Refresh</button>
        </div>
        <div id="trash-list" class="item-list">
          <div class="loading">No trashed items loaded.</div>
        </div>
      </div>

      <!-- Upload Tab -->
      <div id="upload-tab" style="display: none;">
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 15px;">Quick Add</h3>
          <div class="form-group">
            <label>Type</label>
            <select id="quick-type">
              <option value="question">Question</option>
              <option value="flashcard">Flashcard</option>
              <option value="reading">Reading</option>
            </select>
          </div>

          <div id="quick-question">
            <div class="form-row">
              <div class="form-group">
                <label>Question ID</label>
                <input type="text" id="quick-q-id" placeholder="oto_anatomy_001" />
              </div>
              <div class="form-group">
                <label>Category</label>
                <input type="text" id="quick-q-category" placeholder="OTOLOGY" />
              </div>
            </div>
            <div class="form-row">
              <div class="form-group">
                <label>Subcategory</label>
                <input type="text" id="quick-q-subcategory" placeholder="Ear Anatomy" />
              </div>
              <div class="form-group">
                <label>Difficulty</label>
                <select id="quick-q-difficulty">
                  <option value="basic">Basic</option>
                  <option value="intermediate" selected>Intermediate</option>
                  <option value="advanced">Advanced</option>
                </select>
              </div>
            </div>
            <div class="form-group">
              <label>Tags (comma separated)</label>
              <input type="text" id="quick-q-tags" placeholder="anatomy, otology" list="tag-options" />
            </div>
            <div class="form-group">
              <label>Stem</label>
              <textarea id="quick-q-stem" rows="3"></textarea>
            </div>
            <div class="form-group">
              <label>Lead-in</label>
              <input type="text" id="quick-q-leadin" />
            </div>
            <div class="options-group">
              <label>Answer Options</label>
              <div class="option-item">
                <input type="text" id="quick-q-option-a" placeholder="Option A" />
                <span class="option-label">A</span>
              </div>
              <div class="option-item">
                <input type="text" id="quick-q-option-b" placeholder="Option B" />
                <span class="option-label">B</span>
              </div>
              <div class="option-item">
                <input type="text" id="quick-q-option-c" placeholder="Option C" />
                <span class="option-label">C</span>
              </div>
              <div class="option-item">
                <input type="text" id="quick-q-option-d" placeholder="Option D" />
                <span class="option-label">D</span>
              </div>
              <div class="form-group" style="margin-top: 12px;">
                <label>Correct (A-D)</label>
                <input type="text" id="quick-q-correct" placeholder="A" />
              </div>
            </div>
            <div class="form-group">
              <label>Explanation</label>
              <textarea id="quick-q-explanation" rows="3"></textarea>
            </div>
          </div>

          <div id="quick-flashcard" style="display:none;">
            <div class="form-row">
              <div class="form-group">
                <label>Flashcard ID</label>
                <input type="text" id="quick-fc-id" placeholder="oto_fc_001" />
              </div>
              <div class="form-group">
                <label>Category</label>
                <input type="text" id="quick-fc-category" placeholder="OTOLOGY" />
              </div>
            </div>
            <div class="form-row">
              <div class="form-group">
                <label>Subcategory</label>
                <input type="text" id="quick-fc-subcategory" placeholder="Ear Anatomy" />
              </div>
              <div class="form-group">
                <label>Difficulty</label>
                <select id="quick-fc-difficulty">
                  <option value="basic">Basic</option>
                  <option value="intermediate" selected>Intermediate</option>
                  <option value="advanced">Advanced</option>
                </select>
              </div>
            </div>
            <div class="form-group">
              <label>Cloze Text (preferred)</label>
              <textarea id="quick-fc-cloze" rows="2" placeholder="Use {{c::answer}}"></textarea>
            </div>
            <div class="form-group">
              <label>Front</label>
              <textarea id="quick-fc-front" rows="2"></textarea>
            </div>
            <div class="form-group">
              <label>Back</label>
              <textarea id="quick-fc-back" rows="2"></textarea>
            </div>
            <div class="form-group">
              <label>Notes (optional)</label>
              <textarea id="quick-fc-notes" rows="2"></textarea>
            </div>
            <div class="form-group">
              <label>Tags (comma separated)</label>
              <input type="text" id="quick-fc-tags" placeholder="anatomy, otology" list="tag-options" />
            </div>
            <div class="form-group">
              <label>Related Question IDs</label>
              <input type="text" id="quick-fc-related" placeholder="oto_anatomy_001, oto_anatomy_002" />
            </div>
            <div class="form-group">
              <label>Related Reading ID</label>
              <input type="text" id="quick-fc-reading" placeholder="otology/01_anatomy.md" />
            </div>
          </div>

          <div id="quick-reading" style="display:none;">
            <div class="form-row">
              <div class="form-group">
                <label>Reading ID</label>
                <input type="text" id="quick-r-id" placeholder="rhinology/01_nasal_anatomy" />
              </div>
              <div class="form-group">
                <label>Category</label>
                <input type="text" id="quick-r-category" placeholder="rhinology" />
              </div>
            </div>
            <div class="form-group">
              <label>Title</label>
              <input type="text" id="quick-r-title" placeholder="Nasal Anatomy" />
            </div>
            <div class="form-row">
              <div class="form-group">
                <label>Reading Time (min)</label>
                <input type="number" id="quick-r-time" placeholder="5" />
              </div>
              <div class="form-group">
                <label>Word Count</label>
                <input type="number" id="quick-r-words" placeholder="500" />
              </div>
            </div>
            <div class="form-group">
              <label>Priority</label>
              <select id="quick-r-priority">
                <option value="essential">Essential</option>
                <option value="suggested" selected>Suggested</option>
                <option value="supplemental">Supplemental</option>
              </select>
            </div>
            <div class="form-group">
              <label>Related Question IDs</label>
              <input type="text" id="quick-r-questions" placeholder="oto_anatomy_001, oto_anatomy_002" />
            </div>
            <div class="form-group">
              <label>Tags (comma separated)</label>
              <input type="text" id="quick-r-tags" placeholder="vascular, syndromes" list="tag-options" />
            </div>
            <div class="form-group">
              <label>Content (Markdown)</label>
              <textarea id="quick-r-content" class="large" rows="8"></textarea>
            </div>
          </div>

          <button class="btn btn-primary" onclick="quickAdd()">Save Item</button>
        </div>

        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 10px;">Import Markdown Reading</h3>
          <p style="opacity:0.7; margin-bottom:12px;">
            Select a Markdown file and load it into Quick Add so it keeps headings, lists, and tables.
          </p>
          <div class="form-row">
            <div class="form-group">
              <label>Markdown File</label>
              <input type="file" id="markdown-reading-file" accept=".md,.markdown,.txt" />
            </div>
            <div class="form-group">
              <label>Category</label>
              <input type="text" id="markdown-reading-category" placeholder="pediatrics" />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label>Reading ID (optional)</label>
              <input type="text" id="markdown-reading-id" placeholder="pediatrics/10_vascular_anomalies" />
            </div>
            <div class="form-group">
              <label>Priority</label>
              <select id="markdown-reading-priority">
                <option value="essential">Essential</option>
                <option value="suggested" selected>Suggested</option>
                <option value="supplemental">Supplemental</option>
              </select>
            </div>
          </div>
          <div class="form-group">
            <label>Related Question IDs (optional)</label>
            <input type="text" id="markdown-reading-questions" placeholder="peds_vascular_001, peds_vascular_002" />
          </div>
          <button class="btn btn-primary" onclick="loadMarkdownReading()">Load into Quick Add</button>
        </div>

        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 10px;">Paste Import (Template)</h3>
          <p style="opacity:0.7; margin-bottom:12px;">
            Paste one or more blocks. Use TYPE=question|flashcard|reading. Multiline fields use FIELD<< then >>.
          </p>
          <textarea id="bulk-import" class="large" rows="10" placeholder="TYPE=question&#10;ID=oto_anatomy_001&#10;CATEGORY=OTOLOGY&#10;SUBCATEGORY=Ear Anatomy&#10;DIFFICULTY=intermediate&#10;TAGS=anatomy, otology&#10;STEM<<&#10;A patient...&#10;>>&#10;LEADIN=Best next step?&#10;OPTIONS=A|B|C|D&#10;CORRECT=A&#10;EXPLANATION<<&#10;Because...&#10;>>&#10;---&#10;TYPE=flashcard&#10;ID=oto_fc_001&#10;CLOZE=The ossicle is {{c::malleus}}.&#10;NOTES=Extra note.&#10;RELATED_QUESTIONS=oto_anatomy_001"></textarea>
          <button class="btn btn-primary" onclick="importFromTemplate()">Import</button>
        </div>
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 15px;">Upload Questions</h3>
          <code style="background:#1a1a2e;padding:10px;display:block;border-radius:4px;">node scripts/uploadQuestions.js</code>
        </div>
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 15px;">Upload Flashcards</h3>
          <code style="background:#1a1a2e;padding:10px;display:block;border-radius:4px;">node scripts/uploadFlashcards.js</code>
        </div>
        <div class="stat-card" style="text-align: left;">
          <h3 style="font-size: 18px; margin-bottom: 15px;">Upload Readings</h3>
          <code style="background:#1a1a2e;padding:10px;display:block;border-radius:4px;">node scripts/uploadReadings.js</code>
        </div>
      </div>

      <!-- Reports Tab -->
      <div id="reports-tab" style="display: none;">
        <div class="filters">
          <input type="text" id="report-search" placeholder="Search reports..." oninput="filterReports()" />
          <select id="report-status-filter" onchange="filterReports()">
            <option value="">All Statuses</option>
            <option value="pending" selected>Pending</option>
            <option value="reviewed">Reviewed</option>
            <option value="resolved">Resolved</option>
            <option value="dismissed">Dismissed</option>
          </select>
          <select id="report-type-filter" onchange="filterReports()">
            <option value="">All Types</option>
            <option value="question">Questions</option>
            <option value="flashcard">Flashcards</option>
          </select>
        </div>
        <div class="stat-card reports-ops-panel">
          <div class="reports-ops-header">
            <h3>Reports Ops</h3>
            <span id="reports-ops-connection" class="tag tag-orange">Not checked</span>
          </div>
          <p class="reports-ops-copy">Desktop controls for Firebase connection checks, report repair, and all-reports summaries.</p>
          <div class="reports-ops-kpis">
            <div class="reports-ops-kpi">
              <span>Total Reports</span>
              <strong id="reports-kpi-total">-</strong>
            </div>
            <div class="reports-ops-kpi">
              <span>Open Reports</span>
              <strong id="reports-kpi-open">-</strong>
            </div>
            <div class="reports-ops-kpi">
              <span>Needs Repair</span>
              <strong id="reports-kpi-repair">-</strong>
            </div>
            <div class="reports-ops-kpi">
              <span>Oldest Open</span>
              <strong id="reports-kpi-oldest">-</strong>
            </div>
          </div>
          <div class="reports-ops-actions">
            <button class="btn btn-secondary btn-small" data-reports-op onclick="checkFirebaseConnection()">Check Connection</button>
            <button class="btn btn-primary btn-small" data-reports-op onclick="refreshReportsOpsSummary()">Refresh Summary</button>
            <button class="btn btn-secondary btn-small" data-reports-op onclick="repairReportsDryRun()">Repair Dry Run</button>
            <button class="btn btn-success btn-small" data-reports-op onclick="repairReportsApply()">Apply Repairs</button>
          </div>
          <div id="reports-ops-summary" class="reports-ops-summary">Open Reports and click "Refresh Summary" to load operations data.</div>
        </div>
        <div id="report-list" class="item-list">
          <div class="loading">Loading reports...</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center; margin:10px 0;">
          <button class="btn btn-secondary" onclick="loadMoreReports()">Load More</button>
          <button class="btn btn-secondary" onclick="loadAllReports()">Load All</button>
          <button class="btn btn-success btn-small" onclick="exportReportsCSV()">Export CSV</button>
          <button class="btn btn-success btn-small" onclick="exportReportsJSON()">Export JSON</button>
          <span id="rpt-load-status" style="opacity:0.7;"></span>
        </div>
        <div class="pagination">
          <button onclick="prevPage('reports')" id="rpt-prev-btn" disabled>Previous</button>
          <span id="rpt-page-info">Page 1</span>
          <button onclick="nextPage('reports')" id="rpt-next-btn">Next</button>
        </div>
      </div>

      <!-- Linker Tab -->
      <div id="linker-tab" style="display: none;">
        <div class="filters">
          <input type="text" id="linker-search" placeholder="Search keyword (e.g., sturge-weber)" oninput="runLinkerSearch()" />
          <button class="btn btn-primary" onclick="runLinkerSearch()">Search</button>
          <button class="btn btn-secondary" onclick="loadLinkerData()">Load Full Data</button>
        </div>
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 10px;">Link Selected Items</h3>
          <p style="opacity:0.7; margin-bottom:12px;">
            Select questions and then link them to flashcards/readings. This updates the flashcard relatedQuestions and reading questionIds.
          </p>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="btn btn-primary" onclick="linkSelectedQuestionsToReadings()">Link to Readings</button>
            <button class="btn btn-secondary" onclick="linkSelectedQuestionsToFlashcards()">Link to Flashcards</button>
            <button class="btn btn-secondary" onclick="autoLinkQuestionsToFlashcardsByTags()">Auto-link Qs → Flashcards by Tags</button>
            <button class="btn btn-secondary" onclick="autoLinkQuestionsToReadingsByTags()">Auto-link Qs → Readings by Tags</button>
          </div>
        </div>
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 10px;">Audit Report</h3>
          <p style="opacity:0.7; margin-bottom:12px;">
            Find items missing links across questions, flashcards, and readings.
          </p>
          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom: 10px;">
            <button class="btn btn-primary" onclick="runAuditReport()">Run Audit</button>
            <button class="btn btn-secondary" onclick="downloadAuditCsv()">Download CSV</button>
          </div>
          <div id="audit-summary" style="opacity:0.75; font-size: 13px;">No audit run yet.</div>
          <div class="form-group" style="margin-top: 12px;">
            <label>Questions Missing Links</label>
            <div id="audit-questions" class="item-list">
              <div class="loading">Run audit to see results...</div>
            </div>
          </div>
          <div class="form-group">
            <label>Flashcards Missing Links</label>
            <div id="audit-flashcards" class="item-list">
              <div class="loading">Run audit to see results...</div>
            </div>
          </div>
          <div class="form-group">
            <label>Readings Missing Links</label>
            <div id="audit-readings" class="item-list">
              <div class="loading">Run audit to see results...</div>
            </div>
          </div>
        </div>
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 10px;">Results</h3>
          <div class="form-group">
            <label>Questions</label>
            <div id="linker-questions" class="item-list">
              <div class="loading">Search to see questions...</div>
            </div>
          </div>
          <div class="form-group">
            <label>Flashcards</label>
            <div id="linker-flashcards" class="item-list">
              <div class="loading">Search to see flashcards...</div>
            </div>
          </div>
          <div class="form-group">
            <label>Readings</label>
            <div id="linker-readings" class="item-list">
              <div class="loading">Search to see readings...</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Assignments Tab -->
      <div id="assignments-tab" style="display: none;">
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 15px;">Create Assignment</h3>
          <div class="form-group">
            <label>Title</label>
            <input type="text" id="assign-title" placeholder="Assigned Exam" />
          </div>
          <div class="form-group">
            <label>Assignee Email</label>
            <input type="email" id="assign-email" placeholder="user@example.com" />
          </div>
          <div class="form-group">
            <label>Question IDs (comma or newline)</label>
            <textarea id="assign-question-ids" rows="3" placeholder="oto_anatomy_001, oto_anatomy_002"></textarea>
          </div>
          <div class="form-group">
            <label>Categories (optional, comma separated)</label>
            <input type="text" id="assign-categories" placeholder="OTOLOGY, RHINOLOGY" />
          </div>
          <div class="form-group">
            <label>Focus Tags (optional, comma separated)</label>
              <input type="text" id="assign-focus-tags" placeholder="anatomy, diagnosis" list="tag-options" />
          </div>
          <div class="form-group">
            <label>Question Count (optional)</label>
            <input type="number" id="assign-count" placeholder="25" />
          </div>
          <div class="form-group">
            <label>Mode</label>
            <select id="assign-mode">
              <option value="tutor">Tutor</option>
              <option value="timed">Timed</option>
              <option value="untimed">Untimed</option>
            </select>
          </div>
          <div class="form-group">
            <label>Due Date (optional)</label>
            <input type="date" id="assign-due-date" />
          </div>
          <button class="btn btn-primary" onclick="createAssignment()">Send Assignment</button>
          <button class="btn btn-secondary" onclick="saveAssignmentPreset()" style="margin-left:10px;">Save as Preset</button>
        </div>
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 10px;">Cohort Overview</h3>
          <div id="assignment-summary" class="item-list">
            <div class="loading">Loading summary...</div>
          </div>
        </div>
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 10px;">Assignment Presets</h3>
          <div id="assignment-presets" class="item-list">
            <div class="loading">Loading presets...</div>
          </div>
        </div>
        <div id="assignment-list" class="item-list">
          <div class="loading">Loading assignments...</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center; margin:10px 0;">
          <button class="btn btn-secondary" onclick="loadMoreAssignments()">Load More</button>
          <button class="btn btn-secondary" onclick="loadAllAssignments()">Load All</button>
          <span id="assign-load-status" style="opacity:0.7;"></span>
        </div>
      </div>

      <!-- Users Tab -->
      <div id="users-tab" style="display: none;">
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 15px;">Learner Activity</h3>
          <div style="display:flex; gap:8px; margin-bottom:10px;">
            <button class="btn btn-secondary btn-small" id="filter-all" onclick="setApprovalFilter('all')" style="background:#4f8cff;">All</button>
            <button class="btn btn-secondary btn-small" id="filter-pending" onclick="setApprovalFilter('pending')">Pending</button>
            <button class="btn btn-secondary btn-small" id="filter-approved" onclick="setApprovalFilter('approved')">Approved</button>
          </div>
          <input type="text" id="user-search" placeholder="Search users..." oninput="renderUsers()" />
          <div id="user-list" class="item-list" style="margin-top: 12px;">
            <div class="loading">Loading users...</div>
          </div>
          <div style="display:flex; gap:10px; align-items:center; margin:10px 0;">
            <button class="btn btn-secondary" onclick="loadMoreUsers()">Load More</button>
            <button class="btn btn-secondary" onclick="loadAllUsers()">Load All</button>
            <span id="user-load-status" style="opacity:0.7;"></span>
          </div>
        </div>
        <div class="stat-card" style="text-align: left; margin-bottom: 20px;">
          <h3 style="font-size: 18px; margin-bottom: 15px;">User Roles</h3>
          <div class="form-group">
            <label>User Email</label>
            <input type="email" id="role-email" placeholder="user@example.com" />
          </div>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="btn btn-primary" onclick="setRoleForEmail('manager')">Set Manager</button>
            <button class="btn btn-secondary" onclick="setRoleForEmail('user')">Set User</button>
          </div>
        </div>
        <div id="roles-list" class="item-list">
          <div class="loading">Loading roles...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Question Editor Modal -->
  <div id="question-modal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h2 id="q-modal-title">Edit Question</h2>
        <button class="close-btn" onclick="closeQuestionModal()">&times;</button>
      </div>
      <form id="question-form">
        <div class="form-row">
          <div class="form-group">
            <label>Question ID</label>
            <input type="text" id="qf-id" readonly />
          </div>
          <div class="form-group" style="align-self:flex-end;">
            <button type="button" class="btn btn-secondary" onclick="generateQuestionId()">Generate ID</button>
          </div>
          <div class="form-group">
            <label>Category</label>
            <select id="qf-category"></select>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Subcategory</label>
            <input type="text" id="qf-subcategory" placeholder="e.g., Anatomy, Treatment..." />
          </div>
          <div class="form-group">
            <label>Difficulty</label>
            <select id="qf-difficulty">
              <option value="basic">Basic</option>
              <option value="intermediate">Intermediate</option>
              <option value="advanced">Advanced</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Tags (optional)</label>
          <input type="text" id="qf-tags" placeholder="anatomy, otology, key-point" list="tag-options" />
        </div>
        <div class="form-group">
          <label>Stem (Clinical Vignette)</label>
          <textarea id="qf-stem" rows="3"></textarea>
        </div>
        <div class="form-group">
          <label>Lead-in Question</label>
          <input type="text" id="qf-leadin" />
        </div>
        <div class="options-group">
          <label>Answer Options</label>
          <div class="option-item">
            <input type="checkbox" id="qf-correct-0" />
            <input type="text" id="qf-option-0" placeholder="Option A" />
            <span class="option-label">Correct?</span>
          </div>
          <div class="option-item">
            <input type="checkbox" id="qf-correct-1" />
            <input type="text" id="qf-option-1" placeholder="Option B" />
            <span class="option-label">Correct?</span>
          </div>
          <div class="option-item">
            <input type="checkbox" id="qf-correct-2" />
            <input type="text" id="qf-option-2" placeholder="Option C" />
            <span class="option-label">Correct?</span>
          </div>
          <div class="option-item">
            <input type="checkbox" id="qf-correct-3" />
            <input type="text" id="qf-option-3" placeholder="Option D" />
            <span class="option-label">Correct?</span>
          </div>
        </div>
        <div class="form-group">
          <label>Explanation</label>
          <textarea id="qf-explanation" rows="4"></textarea>
        </div>
        <div class="form-group">
          <label>Clinical Pearl</label>
          <textarea id="qf-keypoint" rows="2" placeholder="Short key point shown after the explanation"></textarea>
        </div>
        <div class="modal-actions">
          <button type="button" class="btn btn-danger" onclick="deleteQuestion()" id="q-delete-btn">Delete</button>
          <button type="button" class="btn btn-secondary" onclick="duplicateQuestion()">Duplicate</button>
          <button type="button" class="btn btn-secondary" onclick="closeQuestionModal()">Cancel</button>
          <button type="submit" class="btn btn-primary">Save Changes</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Flashcard Editor Modal -->
  <div id="flashcard-modal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h2 id="fc-modal-title">Edit Flashcard</h2>
        <button class="close-btn" onclick="closeFlashcardModal()">&times;</button>
      </div>
      <form id="flashcard-form">
        <div class="form-row">
          <div class="form-group">
            <label>Flashcard ID</label>
            <input type="text" id="fcf-id" readonly />
          </div>
          <div class="form-group">
            <label>Category</label>
            <select id="fcf-category">
              <option value="RHINOLOGY">Rhinology</option>
              <option value="OTOLOGY">Otology</option>
              <option value="LARYNGOLOGY">Laryngology</option>
              <option value="HEAD_NECK">Head & Neck</option>
              <option value="FACIAL_PLASTICS">Facial Plastics</option>
              <option value="PEDIATRICS">Pediatrics</option>
              <option value="SLEEP">Sleep</option>
            </select>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Subcategory</label>
            <input type="text" id="fcf-subcategory" placeholder="e.g., Nasal Anatomy" />
          </div>
          <div class="form-group">
            <label>Difficulty</label>
            <select id="fcf-difficulty">
              <option value="basic">Basic</option>
              <option value="intermediate">Intermediate</option>
              <option value="advanced">Advanced</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Cloze Text (preferred)</label>
          <textarea id="fcf-cloze" rows="3" placeholder="Use {{c::answer}} for cloze deletions"></textarea>
          <p class="hint">If cloze text is provided, it will be saved to the flashcard "text" field.</p>
        </div>
        <div class="form-group">
          <label>Notes (optional)</label>
          <textarea id="fcf-notes" rows="3" placeholder="Extra notes shown after answering"></textarea>
        </div>
        <div class="form-group">
          <label>Front (Question)</label>
          <textarea id="fcf-front" rows="3" placeholder="What is the question?"></textarea>
        </div>
        <div class="form-group">
          <label>Back (Answer)</label>
          <textarea id="fcf-back" rows="4" placeholder="The answer..."></textarea>
        </div>
        <div class="flashcard-preview">
          <div class="side front-side">
            <div class="side-label">Front</div>
            <div id="fc-preview-front">-</div>
          </div>
          <div class="side back-side">
            <div class="side-label">Back</div>
            <div id="fc-preview-back">-</div>
          </div>
        </div>
        <div class="form-group">
          <label>Related Questions (comma-separated IDs)</label>
          <input type="text" id="fcf-related-questions" placeholder="rhino_anat_001, rhino_anat_002" />
          <p class="hint">Link to question IDs for review suggestions</p>
        </div>
        <div class="form-group">
          <label>Related Reading</label>
          <input type="text" id="fcf-related-reading" placeholder="rhinology/01_nasal_anatomy.md" />
        </div>
        <div class="form-group">
          <label>Tags (comma-separated)</label>
          <input type="text" id="fcf-tags" placeholder="anatomy, high-yield, turbinates" list="tag-options" />
        </div>
        <div class="modal-actions">
          <button type="button" class="btn btn-danger" onclick="deleteFlashcard()" id="fc-delete-btn">Delete</button>
          <button type="button" class="btn btn-secondary" onclick="duplicateFlashcard()">Duplicate</button>
          <button type="button" class="btn btn-secondary" onclick="closeFlashcardModal()">Cancel</button>
          <button type="submit" class="btn btn-primary">Save Changes</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Reading Editor Modal -->
  <div id="reading-modal" class="modal-overlay">
    <div class="modal wide">
      <div class="modal-header">
        <h2 id="r-modal-title">Edit Reading</h2>
        <button class="close-btn" onclick="closeReadingModal()">&times;</button>
      </div>
      <form id="reading-form">
        <div class="form-row">
          <div class="form-group">
            <label>Reading ID</label>
            <input type="text" id="rf-id" readonly />
          </div>
          <div class="form-group">
            <label>Category</label>
            <select id="rf-category">
              <option value="facial_plastics">Facial Plastics</option>
              <option value="head_neck">Head & Neck Cancer</option>
              <option value="laryngology">Laryngology</option>
              <option value="otology">Otology</option>
              <option value="pediatrics">Pediatric ENT</option>
              <option value="rhinology">Allergy & Rhinology</option>
              <option value="sleep">Sleep Medicine</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Title</label>
          <input type="text" id="rf-title" />
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Reading Time (minutes)</label>
            <input type="number" id="rf-readingtime" min="1" />
          </div>
          <div class="form-group">
            <label>Word Count</label>
            <input type="number" id="rf-wordcount" min="0" />
          </div>
        </div>
        <div class="form-group">
          <label>Content (Markdown)</label>
          <textarea id="rf-content" class="large" rows="15"></textarea>
        </div>
        <div class="form-group">
          <label>Related Question IDs (optional)</label>
          <input type="text" id="rf-related-questions" placeholder="fp_analysis_001, fp_analysis_002" />
        </div>
        <div class="form-group">
          <label>Tags (comma separated)</label>
          <input type="text" id="rf-tags" placeholder="vascular, syndromes" list="tag-options" />
        </div>
      <div class="modal-actions">
        <button type="button" class="btn btn-danger" onclick="deleteReading()" id="r-delete-btn">Delete</button>
        <button type="button" class="btn btn-secondary" onclick="duplicateReading()">Duplicate</button>
        <button type="button" class="btn btn-secondary" onclick="closeReadingModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Save Changes</button>
      </div>
      </form>
    </div>
  </div>

  <!-- Report Modal -->
  <div id="report-modal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h2>Report Details</h2>
        <button class="close-btn" onclick="closeReportModal()">&times;</button>
      </div>
      <div id="report-details">
        <div class="form-group">
          <label>Report ID</label>
          <input type="text" id="rptf-id" readonly />
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Type</label>
            <input type="text" id="rptf-type" readonly />
          </div>
          <div class="form-group">
            <label>Item ID</label>
            <input type="text" id="rptf-item-id" readonly style="cursor:pointer;color:#4f8cff;" onclick="viewReportedItem()" />
          </div>
        </div>
        <div class="form-group">
          <label>Item Title</label>
          <input type="text" id="rptf-item-title" readonly />
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Status</label>
            <select id="rptf-status">
              <option value="pending">Pending</option>
              <option value="reviewed">Reviewed</option>
              <option value="resolved">Resolved</option>
              <option value="dismissed">Dismissed</option>
            </select>
          </div>
          <div class="form-group">
            <label>Submitted</label>
            <input type="text" id="rptf-date" readonly />
          </div>
        </div>
        <div class="form-group">
          <label>User</label>
          <input type="text" id="rptf-user" readonly />
        </div>
        <div class="form-group">
          <label>Description</label>
          <textarea id="rptf-description" readonly rows="4"></textarea>
        </div>
        <div class="form-group">
          <label>Reported Content</label>
          <textarea id="rptf-content" readonly rows="3" style="background: #1a1a2e; opacity: 0.8;"></textarea>
        </div>
        <div class="form-group">
          <label>Admin Notes</label>
          <textarea id="rptf-notes" rows="3" placeholder="Add notes about this report..."></textarea>
        </div>
      </div>
      <div class="modal-actions">
        <button type="button" class="btn btn-danger" onclick="deleteReport()">Delete</button>
        <button type="button" class="btn btn-secondary" onclick="closeReportModal()">Cancel</button>
        <button type="button" class="btn btn-success" onclick="updateReportStatus()">Save Changes</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <!-- ID Prefix Editor Modal -->
  <div id="prefix-modal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h2>Question ID Prefixes</h2>
        <button class="close-btn" onclick="closePrefixModal()">&times;</button>
      </div>
      <div class="form-group">
        <label>Prefix Map (JSON)</label>
        <textarea id="prefix-config" rows="8" placeholder='{"OTOLOGY":"oto","RHINOLOGY":"rhino"}'></textarea>
        <p class="hint">Keys should match category values. This is stored locally in your browser.</p>
      </div>
      <div class="modal-actions">
        <button type="button" class="btn btn-secondary" onclick="resetPrefixOverrides()">Reset to Defaults</button>
        <button type="button" class="btn btn-secondary" onclick="closePrefixModal()">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="savePrefixOverrides()">Save</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import { getFirestore, collection, doc, getDoc, getDocs, setDoc, deleteDoc, updateDoc, addDoc, query, where, serverTimestamp, orderBy, limit, startAfter, startAt, endAt, getCountFromServer, writeBatch } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    import { marked } from 'https://cdn.jsdelivr.net/npm/marked@12.0.2/lib/marked.esm.js';

    const firebaseConfig = {
      apiKey: "AIzaSyB_k1Sa8U-Ab-fiGAptjJ6D0RupuiA6uEk",
      authDomain: "ent-practice-app.firebaseapp.com",
      projectId: "ent-practice-app",
      storageBucket: "ent-practice-app.firebasestorage.app",
      messagingSenderId: "409735708262",
      appId: "1:409735708262:web:e4255fbdba1b350695f7a7"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // State
    let allQuestions = [], filteredQuestions = [], qPage = 1;
    let allFlashcards = [], filteredFlashcards = [], fcPage = 1;
    let allReadings = [], filteredReadings = [], rPage = 1;
    let allReports = [], filteredReports = [], rptPage = 1;
    let allAssignments = [];
    let allPresets = [];
    let allUsers = [];
    let allRoles = [];
    let tabLoaded = {
      questions: false,
      flashcards: false,
      readings: false,
      readingEditor: false,
      reports: false,
      assignments: false,
      users: false,
    };

    let qLastDoc = null, fcLastDoc = null, rLastDoc = null, rptLastDoc = null, assignLastDoc = null, userLastDoc = null;
    let qTotalCount = 0, fcTotalCount = 0, rTotalCount = 0, rptTotalCount = 0, assignTotalCount = 0, userTotalCount = 0;
    let qHasMore = true, fcHasMore = true, rHasMore = true, rptHasMore = true, assignHasMore = true, userHasMore = true;
    const pageSize = 20;
    const VALID_REPORT_STATUSES = new Set(['pending', 'reviewed', 'resolved', 'dismissed']);
    const REPORT_OPS_SERVER_TIMESTAMP = '__SERVER_TIMESTAMP__';
    const REPORT_REPAIR_BATCH_SIZE = 350;
    let reportsOpsLastScan = null;
    let reportsOpsBusy = false;
    let currentQuestion = null, currentFlashcard = null, currentReading = null, currentReport = null;
    let duplicateFlashcardSourceId = null, duplicateReadingSourceId = null;
    let duplicateSourceId = null;
    let duplicateCopyLinks = false;
    let qCategories = new Set(), fcCategories = new Set(), rCategories = new Set();
    let readingEditorSelectedId = null;

    const ADMIN_EMAILS = ['alexandria.l.harris@gmail.com'];
    const PREFIX_STORAGE_KEY = 'admin_category_prefixes';
    const CATEGORY_PREFIXES = {
      OTOLOGY: 'oto',
      RHINOLOGY: 'rhino',
      LARYNGOLOGY: 'lary',
      HEAD_NECK: 'hnc',
      FACIAL_PLASTICS: 'fp',
      PEDIATRICS: 'peds',
      SLEEP: 'sleep',
      ALLERGY: 'allergy',
      GENERAL: 'general',
    };
    const READING_CATEGORY_NAMES = {
      facial_plastics: 'Facial Plastics',
      head_neck: 'Head & Neck Cancer',
      laryngology: 'Laryngology',
      otology: 'Otology',
      pediatrics: 'Pediatric ENT',
      rhinology: 'Allergy & Rhinology',
      sleep: 'Sleep Medicine',
    };
    let categoryPrefixOverrides = {};

    const loadPrefixOverrides = () => {
      try {
        const raw = localStorage.getItem(PREFIX_STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') {
          categoryPrefixOverrides = parsed;
        }
      } catch (e) {
        console.warn('Failed to load prefix overrides:', e);
      }
    };

    const getActivePrefixMap = () => ({
      ...CATEGORY_PREFIXES,
      ...categoryPrefixOverrides,
    });

    loadPrefixOverrides();

    // Auth
    window.login = async () => {
      try {
        document.getElementById('auth-error').style.display = 'none';
        await signInWithEmailAndPassword(auth, document.getElementById('email').value, document.getElementById('password').value);
      } catch (e) {
        document.getElementById('auth-error').textContent = e.message;
        document.getElementById('auth-error').style.display = 'block';
      }
    };
    window.logout = () => signOut(auth);

    onAuthStateChanged(auth, user => {
      if (user && ADMIN_EMAILS.includes(user.email)) {
        document.getElementById('auth-container').style.display = 'none';
        document.getElementById('dashboard').style.display = 'block';
        document.getElementById('user-email').textContent = user.email;
        loadAllData();
      } else {
        document.getElementById('auth-container').style.display = 'flex';
        document.getElementById('dashboard').style.display = 'none';
        if (user && !ADMIN_EMAILS.includes(user.email)) {
          document.getElementById('auth-error').textContent = 'Access denied.';
          document.getElementById('auth-error').style.display = 'block';
          signOut(auth);
        }
      }
    });

    async function loadAllData() {
      await loadCounts();
      await loadQuestions();
      updateStats();
    }

    async function loadCounts() {
      try {
        const [qCount, fcCount, rCount, rptCount, assignCount, userCount, pendingRptCount] = await Promise.all([
          getCountFromServer(collection(db, 'questions')),
          getCountFromServer(collection(db, 'flashcards')),
          getCountFromServer(collection(db, 'readings')),
          getCountFromServer(collection(db, 'reports')),
          getCountFromServer(collection(db, 'assignments')),
          getCountFromServer(collection(db, 'users')),
          getCountFromServer(query(collection(db, 'reports'), where('status', '==', 'pending'))),
        ]);
        qTotalCount = qCount.data().count || 0;
        fcTotalCount = fcCount.data().count || 0;
        rTotalCount = rCount.data().count || 0;
        rptTotalCount = rptCount.data().count || 0;
        assignTotalCount = assignCount.data().count || 0;
        userTotalCount = userCount.data().count || 0;
        document.getElementById('total-reports').textContent = pendingRptCount.data().count || 0;
      } catch (e) {
        console.error('[Counts] Failed to load counts', e);
      }
    }

    async function loadQuestions(reset = true) {
      try {
        const baseQuery = query(collection(db, 'questions'), orderBy('__name__'), limit(pageSize));
        const snap = reset ? await getDocs(baseQuery) : await getDocs(query(collection(db, 'questions'), orderBy('__name__'), startAfter(qLastDoc), limit(pageSize)));
        if (reset) {
          allQuestions = [];
          qLastDoc = null;
          qHasMore = true;
          qPage = 1;
        }
        const pageItems = [];
        snap.forEach(d => pageItems.push({ id: d.id, ...d.data() }));
        if (pageItems.length > 0) {
          qLastDoc = snap.docs[snap.docs.length - 1];
        } else {
          qHasMore = false;
        }
        allQuestions = [...allQuestions, ...pageItems];
        qCategories = new Set();
        allQuestions.forEach(q => { if (q.category) qCategories.add(q.category); });
        allQuestions.sort((a, b) => a.id.localeCompare(b.id));
        populateFilter('q-category-filter', qCategories, 'qf-category');
        filterQuestions();
        updateTagOptions();
        updateLoadStatus('q-load-status', allQuestions.length, qTotalCount, qHasMore);
        if (reset) tabLoaded.questions = true;
      } catch (e) { console.error(e); }
    }

    async function loadFlashcards(reset = true) {
      try {
        const baseQuery = query(collection(db, 'flashcards'), orderBy('__name__'), limit(pageSize));
        const snap = reset ? await getDocs(baseQuery) : await getDocs(query(collection(db, 'flashcards'), orderBy('__name__'), startAfter(fcLastDoc), limit(pageSize)));
        if (reset) {
          allFlashcards = [];
          fcLastDoc = null;
          fcHasMore = true;
          fcPage = 1;
        }
        const pageItems = [];
        snap.forEach(d => pageItems.push({ id: d.id, ...d.data() }));
        if (pageItems.length > 0) {
          fcLastDoc = snap.docs[snap.docs.length - 1];
        } else {
          fcHasMore = false;
        }
        allFlashcards = [...allFlashcards, ...pageItems];
        allFlashcards.sort((a, b) => a.id.localeCompare(b.id));
        fcCategories = new Set();
        allFlashcards.forEach(fc => { if (fc.category) fcCategories.add(fc.category); });
        populateFilter('fc-category-filter', fcCategories);
        filterFlashcards();
        updateTagOptions();
        updateLoadStatus('fc-load-status', allFlashcards.length, fcTotalCount, fcHasMore);
        if (reset) tabLoaded.flashcards = true;
      } catch (e) { console.error(e); document.getElementById('flashcard-list').innerHTML = '<div class="loading">No flashcards found.</div>'; }
    }

    async function loadReadings(reset = true) {
      try {
        const baseQuery = query(collection(db, 'readings'), orderBy('__name__'), limit(pageSize));
        const snap = reset ? await getDocs(baseQuery) : await getDocs(query(collection(db, 'readings'), orderBy('__name__'), startAfter(rLastDoc), limit(pageSize)));
        if (reset) {
          allReadings = [];
          rLastDoc = null;
          rHasMore = true;
          rPage = 1;
        }
        const pageItems = [];
        snap.forEach(d => pageItems.push({ id: d.id, ...d.data() }));
        if (pageItems.length > 0) {
          rLastDoc = snap.docs[snap.docs.length - 1];
        } else {
          rHasMore = false;
        }
        allReadings = [...allReadings, ...pageItems];
        allReadings.sort((a, b) => a.id.localeCompare(b.id));
        rCategories = new Set();
        allReadings.forEach(r => { if (r.category) rCategories.add(r.category); });
        populateFilter('r-category-filter', rCategories);
        filterReadings();
        updateTagOptions();
        updateLoadStatus('r-load-status', allReadings.length, rTotalCount, rHasMore);
        if (reset) tabLoaded.readings = true;
      } catch (e) { console.error(e); document.getElementById('reading-list').innerHTML = '<div class="loading">No readings found.</div>'; }
    }

    async function loadReports(reset = true) {
      try {
        const baseQuery = query(collection(db, 'reports'), orderBy('createdAt', 'desc'), limit(pageSize));
        const snap = reset ? await getDocs(baseQuery) : await getDocs(query(collection(db, 'reports'), orderBy('createdAt', 'desc'), startAfter(rptLastDoc), limit(pageSize)));
        if (reset) {
          allReports = [];
          rptLastDoc = null;
          rptHasMore = true;
          rptPage = 1;
        }
        const pageItems = [];
        snap.forEach(d => {
          const r = { ...d.data(), cloudId: d.id };
          if (r.createdAt?.toDate) r.createdAt = r.createdAt.toDate();
          if (r.updatedAt?.toDate) r.updatedAt = r.updatedAt.toDate();
          pageItems.push(r);
        });
        if (pageItems.length > 0) {
          rptLastDoc = snap.docs[snap.docs.length - 1];
        } else {
          rptHasMore = false;
        }
        allReports = [...allReports, ...pageItems];
        allReports.sort((a, b) => (b.createdAt?.getTime?.() || b.createdAt || 0) - (a.createdAt?.getTime?.() || a.createdAt || 0));
        filterReports();
        updateLoadStatus('rpt-load-status', allReports.length, rptTotalCount, rptHasMore);
        if (reset) tabLoaded.reports = true;
      } catch (e) {
        console.error(e);
        document.getElementById('report-list').innerHTML = '<div class="loading">No reports found.</div>';
      }
    }

    async function loadAssignments(reset = true) {
      try {
        const baseQuery = query(collection(db, 'assignments'), orderBy('createdAt', 'desc'), limit(pageSize));
        const snap = reset ? await getDocs(baseQuery) : await getDocs(query(collection(db, 'assignments'), orderBy('createdAt', 'desc'), startAfter(assignLastDoc), limit(pageSize)));
        if (reset) {
          allAssignments = [];
          assignLastDoc = null;
          assignHasMore = true;
        }
        const pageItems = [];
        snap.forEach(d => pageItems.push({ id: d.id, ...d.data() }));
        if (pageItems.length > 0) {
          assignLastDoc = snap.docs[snap.docs.length - 1];
        } else {
          assignHasMore = false;
        }
        allAssignments = [...allAssignments, ...pageItems];
        allAssignments.sort((a, b) => {
          const at = a.createdAt?.toMillis ? a.createdAt.toMillis() : (a.createdAt || 0);
          const bt = b.createdAt?.toMillis ? b.createdAt.toMillis() : (b.createdAt || 0);
          return bt - at;
        });
        renderAssignments();
        renderAssignmentSummary();
        updateLoadStatus('assign-load-status', allAssignments.length, assignTotalCount, assignHasMore);
        if (reset) tabLoaded.assignments = true;
      } catch (e) {
        console.error(e);
        document.getElementById('assignment-list').innerHTML = '<div class="loading">No assignments found.</div>';
      }
    }

    async function loadPresets() {
      try {
        const snap = await getDocs(collection(db, 'assignmentPresets'));
        allPresets = [];
        snap.forEach(d => allPresets.push({ id: d.id, ...d.data() }));
        allPresets.sort((a, b) => {
          const at = a.createdAt?.toMillis ? a.createdAt.toMillis() : (a.createdAt || 0);
          const bt = b.createdAt?.toMillis ? b.createdAt.toMillis() : (b.createdAt || 0);
          return bt - at;
        });
        renderPresets();
      } catch (e) {
        console.error(e);
        document.getElementById('assignment-presets').innerHTML = '<div class="loading">No presets found.</div>';
      }
    }

    async function loadUsers(reset = true) {
      try {
        const baseQuery = query(collection(db, 'users'), orderBy('lastActiveAt', 'desc'), limit(pageSize));
        const snap = reset ? await getDocs(baseQuery) : await getDocs(query(collection(db, 'users'), orderBy('lastActiveAt', 'desc'), startAfter(userLastDoc), limit(pageSize)));
        if (reset) {
          allUsers = [];
          userLastDoc = null;
          userHasMore = true;
        }
        const pageItems = [];
        snap.forEach(d => pageItems.push({ id: d.id, ...d.data() }));
        if (pageItems.length > 0) {
          userLastDoc = snap.docs[snap.docs.length - 1];
        } else {
          userHasMore = false;
        }
        allUsers = [...allUsers, ...pageItems];
        allUsers.sort((a, b) => {
          const at = a.lastActiveAt ? new Date(a.lastActiveAt).getTime() : 0;
          const bt = b.lastActiveAt ? new Date(b.lastActiveAt).getTime() : 0;
          return bt - at;
        });
        renderUsers();
        updateLoadStatus('user-load-status', allUsers.length, userTotalCount, userHasMore);
        if (reset) tabLoaded.users = true;
      } catch (e) {
        console.error(e);
        document.getElementById('user-list').innerHTML = '<div class="loading">No users found.</div>';
      }
    }

    window.loadMoreQuestions = async () => {
      if (!qHasMore) return;
      await loadQuestions(false);
    };
    window.loadAllQuestions = async () => {
      if (!confirm('Load all questions? This will increase Firestore reads.')) return;
      await loadAllPages({
        loadMore: () => loadQuestions(false),
        hasMore: () => qHasMore,
        loadedCount: () => allQuestions.length,
      });
    };
    window.loadMoreFlashcards = async () => {
      if (!fcHasMore) return;
      await loadFlashcards(false);
    };
    window.loadAllFlashcards = async () => {
      if (!confirm('Load all flashcards? This will increase Firestore reads.')) return;
      await loadAllPages({
        loadMore: () => loadFlashcards(false),
        hasMore: () => fcHasMore,
        loadedCount: () => allFlashcards.length,
      });
    };
    window.loadMoreReadings = async () => {
      if (!rHasMore) return;
      await loadReadings(false);
    };
    window.loadAllReadings = async () => {
      if (!confirm('Load all readings? This will increase Firestore reads.')) return;
      await loadAllPages({
        loadMore: () => loadReadings(false),
        hasMore: () => rHasMore,
        loadedCount: () => allReadings.length,
      });
    };
    window.loadMoreReports = async () => {
      if (!rptHasMore) return;
      await loadReports(false);
    };
    window.loadAllReports = async () => {
      if (!confirm('Load all reports? This will increase Firestore reads.')) return;
      await loadAllPages({
        loadMore: () => loadReports(false),
        hasMore: () => rptHasMore,
        loadedCount: () => allReports.length,
      });
    };
    window.loadMoreAssignments = async () => {
      if (!assignHasMore) return;
      await loadAssignments(false);
    };
    window.loadAllAssignments = async () => {
      if (!confirm('Load all assignments? This will increase Firestore reads.')) return;
      await loadAllPages({
        loadMore: () => loadAssignments(false),
        hasMore: () => assignHasMore,
        loadedCount: () => allAssignments.length,
      });
    };
    window.loadMoreUsers = async () => {
      if (!userHasMore) return;
      await loadUsers(false);
    };
    window.loadAllUsers = async () => {
      if (!confirm('Load all users? This will increase Firestore reads.')) return;
      await loadAllPages({
        loadMore: () => loadUsers(false),
        hasMore: () => userHasMore,
        loadedCount: () => allUsers.length,
      });
    };

    async function loadRoles() {
      try {
        const snap = await getDocs(collection(db, 'userRoles'));
        allRoles = [];
        snap.forEach(d => {
          allRoles.push({ id: d.id, ...d.data() });
        });
        renderRoles();
      } catch (e) {
        console.error(e);
        document.getElementById('roles-list').innerHTML = '<div class="loading">No roles found.</div>';
      }
    }

    function updateStats() {
      document.getElementById('total-questions').textContent = qTotalCount || allQuestions.length;
      document.getElementById('total-flashcards').textContent = fcTotalCount || allFlashcards.length;
      document.getElementById('total-readings').textContent = rTotalCount || allReadings.length;
      const canComputeLinked = allFlashcards.length > 0 || fcTotalCount === 0;
      const linked = canComputeLinked ? allFlashcards.filter(fc => fc.relatedQuestions?.length > 0).length : 0;
      document.getElementById('total-linked').textContent = canComputeLinked && linked ? `${linked}+` : '—';
    }

    function populateFilter(selectId, categories, editorSelectId) {
      const sel = document.getElementById(selectId);
      sel.innerHTML = '<option value="">All Categories</option>';
      Array.from(categories).sort().forEach(c => sel.innerHTML += `<option value="${c}">${c}</option>`);
      if (editorSelectId) {
        const ed = document.getElementById(editorSelectId);
        ed.innerHTML = '';
        Array.from(categories).sort().forEach(c => ed.innerHTML += `<option value="${c}">${c}</option>`);
      }
    }

    // Filters
    window.filterQuestions = () => {
      const search = document.getElementById('q-search').value.toLowerCase();
      const cat = document.getElementById('q-category-filter').value;
      filteredQuestions = allQuestions.filter(q => !q.deletedAt && (!search || getQuestionSearchText(q).includes(search)) && (!cat || q.category === cat));
      qPage = 1; renderList('questions');
    };
    window.filterFlashcards = () => {
      const search = document.getElementById('fc-search').value.toLowerCase();
      const cat = document.getElementById('fc-category-filter').value;
      filteredFlashcards = allFlashcards.filter(fc => !fc.deletedAt && (!search || getFlashcardSearchText(fc).includes(search)) && (!cat || fc.category === cat));
      fcPage = 1; renderList('flashcards');
    };
    window.filterReadings = () => {
      const search = document.getElementById('r-search').value.toLowerCase();
      const cat = document.getElementById('r-category-filter').value;
      filteredReadings = allReadings.filter(r => !r.deletedAt && (!search || getReadingSearchText(r).includes(search)) && (!cat || r.category === cat));
      rPage = 1; renderList('readings');
    };
    window.filterReports = () => {
      const search = document.getElementById('report-search').value.toLowerCase();
      const status = document.getElementById('report-status-filter').value;
      const type = document.getElementById('report-type-filter').value;
      filteredReports = allReports.filter(r => (!search || getReportSearchText(r).includes(search)) && (!status || r.status === status) && (!type || r.type === type));
      rptPage = 1; renderReports();
    };

    // Render
    function renderList(type) {
      const config = {
        questions: { items: filteredQuestions, page: qPage, container: 'question-list', prevBtn: 'q-prev-btn', nextBtn: 'q-next-btn', pageInfo: 'q-page-info' },
        flashcards: { items: filteredFlashcards, page: fcPage, container: 'flashcard-list', prevBtn: 'fc-prev-btn', nextBtn: 'fc-next-btn', pageInfo: 'fc-page-info' },
        readings: { items: filteredReadings, page: rPage, container: 'reading-list', prevBtn: 'r-prev-btn', nextBtn: 'r-next-btn', pageInfo: 'r-page-info' }
      }[type];

      const { items, page, container, prevBtn, nextBtn, pageInfo } = config;
      const start = (page - 1) * pageSize;
      const pageItems = items.slice(start, start + pageSize);
      const totalPages = Math.ceil(items.length / pageSize) || 1;
      const cont = document.getElementById(container);

      if (pageItems.length === 0) {
        cont.innerHTML = '<div class="loading">No items found</div>';
      } else if (type === 'questions') {
        cont.innerHTML = pageItems.map(q => `
          <div class="item-card" onclick="editQuestion('${q.id}')">
            <div class="item-controls" onclick="event.stopPropagation()">
              <input type="checkbox" class="bulk-select" data-type="questions" value="${q.id}" onclick="event.stopPropagation()" />
              <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); editQuestion('${q.id}')">Edit</button>
              <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); toggleQuickEdit(event, 'questions', '${q.id}')">Quick Edit</button>
              <button class="btn btn-danger btn-small" onclick="event.stopPropagation(); softDeleteItem('questions', '${q.id}')">Delete</button>
            </div>
            <div class="id">${q.id}</div>
            <div class="title">${escapeHtml(q.stem || 'No stem')}</div>
            <div class="meta">
              <span class="tag tag-blue">${q.category || 'Uncategorized'}</span>
              <span>${q.difficulty || '-'}</span>
              <span>${q.options?.length || 0} options</span>
            </div>
            <div class="quick-edit" id="qe-questions-${toDomId(q.id)}" onclick="event.stopPropagation()">
              <textarea id="qe-q-stem-${toDomId(q.id)}" rows="2" placeholder="Stem">${escapeHtml(q.stem || '')}</textarea>
              <input id="qe-q-leadin-${toDomId(q.id)}" type="text" placeholder="Lead-in" value="${escapeHtml(q.leadIn || '')}" />
              <select id="qe-q-difficulty-${toDomId(q.id)}">
                <option value="basic" ${q.difficulty === 'basic' ? 'selected' : ''}>Basic</option>
                <option value="intermediate" ${q.difficulty === 'intermediate' ? 'selected' : ''}>Intermediate</option>
                <option value="advanced" ${q.difficulty === 'advanced' ? 'selected' : ''}>Advanced</option>
              </select>
              <input id="qe-q-keypoint-${toDomId(q.id)}" type="text" placeholder="Clinical Pearl" value="${escapeHtml(q.keyPoint || '')}" />
              <div class="quick-edit-actions">
                <button class="btn btn-secondary btn-small" onclick="toggleQuickEdit(event, 'questions', '${q.id}')">Close</button>
                <button class="btn btn-primary btn-small" onclick="saveQuickEditQuestion(event, '${q.id}')">Save</button>
              </div>
            </div>
          </div>`).join('');
      } else if (type === 'flashcards') {
        cont.innerHTML = pageItems.map(fc => `
          <div class="item-card" onclick="editFlashcard('${fc.id}')">
            <div class="item-controls" onclick="event.stopPropagation()">
              <input type="checkbox" class="bulk-select" data-type="flashcards" value="${fc.id}" onclick="event.stopPropagation()" />
              <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); editFlashcard('${fc.id}')">Edit</button>
              <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); toggleQuickEdit(event, 'flashcards', '${fc.id}')">Quick Edit</button>
              <button class="btn btn-danger btn-small" onclick="event.stopPropagation(); softDeleteItem('flashcards', '${fc.id}')">Delete</button>
            </div>
            <div class="id">${fc.id}</div>
            <div class="title">${escapeHtml(fc.front || 'No front')}</div>
            <div class="preview">${escapeHtml(fc.back || '')}</div>
            <div class="meta">
              <span class="tag tag-purple">${fc.category || 'Uncategorized'}</span>
              <span class="tag tag-blue">${fc.subcategory || ''}</span>
              ${fc.relatedQuestions?.length ? '<span class="tag tag-green">Linked</span>' : ''}
              ${fc.tags?.length ? `<span>${fc.tags.length} tags</span>` : ''}
            </div>
            <div class="quick-edit" id="qe-flashcards-${toDomId(fc.id)}" onclick="event.stopPropagation()">
              <textarea id="qe-fc-front-${toDomId(fc.id)}" rows="2" placeholder="Front">${escapeHtml(fc.front || '')}</textarea>
              <textarea id="qe-fc-back-${toDomId(fc.id)}" rows="2" placeholder="Back">${escapeHtml(fc.back || '')}</textarea>
              <textarea id="qe-fc-cloze-${toDomId(fc.id)}" rows="2" placeholder="Cloze text">${escapeHtml(fc.text || '')}</textarea>
              <input id="qe-fc-tags-${toDomId(fc.id)}" type="text" placeholder="Tags (comma)" value="${escapeHtml((fc.tags || []).join(', '))}" list="tag-options" />
              <div class="quick-edit-actions">
                <button class="btn btn-secondary btn-small" onclick="toggleQuickEdit(event, 'flashcards', '${fc.id}')">Close</button>
                <button class="btn btn-primary btn-small" onclick="saveQuickEditFlashcard(event, '${fc.id}')">Save</button>
              </div>
            </div>
          </div>`).join('');
      } else if (type === 'readings') {
        cont.innerHTML = pageItems.map(r => `
          <div class="item-card" onclick="editReading('${r.id}')">
            <div class="item-controls" onclick="event.stopPropagation()">
              <input type="checkbox" class="bulk-select" data-type="readings" value="${r.id}" onclick="event.stopPropagation()" />
              <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); editReading('${r.id}')">Edit</button>
              <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); toggleQuickEdit(event, 'readings', '${r.id}')">Quick Edit</button>
              <button class="btn btn-danger btn-small" onclick="event.stopPropagation(); softDeleteItem('readings', '${r.id}')">Delete</button>
            </div>
            <div class="id">${r.id}</div>
            <div class="title">${escapeHtml(r.title || 'Untitled')}</div>
            <div class="preview">${escapeHtml(r.content?.substring(0, 100).replace(/#/g, '') || '')}...</div>
            <div class="meta">
              <span class="tag tag-blue">${r.categoryName || r.category || ''}</span>
              <span>${r.readingTime || '?'} min</span>
              <span>${r.wordCount || 0} words</span>
            </div>
            <div class="quick-edit" id="qe-readings-${toDomId(r.id)}" onclick="event.stopPropagation()">
              <input id="qe-r-title-${toDomId(r.id)}" type="text" placeholder="Title" value="${escapeHtml(r.title || '')}" />
              <input id="qe-r-time-${toDomId(r.id)}" type="number" min="1" placeholder="Reading time" value="${escapeHtml(r.readingTime || 5)}" />
              <input id="qe-r-tags-${toDomId(r.id)}" type="text" placeholder="Tags (comma)" value="${escapeHtml((r.tags || []).join(', '))}" list="tag-options" />
              <div class="quick-edit-actions">
                <button class="btn btn-secondary btn-small" onclick="toggleQuickEdit(event, 'readings', '${r.id}')">Close</button>
                <button class="btn btn-primary btn-small" onclick="saveQuickEditReading(event, '${r.id}')">Save</button>
              </div>
            </div>
          </div>`).join('');
      }

      document.getElementById(pageInfo).textContent = `Page ${page} of ${totalPages}`;
      document.getElementById(prevBtn).disabled = page === 1;
      document.getElementById(nextBtn).disabled = page >= totalPages;
    }

    window.renderTrash = async () => {
      const type = document.getElementById('trash-type-filter').value;
      const cont = document.getElementById('trash-list');
      if (!tabLoaded.questions) await loadQuestions();
      if (!tabLoaded.flashcards) await loadFlashcards();
      if (!tabLoaded.readings) await loadReadings();
      const source = {
        questions: allQuestions,
        flashcards: allFlashcards,
        readings: allReadings,
      }[type] || [];
      const trashed = source.filter(item => item?.deletedAt);
      if (!trashed.length) {
        cont.innerHTML = '<div class="loading">No trashed items found.</div>';
        return;
      }
      cont.innerHTML = trashed.map(item => {
        const title = type === 'questions'
          ? (item.stem || item.leadIn || 'Untitled')
          : type === 'flashcards'
            ? (item.front || item.text || 'Flashcard')
            : (item.title || 'Reading');
        const deleted = item.deletedAt ? new Date(item.deletedAt).toLocaleString() : '—';
        return `
          <div class="item-card">
            <div class="id">${item.id}</div>
            <div class="title">${escapeHtml(title)}</div>
            <div class="meta">
              <span class="tag trash-tag">Deleted</span>
              <span>${deleted}</span>
            </div>
            <div class="actions">
              <button class="btn btn-secondary btn-small" onclick="restoreItem('${type}', '${item.id}')">Restore</button>
              <button class="btn btn-danger btn-small" onclick="permanentlyDeleteItem('${type}', '${item.id}')">Delete Permanently</button>
            </div>
          </div>
        `;
      }).join('');
    };

    // Render reports separately (different structure)
    function renderReports() {
      const start = (rptPage - 1) * pageSize;
      const pageItems = filteredReports.slice(start, start + pageSize);
      const totalPages = Math.ceil(filteredReports.length / pageSize) || 1;
      const cont = document.getElementById('report-list');

      const getStatusColor = (status) => {
        switch(status) {
          case 'pending': return 'tag-orange';
          case 'reviewed': return 'tag-blue';
          case 'resolved': return 'tag-green';
          case 'dismissed': return 'tag-purple';
          default: return '';
        }
      };

      if (pageItems.length === 0) {
        cont.innerHTML = '<div class="loading">No reports found</div>';
      } else {
        cont.innerHTML = pageItems.map(r => {
          const date = r.timestamp ? new Date(r.timestamp).toLocaleDateString() : (r.createdAt ? r.createdAt.toLocaleDateString() : 'Unknown');
          const title = r.itemTitle || r.itemId || 'Reported item';
          const content = r.itemContent || '';
          return `
            <div class="item-card" onclick="viewReport('${r.id}')">
              <div class="id">${r.itemId || 'Unknown Item'}</div>
              <div class="title">${r.description?.substring(0, 100) || 'No description'}${r.description?.length > 100 ? '...' : ''}</div>
              <div class="report-title">${title}</div>
              ${content ? `<div class="report-content">${content.substring(0, 200)}${content.length > 200 ? '...' : ''}</div>` : ''}
              <div class="meta">
                <span class="tag ${getStatusColor(r.status)}">${r.status || 'pending'}</span>
                <span class="tag ${r.type === 'question' ? 'tag-blue' : 'tag-purple'}">${r.type || 'unknown'}</span>
                <span>${date}</span>
                <span>${r.userEmail || 'anonymous'}</span>
              </div>
              <div class="actions">
                <button class="btn btn-secondary btn-small" onclick="openReportedItemById(event, '${r.id}')">Edit Item</button>
                <button class="btn btn-primary btn-small" onclick="openAndResolveReport(event, '${r.cloudId || r.id}')">Open & Resolve</button>
                <button class="btn btn-success btn-small" onclick="quickUpdateReportStatus(event, '${r.cloudId || r.id}', 'resolved')">Resolve</button>
                <button class="btn btn-secondary btn-small" onclick="quickUpdateReportStatus(event, '${r.cloudId || r.id}', 'reviewed')">Review</button>
                <button class="btn btn-danger btn-small" onclick="quickUpdateReportStatus(event, '${r.cloudId || r.id}', 'dismissed')">Dismiss</button>
              </div>
            </div>`;
        }).join('');
      }

      document.getElementById('rpt-page-info').textContent = `Page ${rptPage} of ${totalPages}`;
      document.getElementById('rpt-prev-btn').disabled = rptPage === 1;
      document.getElementById('rpt-next-btn').disabled = rptPage >= totalPages;
    }

    // Pagination
    window.prevPage = (type) => {
      if (type === 'questions' && qPage > 1) { qPage--; renderList('questions'); }
      if (type === 'flashcards' && fcPage > 1) { fcPage--; renderList('flashcards'); }
      if (type === 'readings' && rPage > 1) { rPage--; renderList('readings'); }
      if (type === 'reports' && rptPage > 1) { rptPage--; renderReports(); }
    };
    window.nextPage = (type) => {
      if (type === 'questions') { const total = Math.ceil(filteredQuestions.length / pageSize); if (qPage < total) { qPage++; renderList('questions'); } }
      if (type === 'flashcards') { const total = Math.ceil(filteredFlashcards.length / pageSize); if (fcPage < total) { fcPage++; renderList('flashcards'); } }
      if (type === 'readings') { const total = Math.ceil(filteredReadings.length / pageSize); if (rPage < total) { rPage++; renderList('readings'); } }
      if (type === 'reports') { const total = Math.ceil(filteredReports.length / pageSize); if (rptPage < total) { rptPage++; renderReports(); } }
    };

    const resolveCollection = (type) => ({
      questions: 'questions',
      flashcards: 'flashcards',
      readings: 'readings',
    }[type]);

    window.softDeleteItem = async (type, id) => {
      const collectionName = resolveCollection(type);
      if (!collectionName || !id) return;
      if (!confirm(`Move ${id} to Trash?`)) return;
      try {
        await updateDoc(doc(db, collectionName, id), {
          deletedAt: Date.now(),
          deletedBy: auth.currentUser?.uid || null,
          updatedAt: new Date().toISOString(),
        });
        const list = type === 'questions' ? allQuestions : type === 'flashcards' ? allFlashcards : allReadings;
        const item = list.find(i => i.id === id);
        if (item) item.deletedAt = Date.now();
        showToast('Moved to Trash');
        if (type === 'questions') filterQuestions();
        if (type === 'flashcards') filterFlashcards();
        if (type === 'readings') filterReadings();
        renderTrash();
      } catch (e) {
        showToast('Failed to delete.', true);
      }
    };

    window.restoreItem = async (type, id) => {
      const collectionName = resolveCollection(type);
      if (!collectionName || !id) return;
      try {
        await updateDoc(doc(db, collectionName, id), {
          deletedAt: null,
          deletedBy: null,
          updatedAt: new Date().toISOString(),
        });
        const list = type === 'questions' ? allQuestions : type === 'flashcards' ? allFlashcards : allReadings;
        const item = list.find(i => i.id === id);
        if (item) {
          delete item.deletedAt;
          delete item.deletedBy;
        }
        showToast('Restored');
        if (type === 'questions') filterQuestions();
        if (type === 'flashcards') filterFlashcards();
        if (type === 'readings') filterReadings();
        renderTrash();
      } catch (e) {
        showToast('Failed to restore.', true);
      }
    };

    window.permanentlyDeleteItem = async (type, id) => {
      const collectionName = resolveCollection(type);
      if (!collectionName || !id) return;
      if (!confirm(`Permanently delete ${id}? This cannot be undone.`)) return;
      try {
        await deleteDoc(doc(db, collectionName, id));
        const list = type === 'questions' ? allQuestions : type === 'flashcards' ? allFlashcards : allReadings;
        const idx = list.findIndex(i => i.id === id);
        if (idx >= 0) list.splice(idx, 1);
        showToast('Deleted permanently');
        if (type === 'questions') filterQuestions();
        if (type === 'flashcards') filterFlashcards();
        if (type === 'readings') filterReadings();
        renderTrash();
      } catch (e) {
        showToast('Failed to delete.', true);
      }
    };

    // Question CRUD
    const fillQuestionForm = (question) => {
      const data = question || {};
      document.getElementById('qf-category').value = data.category || '';
      document.getElementById('qf-subcategory').value = data.subcategory || '';
      document.getElementById('qf-difficulty').value = data.difficulty || 'intermediate';
      document.getElementById('qf-tags').value = (data.tags || []).join(', ');
      document.getElementById('qf-stem').value = data.stem || '';
      document.getElementById('qf-leadin').value = data.leadIn || '';
      document.getElementById('qf-explanation').value = data.explanation || '';
      document.getElementById('qf-keypoint').value = data.keyPoint || '';
      const opts = data.options || [];
      const normalizedOptions = opts.map(opt => (typeof opt === 'string' ? opt : opt?.text || ''));
      const fallbackCorrectIndex = opts.findIndex(opt => opt?.isCorrect);
      const correctIndex = Number.isFinite(data.correctIndex)
        ? data.correctIndex
        : (fallbackCorrectIndex >= 0 ? fallbackCorrectIndex : 0);
      for (let i = 0; i < 4; i++) {
        document.getElementById(`qf-option-${i}`).value = normalizedOptions[i] || '';
        document.getElementById(`qf-correct-${i}`).checked = i === correctIndex;
      }
    };

    window.editQuestion = (id) => {
      currentQuestion = allQuestions.find(q => q.id === id);
      if (!currentQuestion) return;
      duplicateSourceId = null;
      duplicateCopyLinks = false;
      document.getElementById('q-modal-title').textContent = 'Edit Question';
      document.getElementById('q-delete-btn').style.display = 'inline-block';
      document.getElementById('qf-id').value = currentQuestion.id;
      fillQuestionForm(currentQuestion);
      document.getElementById('question-modal').classList.add('active');
    };
    window.duplicateQuestion = () => {
      if (!currentQuestion) return;
      const defaultId = `${currentQuestion.id}_copy_${Date.now()}`;
      const newId = prompt('New question ID', defaultId);
      if (!newId) return;
      duplicateSourceId = currentQuestion.id;
      duplicateCopyLinks = confirm('Copy linked flashcards/readings to the new question?');
      document.getElementById('q-modal-title').textContent = 'Duplicate Question';
      document.getElementById('q-delete-btn').style.display = 'none';
      document.getElementById('qf-id').value = newId.trim();
      fillQuestionForm(currentQuestion);
      document.getElementById('question-modal').classList.add('active');
    };
    window.openNewQuestion = () => {
      currentQuestion = null;
      duplicateSourceId = null;
      duplicateCopyLinks = false;
      document.getElementById('q-modal-title').textContent = 'New Question';
      document.getElementById('q-delete-btn').style.display = 'none';
      document.getElementById('qf-id').value = `new_${Date.now()}`;
      fillQuestionForm(null);
      document.getElementById('question-modal').classList.add('active');
    };
    window.closeQuestionModal = () => {
      document.getElementById('question-modal').classList.remove('active');
      currentQuestion = null;
      duplicateSourceId = null;
      duplicateCopyLinks = false;
    };
    window.deleteQuestion = async () => {
      if (!currentQuestion) return;
      await softDeleteItem('questions', currentQuestion.id);
      closeQuestionModal();
    };
    async function copyQuestionLinks(sourceId, newId) {
      if (!sourceId || !newId || sourceId === newId) return;
      const updatedAt = new Date().toISOString();
      const fcSnap = await getDocs(query(collection(db, 'flashcards'), where('relatedQuestions', 'array-contains', sourceId)));
      const rSnap = await getDocs(query(collection(db, 'readings'), where('questionIds', 'array-contains', sourceId)));
      const rAltSnap = await getDocs(query(collection(db, 'readings'), where('relatedQuestions', 'array-contains', sourceId)));
      const rDocs = new Map();
      rSnap.forEach(d => rDocs.set(d.id, d));
      rAltSnap.forEach(d => rDocs.set(d.id, d));

      const updates = [];
      fcSnap.forEach(d => {
        const data = d.data() || {};
        const existing = data.relatedQuestions || [];
        const next = Array.from(new Set([...existing, newId]));
        updates.push(updateDoc(d.ref, { relatedQuestions: next, updatedAt }));
      });
      rDocs.forEach(d => {
        const data = d.data() || {};
        const existing = data.questionIds || data.relatedQuestions || [];
        const next = Array.from(new Set([...existing, newId]));
        const payload = { questionIds: next, updatedAt };
        if (Array.isArray(data.relatedQuestions)) {
          payload.relatedQuestions = next;
        }
        updates.push(updateDoc(d.ref, payload));
      });
      await Promise.all(updates);
      await Promise.all([loadFlashcards(), loadReadings()]);
    }

    document.getElementById('question-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const id = document.getElementById('qf-id').value;
      const options = [];
      let correctIndex = 0;
      for (let i = 0; i < 4; i++) {
        const text = document.getElementById(`qf-option-${i}`).value.trim();
        if (text) {
          options.push(text);
          if (document.getElementById(`qf-correct-${i}`).checked) {
            correctIndex = options.length - 1;
          }
        }
      }
      try {
        const docRef = doc(db, 'questions', id);
        const existingDoc = await getDoc(docRef);
        if (existingDoc.exists() && (!currentQuestion || currentQuestion.id !== id)) {
          showToast(`ID already exists: ${id}`, true);
          return;
        }
        await setDoc(docRef, {
          id, category: document.getElementById('qf-category').value, subcategory: document.getElementById('qf-subcategory').value,
          difficulty: document.getElementById('qf-difficulty').value, stem: document.getElementById('qf-stem').value,
          leadIn: document.getElementById('qf-leadin').value, explanation: document.getElementById('qf-explanation').value,
          keyPoint: document.getElementById('qf-keypoint').value,
          tags: document.getElementById('qf-tags').value.split(',').map(s => s.trim()).filter(Boolean),
          options, correctIndex, updatedAt: new Date().toISOString()
        });
        if (duplicateSourceId && duplicateCopyLinks) {
          await copyQuestionLinks(duplicateSourceId, id);
        }
        duplicateSourceId = null;
        duplicateCopyLinks = false;
        showToast('Saved!'); closeQuestionModal(); loadQuestions();
      } catch (e) { showToast(e.message, true); }
    });

    function renderAssignments() {
      const cont = document.getElementById('assignment-list');
      if (!allAssignments.length) {
        cont.innerHTML = '<div class="loading">No assignments found.</div>';
        return;
      }
      cont.innerHTML = allAssignments.map(a => {
        const due = a.dueDate ? new Date(a.dueDate).toLocaleDateString() : 'No due date';
        const status = a.status || 'assigned';
        const score = a.score?.total ? `${a.score.correct}/${a.score.total} (${a.score.percentage || 0}%)` : '—';
        const isOverdue = a.dueDate && a.dueDate < Date.now() && status !== 'completed';
        const remindLabel = a.lastReminderAt
          ? `Reminded ${new Date(a.lastReminderAt).toLocaleDateString()}`
          : 'Remind';
        return `
          <div class="item-card">
            <div class="id">${a.id}</div>
            <div class="title">${a.title || 'Assigned Exam'}</div>
            <div class="meta">
              <span class="tag tag-purple">${status}</span>
              <span>${a.assignedToEmail || 'Unknown user'}</span>
              <span>Due: ${due}${isOverdue ? ' (overdue)' : ''}</span>
              <span>Score: ${score}</span>
            </div>
            <div class="meta" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
              <button class="btn btn-secondary" onclick="applyAssignmentPreset('${a.id}')">Clone to Form</button>
              <button class="btn btn-primary" onclick="remindAssignment('${a.id}')">${remindLabel}</button>
              <button class="btn btn-secondary" onclick="resetAssignmentStatus('${a.id}')">Reset</button>
            </div>
          </div>
        `;
      }).join('');
    }

    function renderAssignmentSummary() {
      const cont = document.getElementById('assignment-summary');
      if (!cont) return;
      if (!allAssignments.length) {
        cont.innerHTML = '<div class="loading">No assignments found.</div>';
        return;
      }

      const total = allAssignments.length;
      const completed = allAssignments.filter(a => a.status === 'completed').length;
      const started = allAssignments.filter(a => a.status === 'started').length;
      const assigned = total - completed - started;
      const overdue = allAssignments.filter(a => a.dueDate && a.dueDate < Date.now() && a.status !== 'completed').length;
      const scores = allAssignments.map(a => a.score?.percentage).filter(p => Number.isFinite(p));
      const avgScore = scores.length ? Math.round(scores.reduce((sum, s) => sum + s, 0) / scores.length) : null;
      const tagCounts = {};
      allAssignments.forEach(a => {
        (a.focusTags || []).forEach(tag => {
          if (!tag) return;
          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
      });
      const topTags = Object.entries(tagCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([tag, count]) => `${tag} (${count})`)
        .join(', ');

      cont.innerHTML = `
        <div class="item-card">
          <div class="title">Assignments Overview</div>
          <div class="meta">
            <span>Total: ${total}</span>
            <span>Assigned: ${assigned}</span>
            <span>Started: ${started}</span>
            <span>Completed: ${completed}</span>
            <span>Overdue: ${overdue}</span>
            <span>Avg Score: ${avgScore !== null ? `${avgScore}%` : '—'}</span>
            <span>Top Focus Tags: ${topTags || '—'}</span>
          </div>
        </div>
      `;
    }

    function renderPresets() {
      const cont = document.getElementById('assignment-presets');
      if (!cont) return;
      if (!allPresets.length) {
        cont.innerHTML = '<div class="loading">No presets saved yet.</div>';
        return;
      }
      cont.innerHTML = allPresets.map(p => `
        <div class="item-card">
          <div class="title">${p.name || 'Preset'}</div>
          <div class="meta">
            <span>${p.template?.mode || 'tutor'}</span>
            <span>${p.template?.count || '—'} questions</span>
            <span>${(p.template?.categories || []).join(', ') || 'All categories'}</span>
          </div>
          <div class="meta" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn btn-secondary" onclick="applyPreset('${p.id}')">Apply to Form</button>
            <button class="btn btn-danger" onclick="deletePreset('${p.id}')">Delete</button>
          </div>
        </div>
      `).join('');
    }

    let approvalFilter = 'all';
    function setApprovalFilter(filter) {
      approvalFilter = filter;
      document.getElementById('filter-all').style.background = filter === 'all' ? '#4f8cff' : '#333';
      document.getElementById('filter-pending').style.background = filter === 'pending' ? '#4f8cff' : '#333';
      document.getElementById('filter-approved').style.background = filter === 'approved' ? '#4f8cff' : '#333';
      renderUsers();
    }

    function renderUsers() {
      const cont = document.getElementById('user-list');
      if (!cont) return;
      const queryText = normalizeText(document.getElementById('user-search')?.value || '');
      let filtered = queryText
        ? allUsers.filter(u => buildSearchText([u.email, u.displayName, u.id]).includes(queryText))
        : [...allUsers];

      // Apply approval filter
      if (approvalFilter === 'pending') {
        filtered = filtered.filter(u => u.approved === false);
      } else if (approvalFilter === 'approved') {
        filtered = filtered.filter(u => u.approved !== false);
      }

      if (!filtered.length) {
        cont.innerHTML = '<div class="loading">No users found.</div>';
        return;
      }

      cont.innerHTML = filtered.map(u => {
        const lastActive = u.lastActiveAt ? new Date(u.lastActiveAt).toLocaleString() : '—';
        const stats = u.stats || {};
        const approvalTag = u.approved === false
          ? '<span class="tag tag-orange">PENDING</span>'
          : '<span class="tag tag-green">APPROVED</span>';
        const statusTags = [
          approvalTag,
          u.flagged ? '<span class="tag tag-orange">FLAGGED</span>' : '',
          u.banned ? '<span class="tag tag-red">BANNED</span>' : '',
        ].filter(Boolean).join(' ');
        const approveBtn = u.approved === false
          ? `<button class="btn btn-success" onclick="toggleApproval('${u.id}', true)">Approve</button>`
          : `<button class="btn btn-secondary" onclick="toggleApproval('${u.id}', false)">Revoke</button>`;
        return `
          <div class="item-card">
            <div class="title">${u.displayName || 'User'} (${u.email || u.id})</div>
            <div class="meta">
              <span>Last active: ${lastActive}</span>
              <span>Reviewed: ${stats.reviewed || 0}</span>
              <span>Retention: ${stats.retention || 0}%</span>
              <span>Flashcards due: ${stats.flashcardsDue || 0}</span>
              ${statusTags ? `<span>${statusTags}</span>` : ''}
            </div>
            <div class="meta" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
              ${approveBtn}
              <button class="btn btn-secondary" onclick="grantCoins('${u.id}')">Grant Coins</button>
              <button class="btn btn-secondary" onclick="unlockFlashcards('${u.id}')">Unlock Flashcards</button>
              <button class="btn btn-secondary" onclick="resetProgress('${u.id}')">Reset Progress</button>
              <button class="btn btn-secondary" onclick="resetAssignments('${u.email || ''}')">Reset Assignments</button>
              <button class="btn btn-secondary" onclick="toggleFlagUser('${u.id}', ${u.flagged ? 'true' : 'false'})">${u.flagged ? 'Unflag' : 'Flag'}</button>
              <button class="btn btn-danger" onclick="toggleBanUser('${u.id}', ${u.banned ? 'true' : 'false'})">${u.banned ? 'Unban' : 'Ban'}</button>
            </div>
          </div>
        `;
      }).join('');
    }

    function renderRoles() {
      const cont = document.getElementById('roles-list');
      if (!allRoles.length) {
        cont.innerHTML = '<div class="loading">No roles assigned yet.</div>';
        return;
      }
      cont.innerHTML = allRoles.map(r => `
        <div class="item-card">
          <div class="id">${r.id}</div>
          <div class="title">${r.role || 'user'}</div>
          <div class="meta">
            <span>Updated: ${r.updatedAt?.toDate ? r.updatedAt.toDate().toLocaleDateString() : '-'}</span>
          </div>
        </div>
      `).join('');
    }

    const parseList = (value) => {
      if (!value) return [];
      return value.split(/[\n,]+/).map(v => v.trim()).filter(Boolean);
    };

    window.createAssignment = async () => {
      const email = document.getElementById('assign-email').value.trim().toLowerCase();
      if (!email || !email.includes('@')) {
        showToast('Enter a valid email', true);
        return;
      }
      const questionIds = parseList(document.getElementById('assign-question-ids').value);
      const categories = parseList(document.getElementById('assign-categories').value);
      const focusTags = parseList(document.getElementById('assign-focus-tags').value);
      const countValue = parseInt(document.getElementById('assign-count').value, 10);
      const dueDateInput = document.getElementById('assign-due-date').value;

      if (questionIds.length === 0 && categories.length === 0 && focusTags.length === 0) {
        showToast('Add question IDs or choose categories/tags.', true);
        return;
      }

      try {
        await addDoc(collection(db, 'assignments'), {
          title: document.getElementById('assign-title').value.trim() || 'Assigned Exam',
          assignedBy: auth.currentUser?.uid || null,
          assignedByEmail: auth.currentUser?.email || null,
          assignedToEmail: email,
          questionIds,
          categories,
          focusTags,
          count: Number.isFinite(countValue) ? countValue : null,
          mode: document.getElementById('assign-mode').value,
          dueDate: dueDateInput ? new Date(dueDateInput).getTime() : null,
          status: 'assigned',
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        });
        document.getElementById('assign-title').value = '';
        document.getElementById('assign-email').value = '';
        document.getElementById('assign-question-ids').value = '';
        document.getElementById('assign-categories').value = '';
        document.getElementById('assign-focus-tags').value = '';
        document.getElementById('assign-count').value = '';
        document.getElementById('assign-due-date').value = '';
        showToast('Assignment created');
        loadAssignments();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.saveAssignmentPreset = async () => {
      const name = prompt('Preset name?');
      if (!name) return;
      const template = {
        title: document.getElementById('assign-title').value.trim() || 'Assigned Exam',
        questionIds: parseList(document.getElementById('assign-question-ids').value),
        categories: parseList(document.getElementById('assign-categories').value),
        focusTags: parseList(document.getElementById('assign-focus-tags').value),
        count: parseInt(document.getElementById('assign-count').value, 10) || null,
        mode: document.getElementById('assign-mode').value,
        dueDate: document.getElementById('assign-due-date').value || null,
      };
      try {
        await addDoc(collection(db, 'assignmentPresets'), {
          name,
          template,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        });
        showToast('Preset saved');
        loadPresets();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.applyPreset = (presetId) => {
      const preset = allPresets.find(p => p.id === presetId);
      if (!preset) return;
      const template = preset.template || {};
      document.getElementById('assign-title').value = template.title || '';
      document.getElementById('assign-question-ids').value = (template.questionIds || []).join(', ');
      document.getElementById('assign-categories').value = (template.categories || []).join(', ');
      document.getElementById('assign-focus-tags').value = (template.focusTags || []).join(', ');
      document.getElementById('assign-count').value = template.count || '';
      document.getElementById('assign-mode').value = template.mode || 'tutor';
      document.getElementById('assign-due-date').value = template.dueDate || '';
      showToast('Preset applied');
    };

    window.deletePreset = async (presetId) => {
      if (!confirm('Delete this preset?')) return;
      try {
        await deleteDoc(doc(db, 'assignmentPresets', presetId));
        showToast('Preset deleted');
        loadPresets();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.applyAssignmentPreset = (assignmentId) => {
      const assignment = allAssignments.find(a => a.id === assignmentId);
      if (!assignment) return;
      document.getElementById('assign-title').value = assignment.title || 'Assigned Exam';
      document.getElementById('assign-question-ids').value = (assignment.questionIds || []).join(', ');
      document.getElementById('assign-categories').value = (assignment.categories || []).join(', ');
      document.getElementById('assign-focus-tags').value = (assignment.focusTags || []).join(', ');
      document.getElementById('assign-count').value = assignment.count || '';
      document.getElementById('assign-mode').value = assignment.mode || 'tutor';
      document.getElementById('assign-due-date').value = assignment.dueDate ? new Date(assignment.dueDate).toISOString().slice(0, 10) : '';
      showToast('Assignment copied to form');
    };

    window.remindAssignment = async (assignmentId) => {
      const assignment = allAssignments.find(a => a.id === assignmentId);
      if (!assignment?.assignedToEmail) {
        showToast('No assignee email found', true);
        return;
      }
      try {
        await updateDoc(doc(db, 'assignments', assignmentId), {
          lastReminderAt: Date.now(),
          updatedAt: serverTimestamp(),
        });
        const subject = encodeURIComponent(`Reminder: ${assignment.title || 'Assigned Exam'}`);
        const body = encodeURIComponent(`Hi,\n\nThis is a reminder to complete your assigned exam.\n\nTitle: ${assignment.title || 'Assigned Exam'}\nDue: ${assignment.dueDate ? new Date(assignment.dueDate).toLocaleDateString() : 'No due date'}\n\nThanks!`);
        window.location.href = `mailto:${assignment.assignedToEmail}?subject=${subject}&body=${body}`;
        loadAssignments();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.resetAssignmentStatus = async (assignmentId) => {
      if (!confirm('Reset this assignment status to assigned?')) return;
      try {
        await updateDoc(doc(db, 'assignments', assignmentId), {
          status: 'assigned',
          score: null,
          startedAt: null,
          completedAt: null,
          updatedAt: serverTimestamp(),
        });
        showToast('Assignment reset');
        loadAssignments();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.grantCoins = async (userId) => {
      const amount = parseInt(prompt('Coins to grant?'), 10);
      if (!Number.isFinite(amount) || amount <= 0) return;
      try {
        const userRef = doc(db, 'users', userId);
        const snap = await getDoc(userRef);
        const data = snap.exists() ? snap.data() : {};
        const coinData = data.coinData || { balance: 0, totalEarned: 0 };
        const next = {
          ...coinData,
          balance: (coinData.balance || 0) + amount,
          totalEarned: (coinData.totalEarned || 0) + amount,
          lastUpdated: Date.now(),
        };
        await updateDoc(userRef, { coinData: next, updatedAt: serverTimestamp() });
        showToast('Coins granted');
        loadUsers();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.unlockFlashcards = async (userId) => {
      if (!confirm('Unlock all flashcards for this user?')) return;
      try {
        await updateDoc(doc(db, 'users', userId), {
          unlockAllFlashcards: true,
          unlockAllFlashcardsAt: Date.now(),
          updatedAt: serverTimestamp(),
        });
        showToast('Flashcards unlocked');
        loadUsers();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.resetProgress = async (userId) => {
      if (!confirm('Reset progress for this user?')) return;
      try {
        await updateDoc(doc(db, 'users', userId), {
          cardData: {},
          flashcards: [],
          readTopics: {},
          savedSessions: [],
          sessionHistory: [],
          updatedAt: serverTimestamp(),
        });
        showToast('Progress reset');
        loadUsers();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.resetAssignments = async (email) => {
      if (!email) {
        showToast('User email missing', true);
        return;
      }
      if (!confirm(`Reset assignments for ${email}?`)) return;
      try {
        const q = query(collection(db, 'assignments'), where('assignedToEmail', '==', email));
        const snap = await getDocs(q);
        const updates = snap.docs.map(docSnap => updateDoc(doc(db, 'assignments', docSnap.id), {
          status: 'assigned',
          score: null,
          startedAt: null,
          completedAt: null,
          updatedAt: serverTimestamp(),
        }));
        await Promise.all(updates);
        showToast('Assignments reset');
        loadAssignments();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.toggleFlagUser = async (userId, isFlagged) => {
      const reason = isFlagged ? '' : prompt('Flag reason (optional):') || '';
      try {
        await updateDoc(doc(db, 'users', userId), {
          flagged: !isFlagged,
          flaggedReason: !isFlagged ? reason : '',
          flaggedAt: !isFlagged ? Date.now() : null,
          updatedAt: serverTimestamp(),
        });
        showToast(isFlagged ? 'User unflagged' : 'User flagged');
        loadUsers();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.toggleBanUser = async (userId, isBanned) => {
      if (!isBanned && !confirm('Ban this user? They will be blocked from the app.')) return;
      const reason = isBanned ? '' : (prompt('Ban reason (optional):') || '');
      try {
        await updateDoc(doc(db, 'users', userId), {
          banned: !isBanned,
          bannedReason: !isBanned ? reason : '',
          bannedAt: !isBanned ? Date.now() : null,
          updatedAt: serverTimestamp(),
        });
        showToast(isBanned ? 'User unbanned' : 'User banned');
        loadUsers();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.toggleApproval = async (userId, newStatus) => {
      try {
        const updates = {
          approved: newStatus,
          updatedAt: serverTimestamp(),
        };
        if (newStatus) {
          updates.approvedAt = serverTimestamp();
          updates.approvedBy = auth.currentUser?.uid || null;
        }
        await updateDoc(doc(db, 'users', userId), updates);
        showToast(newStatus ? 'User approved' : 'Approval revoked');
        // Update local cache
        const user = allUsers.find(u => u.id === userId);
        if (user) user.approved = newStatus;
        renderUsers();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.setRoleForEmail = async (role) => {
      const email = document.getElementById('role-email').value.trim().toLowerCase();
      if (!email || !email.includes('@')) {
        showToast('Enter a valid email', true);
        return;
      }
      try {
        const q = query(collection(db, 'users'), where('email', '==', email));
        const snap = await getDocs(q);
        if (snap.empty) {
          showToast('User not found (ask them to sign in once).', true);
          return;
        }
        const userDoc = snap.docs[0];
        await setDoc(doc(db, 'userRoles', userDoc.id), {
          role,
          updatedAt: serverTimestamp(),
          updatedBy: auth.currentUser?.uid || null,
        });
        showToast(`Role set to ${role}`);
        loadRoles();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    // Flashcard CRUD
    window.editFlashcard = (id) => {
      currentFlashcard = allFlashcards.find(fc => fc.id === id);
      if (!currentFlashcard) return;
      duplicateFlashcardSourceId = null;
      document.getElementById('fc-modal-title').textContent = 'Edit Flashcard';
      document.getElementById('fc-delete-btn').style.display = 'inline-block';
      document.getElementById('fcf-id').value = currentFlashcard.id;
      document.getElementById('fcf-category').value = currentFlashcard.category || '';
      document.getElementById('fcf-subcategory').value = currentFlashcard.subcategory || '';
      document.getElementById('fcf-difficulty').value = currentFlashcard.difficulty || 'intermediate';
      document.getElementById('fcf-cloze').value = currentFlashcard.text || '';
      document.getElementById('fcf-notes').value = currentFlashcard.notes || '';
      document.getElementById('fcf-front').value = currentFlashcard.front || '';
      document.getElementById('fcf-back').value = currentFlashcard.back || '';
      document.getElementById('fcf-related-questions').value = (currentFlashcard.relatedQuestions || []).join(', ');
      document.getElementById('fcf-related-reading').value = currentFlashcard.relatedReading || '';
      document.getElementById('fcf-tags').value = (currentFlashcard.tags || []).join(', ');
      updateFlashcardPreview();
      document.getElementById('flashcard-modal').classList.add('active');
    };
    window.duplicateFlashcard = () => {
      if (!currentFlashcard) return;
      const defaultId = `${currentFlashcard.id}_copy_${Date.now()}`;
      const newId = prompt('New flashcard ID', defaultId);
      if (!newId) return;
      duplicateFlashcardSourceId = currentFlashcard.id;
      document.getElementById('fc-modal-title').textContent = 'Duplicate Flashcard';
      document.getElementById('fc-delete-btn').style.display = 'none';
      document.getElementById('fcf-id').value = newId.trim();
      document.getElementById('fcf-category').value = currentFlashcard.category || '';
      document.getElementById('fcf-subcategory').value = currentFlashcard.subcategory || '';
      document.getElementById('fcf-difficulty').value = currentFlashcard.difficulty || 'intermediate';
      document.getElementById('fcf-cloze').value = currentFlashcard.text || '';
      document.getElementById('fcf-notes').value = currentFlashcard.notes || '';
      document.getElementById('fcf-front').value = currentFlashcard.front || '';
      document.getElementById('fcf-back').value = currentFlashcard.back || '';
      document.getElementById('fcf-related-questions').value = (currentFlashcard.relatedQuestions || []).join(', ');
      document.getElementById('fcf-related-reading').value = currentFlashcard.relatedReading || '';
      document.getElementById('fcf-tags').value = (currentFlashcard.tags || []).join(', ');
      updateFlashcardPreview();
      document.getElementById('flashcard-modal').classList.add('active');
    };
    window.openNewFlashcard = () => {
      currentFlashcard = null;
      duplicateFlashcardSourceId = null;
      document.getElementById('fc-modal-title').textContent = 'New Flashcard';
      document.getElementById('fc-delete-btn').style.display = 'none';
      document.getElementById('fcf-id').value = `fc_${Date.now()}`;
      document.getElementById('fcf-category').value = 'RHINOLOGY';
      document.getElementById('fcf-subcategory').value = '';
      document.getElementById('fcf-difficulty').value = 'intermediate';
      document.getElementById('fcf-front').value = '';
      document.getElementById('fcf-back').value = '';
      document.getElementById('fcf-cloze').value = '';
      document.getElementById('fcf-notes').value = '';
      document.getElementById('fcf-related-questions').value = '';
      document.getElementById('fcf-related-reading').value = '';
      document.getElementById('fcf-tags').value = '';
      updateFlashcardPreview();
      document.getElementById('flashcard-modal').classList.add('active');
    };
    window.closeFlashcardModal = () => {
      document.getElementById('flashcard-modal').classList.remove('active');
      currentFlashcard = null;
      duplicateFlashcardSourceId = null;
    };
    window.deleteFlashcard = async () => {
      if (!currentFlashcard) return;
      await softDeleteItem('flashcards', currentFlashcard.id);
      closeFlashcardModal();
    };
    function updateFlashcardPreview() {
      const cloze = document.getElementById('fcf-cloze').value;
      const front = document.getElementById('fcf-front').value;
      const back = document.getElementById('fcf-back').value;
      document.getElementById('fc-preview-front').textContent = cloze || front || '-';
      document.getElementById('fc-preview-back').textContent = back || (cloze ? '(cloze)' : '-');
    }
    document.getElementById('fcf-cloze').addEventListener('input', updateFlashcardPreview);
    document.getElementById('fcf-front').addEventListener('input', updateFlashcardPreview);
    document.getElementById('fcf-back').addEventListener('input', updateFlashcardPreview);
    document.getElementById('flashcard-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const id = document.getElementById('fcf-id').value;
      const clozeText = document.getElementById('fcf-cloze').value.trim();
      const notes = document.getElementById('fcf-notes').value.trim();
      const relatedQuestions = document.getElementById('fcf-related-questions').value.split(',').map(s => s.trim()).filter(s => s);
      const tags = document.getElementById('fcf-tags').value.split(',').map(s => s.trim()).filter(s => s);
      try {
        const docRef = doc(db, 'flashcards', id);
        const existingDoc = await getDoc(docRef);
        if (existingDoc.exists() && (!currentFlashcard || currentFlashcard.id !== id)) {
          showToast(`ID already exists: ${id}`, true);
          return;
        }
        await setDoc(docRef, {
          id, category: document.getElementById('fcf-category').value, subcategory: document.getElementById('fcf-subcategory').value,
          difficulty: document.getElementById('fcf-difficulty').value, front: document.getElementById('fcf-front').value,
          back: document.getElementById('fcf-back').value, text: clozeText || null, type: clozeText ? 'cloze' : (currentFlashcard?.type || 'basic'),
          notes: notes || '',
          relatedQuestions, relatedReading: document.getElementById('fcf-related-reading').value,
          tags, updatedAt: new Date().toISOString()
        });
        showToast('Saved!'); closeFlashcardModal(); loadFlashcards();
      } catch (e) { showToast(e.message, true); }
    });

    // Reading CRUD
    window.editReading = (id) => {
      currentReading = allReadings.find(r => r.id === id);
      if (!currentReading) return;
      duplicateReadingSourceId = null;
      document.getElementById('r-modal-title').textContent = 'Edit Reading';
      document.getElementById('r-delete-btn').style.display = 'inline-block';
      document.getElementById('rf-id').value = currentReading.id;
      document.getElementById('rf-category').value = currentReading.category || '';
      document.getElementById('rf-title').value = currentReading.title || '';
      document.getElementById('rf-readingtime').value = currentReading.readingTime || 5;
      document.getElementById('rf-wordcount').value = currentReading.wordCount || 0;
      document.getElementById('rf-content').value = currentReading.content || '';
      const relatedIds = currentReading.questionIds || currentReading.relatedQuestions || [];
      const relatedList = Array.isArray(relatedIds) ? relatedIds : String(relatedIds).split(/[\n,]+/);
      document.getElementById('rf-related-questions').value = relatedList.map(s => s.trim()).filter(Boolean).join(', ');
      document.getElementById('rf-tags').value = (currentReading.tags || []).join(', ');
      document.getElementById('reading-modal').classList.add('active');
    };
    window.duplicateReading = () => {
      if (!currentReading) return;
      const defaultId = `${currentReading.id}_copy_${Date.now()}`;
      const newId = prompt('New reading ID', defaultId);
      if (!newId) return;
      duplicateReadingSourceId = currentReading.id;
      document.getElementById('r-modal-title').textContent = 'Duplicate Reading';
      document.getElementById('r-delete-btn').style.display = 'none';
      document.getElementById('rf-id').value = newId.trim();
      document.getElementById('rf-category').value = currentReading.category || '';
      document.getElementById('rf-title').value = currentReading.title || '';
      document.getElementById('rf-readingtime').value = currentReading.readingTime || 5;
      document.getElementById('rf-wordcount').value = currentReading.wordCount || 0;
      document.getElementById('rf-content').value = currentReading.content || '';
      const relatedIds = currentReading.questionIds || currentReading.relatedQuestions || [];
      const relatedList = Array.isArray(relatedIds) ? relatedIds : String(relatedIds).split(/[\n,]+/);
      document.getElementById('rf-related-questions').value = relatedList.map(s => s.trim()).filter(Boolean).join(', ');
      document.getElementById('rf-tags').value = (currentReading.tags || []).join(', ');
      document.getElementById('reading-modal').classList.add('active');
    };
    window.openNewReading = () => {
      currentReading = null;
      duplicateReadingSourceId = null;
      document.getElementById('r-modal-title').textContent = 'New Reading';
      document.getElementById('r-delete-btn').style.display = 'none';
      document.getElementById('rf-id').value = `reading_${Date.now()}`;
      document.getElementById('rf-category').value = 'rhinology';
      document.getElementById('rf-title').value = '';
      document.getElementById('rf-readingtime').value = 5;
      document.getElementById('rf-wordcount').value = 0;
      document.getElementById('rf-content').value = '# Title\n\n## Learning Objectives\n-\n\n## Introduction\n\n';
      document.getElementById('rf-related-questions').value = '';
      document.getElementById('rf-tags').value = '';
      document.getElementById('reading-modal').classList.add('active');
    };
    window.closeReadingModal = () => {
      document.getElementById('reading-modal').classList.remove('active');
      currentReading = null;
      duplicateReadingSourceId = null;
    };
    window.deleteReading = async () => {
      if (!currentReading) return;
      await softDeleteItem('readings', currentReading.id);
      closeReadingModal();
    };
    const categoryNames = READING_CATEGORY_NAMES;
    document.getElementById('reading-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const id = document.getElementById('rf-id').value;
      const cat = document.getElementById('rf-category').value;
      try {
        const docRef = doc(db, 'readings', id);
        const existingDoc = await getDoc(docRef);
        if (existingDoc.exists() && (!currentReading || currentReading.id !== id)) {
          showToast(`ID already exists: ${id}`, true);
          return;
        }
        const questionIds = document.getElementById('rf-related-questions').value.split(/[\n,]+/).map(s => s.trim()).filter(Boolean);
        const tags = document.getElementById('rf-tags').value.split(',').map(s => s.trim()).filter(Boolean);
        await setDoc(docRef, {
          id, category: cat, categoryName: categoryNames[cat] || cat, title: document.getElementById('rf-title').value,
          content: document.getElementById('rf-content').value, readingTime: parseInt(document.getElementById('rf-readingtime').value) || 5,
          wordCount: parseInt(document.getElementById('rf-wordcount').value) || 0, questionIds, tags,
          updatedAt: new Date().toISOString()
        });
        showToast('Saved!'); closeReadingModal(); loadReadings();
      } catch (e) { showToast(e.message, true); }
    });

    // Report CRUD
    window.viewReport = (id) => {
      currentReport = allReports.find(r => r.id === id || r.cloudId === id);
      if (!currentReport) return;
      document.getElementById('rptf-id').value = currentReport.id;
      document.getElementById('rptf-type').value = currentReport.type || 'unknown';
      document.getElementById('rptf-item-id').value = currentReport.itemId || 'Unknown';
      document.getElementById('rptf-item-title').value = currentReport.itemTitle || '';
      document.getElementById('rptf-status').value = currentReport.status || 'pending';
      const date = currentReport.timestamp ? new Date(currentReport.timestamp) : (currentReport.createdAt || new Date());
      document.getElementById('rptf-date').value = date.toLocaleString();
      document.getElementById('rptf-user').value = currentReport.userEmail || 'anonymous';
      document.getElementById('rptf-description').value = currentReport.description || '';
      document.getElementById('rptf-content').value = currentReport.itemContent || 'No content preview available';
      document.getElementById('rptf-notes').value = currentReport.adminNotes || '';
      document.getElementById('report-modal').classList.add('active');
    };
    window.closeReportModal = () => { document.getElementById('report-modal').classList.remove('active'); currentReport = null; };
    window.viewReportedItem = () => {
      if (!currentReport) return;
      const report = currentReport;
      closeReportModal();
      if (report.type === 'question') {
        const q = allQuestions.find(q => q.id === report.itemId);
        if (q) editQuestion(q.id);
        else showToast('Question not found', true);
      } else if (report.type === 'flashcard') {
        const fc = allFlashcards.find(fc => fc.id === report.itemId);
        if (fc) {
          editFlashcard(fc.id);
        } else {
          openFlashcardFromReport(report);
        }
      } else if (report.type === 'reading') {
        const rd = allReadings.find(r => r.id === report.itemId);
        if (rd) editReading(rd.id);
        else showToast('Reading not found', true);
      }
    };
    window.openFlashcardFromReport = (report) => {
      if (!report) return;
      currentFlashcard = null;
      document.getElementById('fc-modal-title').textContent = 'New Flashcard (From Report)';
      document.getElementById('fc-delete-btn').style.display = 'none';
      document.getElementById('fcf-id').value = report.itemId || `fc_${Date.now()}`;

      const parsed = parseReportedFlashcardContent(report.itemContent || '');
      document.getElementById('fcf-cloze').value = parsed.text || '';
      document.getElementById('fcf-front').value = parsed.front || '';
      document.getElementById('fcf-back').value = parsed.back || '';
      document.getElementById('fcf-tags').value = (parsed.tags || []).join(', ');
      document.getElementById('fcf-related-questions').value = '';
      document.getElementById('fcf-related-reading').value = '';
      document.getElementById('fcf-category').value = parsed.category || 'RHINOLOGY';
      document.getElementById('fcf-subcategory').value = parsed.subcategory || '';
      document.getElementById('fcf-difficulty').value = 'intermediate';
      updateFlashcardPreview();
      document.getElementById('flashcard-modal').classList.add('active');
    };
    function parseReportedFlashcardContent(content) {
      const lines = content.split('\n');
      const parsed = { text: '', front: '', back: '', tags: [] };
      lines.forEach(line => {
        if (line.startsWith('Text: ')) parsed.text = line.replace('Text: ', '').trim();
        if (line.startsWith('Front: ')) parsed.front = line.replace('Front: ', '').trim();
        if (line.startsWith('Back: ')) parsed.back = line.replace('Back: ', '').trim();
        if (line.startsWith('Tags: ')) {
          parsed.tags = line.replace('Tags: ', '').split(',').map(t => t.trim()).filter(Boolean);
        }
      });
      return parsed;
    }
    window.openReportedItemById = (event, reportId) => {
      if (event) event.stopPropagation();
      const report = allReports.find(r => r.id === reportId || r.cloudId === reportId);
      if (!report) return;
      currentReport = report;
      viewReportedItem();
    };
    window.quickUpdateReportStatus = async (event, reportId, status) => {
      if (event) event.stopPropagation();
      const report = allReports.find(r => r.id === reportId || r.cloudId === reportId);
      const reportDocId = report?.cloudId || reportId;
      if (!reportDocId) return;
      try {
        await updateDoc(doc(db, 'reports', reportDocId), {
          status,
          updatedAt: new Date().toISOString()
        });
        showToast(`Report ${status}`);
        await loadReports();
        await refreshReportsOpsSummary(true);
        updateStats();
      } catch (e) { showToast(e.message, true); }
    };
    window.openAndResolveReport = async (event, reportId) => {
      if (event) event.stopPropagation();
      const report = allReports.find(r => r.cloudId === reportId || r.id === reportId);
      if (!report) return;
      await quickUpdateReportStatus(null, reportId, 'resolved');
      openReportedItemById(null, report.cloudId || report.id);
    };
    window.updateReportStatus = async () => {
      if (!currentReport) return;
      const newStatus = document.getElementById('rptf-status').value;
      const adminNotes = document.getElementById('rptf-notes').value;
      try {
        const reportDocId = currentReport.cloudId || currentReport.id;
        await updateDoc(doc(db, 'reports', reportDocId), {
          status: newStatus,
          adminNotes: adminNotes,
          updatedAt: new Date().toISOString()
        });
        showToast('Report updated!');
        closeReportModal();
        await loadReports();
        await refreshReportsOpsSummary(true);
        updateStats();
      } catch (e) { showToast(e.message, true); }
    };
    window.deleteReport = async () => {
      if (!currentReport || !confirm('Delete this report?')) return;
      try {
        const reportDocId = currentReport.cloudId || currentReport.id;
        await deleteDoc(doc(db, 'reports', reportDocId));
        showToast('Report deleted');
        closeReportModal();
        await loadReports();
        await refreshReportsOpsSummary(true);
        updateStats();
      } catch (e) { showToast(e.message, true); }
    };

    const valueToMillis = (value) => {
      if (!value) return 0;
      if (value instanceof Date) return value.getTime();
      if (typeof value === 'number') return value;
      if (typeof value === 'string') {
        const parsed = Date.parse(value);
        return Number.isFinite(parsed) ? parsed : 0;
      }
      if (typeof value.toMillis === 'function') return value.toMillis();
      if (typeof value.toDate === 'function') return value.toDate().getTime();
      return 0;
    };

    const normalizeReportStatusValue = (status) => {
      const raw = String(status ?? '').trim().toLowerCase();
      return VALID_REPORT_STATUSES.has(raw) ? raw : 'pending';
    };

    const deriveCreatedAtFallback = (reportData) => {
      const timestampCandidate = reportData.timestamp;
      if (timestampCandidate && typeof timestampCandidate.toDate === 'function') return timestampCandidate;
      const updatedCandidate = reportData.updatedAt;
      if (updatedCandidate && typeof updatedCandidate.toDate === 'function') return updatedCandidate;
      const ms = valueToMillis(timestampCandidate) || valueToMillis(updatedCandidate);
      return ms ? new Date(ms) : null;
    };

    const buildReportRepairPatch = (reportData) => {
      const patch = {};
      const statusRaw = String(reportData.status ?? '').trim().toLowerCase();
      const normalizedStatus = normalizeReportStatusValue(reportData.status);
      if (!VALID_REPORT_STATUSES.has(statusRaw) || statusRaw !== normalizedStatus) {
        patch.status = normalizedStatus;
      }

      const typeRaw = String(reportData.type ?? '').trim().toLowerCase();
      if (!typeRaw) {
        patch.type = 'unknown';
      } else if (typeRaw !== reportData.type) {
        patch.type = typeRaw;
      }

      const stringFields = [
        ['itemId', ''],
        ['itemTitle', ''],
        ['description', ''],
        ['userId', 'anonymous'],
        ['userEmail', 'anonymous'],
        ['adminNotes', ''],
      ];
      stringFields.forEach(([field, fallback]) => {
        const value = reportData[field];
        if (value === undefined || value === null || String(value).trim() === '') {
          patch[field] = fallback;
          return;
        }
        if (typeof value !== 'string') {
          patch[field] = String(value);
        }
      });

      if (!reportData.createdAt) {
        const createdAtFallback = deriveCreatedAtFallback(reportData);
        patch.createdAt = createdAtFallback || REPORT_OPS_SERVER_TIMESTAMP;
      }

      return patch;
    };

    const formatReportRepairValue = (value) => {
      if (value === REPORT_OPS_SERVER_TIMESTAMP) return REPORT_OPS_SERVER_TIMESTAMP;
      if (value instanceof Date) return value.toISOString();
      if (value && typeof value.toDate === 'function') return value.toDate().toISOString();
      return value;
    };

    const formatCountMap = (counts) => {
      const entries = Object.entries(counts).filter(([, value]) => value > 0).sort((a, b) => b[1] - a[1]);
      return entries.length ? entries.map(([label, value]) => `${label}: ${value}`).join(' | ') : 'none';
    };

    const setReportsOpsBusy = (busy) => {
      reportsOpsBusy = busy;
      document.querySelectorAll('[data-reports-op]').forEach(btn => {
        btn.disabled = busy;
      });
    };

    const setReportsConnectionBadge = (label, className) => {
      const badge = document.getElementById('reports-ops-connection');
      if (!badge) return;
      badge.className = `tag ${className}`;
      badge.textContent = label;
    };

    const scanReportsOps = async () => {
      const snap = await getDocs(query(collection(db, 'reports'), orderBy('__name__')));
      const statusCounts = { pending: 0, reviewed: 0, resolved: 0, dismissed: 0 };
      const typeCounts = {};
      const fieldFixCounts = {};
      const patches = [];
      let openCount = 0;
      let oldestOpenMs = 0;

      snap.forEach(docSnap => {
        const reportData = docSnap.data() || {};
        const status = normalizeReportStatusValue(reportData.status);
        statusCounts[status] = (statusCounts[status] || 0) + 1;

        const type = String(reportData.type ?? '').trim().toLowerCase() || 'unknown';
        typeCounts[type] = (typeCounts[type] || 0) + 1;

        const createdMs = valueToMillis(reportData.createdAt || reportData.timestamp);
        const isOpen = status !== 'resolved' && status !== 'dismissed';
        if (isOpen) {
          openCount += 1;
          if (createdMs && (!oldestOpenMs || createdMs < oldestOpenMs)) oldestOpenMs = createdMs;
        }

        const patch = buildReportRepairPatch(reportData);
        if (!Object.keys(patch).length) return;

        Object.keys(patch).forEach(field => {
          fieldFixCounts[field] = (fieldFixCounts[field] || 0) + 1;
        });

        const preview = {};
        Object.entries(patch).forEach(([field, value]) => {
          preview[field] = formatReportRepairValue(value);
        });

        patches.push({
          id: docSnap.id,
          patch,
          preview,
        });
      });

      return {
        scanned: snap.size,
        statusCounts,
        typeCounts,
        openCount,
        oldestOpenMs,
        fieldFixCounts,
        patches,
        scannedAt: new Date(),
      };
    };

    const renderReportsOps = (scan) => {
      const summary = document.getElementById('reports-ops-summary');
      if (!summary) return;

      if (!scan) {
        summary.textContent = 'Open Reports and click "Refresh Summary" to load operations data.';
        return;
      }

      document.getElementById('reports-kpi-total').textContent = scan.scanned;
      document.getElementById('reports-kpi-open').textContent = scan.openCount;
      document.getElementById('reports-kpi-repair').textContent = scan.patches.length;
      document.getElementById('reports-kpi-oldest').textContent = scan.oldestOpenMs ? new Date(scan.oldestOpenMs).toLocaleDateString() : '—';

      const lines = [
        `Last scan: ${scan.scannedAt.toLocaleString()}`,
        `Scanned reports: ${scan.scanned}`,
        `Status: ${formatCountMap(scan.statusCounts)}`,
        `Type: ${formatCountMap(scan.typeCounts)}`,
        `Repairs needed: ${scan.patches.length}`,
      ];

      if (scan.patches.length > 0) {
        lines.push(`Fields to fix: ${formatCountMap(scan.fieldFixCounts)}`);
        lines.push('Sample repairs:');
        scan.patches.slice(0, 8).forEach(item => {
          lines.push(`- ${item.id}: ${Object.keys(item.preview).join(', ')}`);
        });
      }

      summary.textContent = lines.join('\n');
    };

    window.refreshReportsOpsSummary = async (silent = false) => {
      if (reportsOpsBusy) return;
      setReportsOpsBusy(true);
      try {
        const scan = await scanReportsOps();
        reportsOpsLastScan = scan;
        renderReportsOps(scan);
        setReportsConnectionBadge(`Connected · ${new Date().toLocaleTimeString()}`, 'tag-green');
        if (!silent) showToast(`Loaded ops summary for ${scan.scanned} reports.`);
      } catch (e) {
        console.error(e);
        setReportsConnectionBadge('Connection failed', 'tag-red');
        if (!silent) showToast(`Summary load failed: ${e.message}`, true);
      } finally {
        setReportsOpsBusy(false);
      }
    };

    window.checkFirebaseConnection = async () => {
      if (reportsOpsBusy) return;
      setReportsOpsBusy(true);
      setReportsConnectionBadge('Checking...', 'tag-blue');
      try {
        await Promise.all([
          getDocs(query(collection(db, 'questions'), limit(1))),
          getDocs(query(collection(db, 'flashcards'), limit(1))),
          getDocs(query(collection(db, 'readings'), limit(1))),
          getDocs(query(collection(db, 'reports'), limit(1))),
          getDocs(query(collection(db, 'users'), limit(1))),
        ]);
        setReportsConnectionBadge(`Connected · ${new Date().toLocaleTimeString()}`, 'tag-green');
        showToast('Firebase connection check passed.');
      } catch (e) {
        console.error(e);
        setReportsConnectionBadge('Connection failed', 'tag-red');
        showToast(`Connection check failed: ${e.message}`, true);
      } finally {
        setReportsOpsBusy(false);
      }
    };

    window.repairReportsDryRun = async () => {
      if (reportsOpsBusy) return;
      setReportsOpsBusy(true);
      try {
        const scan = await scanReportsOps();
        reportsOpsLastScan = scan;
        renderReportsOps(scan);
        setReportsConnectionBadge(`Connected · ${new Date().toLocaleTimeString()}`, 'tag-green');
        if (scan.patches.length) {
          showToast(`Dry run complete: ${scan.patches.length} reports need repair.`);
        } else {
          showToast('Dry run complete: no repairs needed.');
        }
      } catch (e) {
        console.error(e);
        setReportsConnectionBadge('Connection failed', 'tag-red');
        showToast(`Dry run failed: ${e.message}`, true);
      } finally {
        setReportsOpsBusy(false);
      }
    };

    const toReportWritePatch = (patch) => {
      const next = {};
      Object.entries(patch).forEach(([field, value]) => {
        next[field] = value === REPORT_OPS_SERVER_TIMESTAMP ? serverTimestamp() : value;
      });
      next.updatedAt = serverTimestamp();
      return next;
    };

    window.repairReportsApply = async () => {
      if (reportsOpsBusy) return;
      setReportsOpsBusy(true);
      try {
        const scan = reportsOpsLastScan || await scanReportsOps();
        reportsOpsLastScan = scan;
        renderReportsOps(scan);

        if (!scan.patches.length) {
          showToast('No report repairs needed.');
          return;
        }

        const shouldApply = confirm(`Apply ${scan.patches.length} repair updates to reports?`);
        if (!shouldApply) return;

        let applied = 0;
        for (let i = 0; i < scan.patches.length; i += REPORT_REPAIR_BATCH_SIZE) {
          const slice = scan.patches.slice(i, i + REPORT_REPAIR_BATCH_SIZE);
          const batch = writeBatch(db);
          slice.forEach(item => {
            batch.update(doc(db, 'reports', item.id), toReportWritePatch(item.patch));
          });
          await batch.commit();
          applied += slice.length;
        }

        await loadReports();
        await loadCounts();
        updateStats();
        const postScan = await scanReportsOps();
        reportsOpsLastScan = postScan;
        renderReportsOps(postScan);
        setReportsConnectionBadge(`Connected · ${new Date().toLocaleTimeString()}`, 'tag-green');
        showToast(`Applied ${applied} report repairs.`);
      } catch (e) {
        console.error(e);
        setReportsConnectionBadge('Connection failed', 'tag-red');
        showToast(`Repair apply failed: ${e.message}`, true);
      } finally {
        setReportsOpsBusy(false);
      }
    };

    // Tab switching
    window.switchTab = (tab, source) => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      const activeTab = source || document.querySelector(`.tab[data-tab="${tab}"]`);
      if (activeTab) activeTab.classList.add('active');
      document.getElementById('questions-tab').style.display = tab === 'questions' ? 'block' : 'none';
      document.getElementById('flashcards-tab').style.display = tab === 'flashcards' ? 'block' : 'none';
      document.getElementById('readings-tab').style.display = tab === 'readings' ? 'block' : 'none';
      document.getElementById('reading-editor-tab').style.display = tab === 'reading-editor' ? 'block' : 'none';
      document.getElementById('trash-tab').style.display = tab === 'trash' ? 'block' : 'none';
      document.getElementById('reports-tab').style.display = tab === 'reports' ? 'block' : 'none';
      document.getElementById('linker-tab').style.display = tab === 'linker' ? 'block' : 'none';
      document.getElementById('assignments-tab').style.display = tab === 'assignments' ? 'block' : 'none';
      document.getElementById('users-tab').style.display = tab === 'users' ? 'block' : 'none';
      document.getElementById('upload-tab').style.display = tab === 'upload' ? 'block' : 'none';

      if (tab === 'questions' && !tabLoaded.questions) loadQuestions();
      if (tab === 'flashcards' && !tabLoaded.flashcards) loadFlashcards();
      if (tab === 'readings' && !tabLoaded.readings) loadReadings();
      if (tab === 'reading-editor') {
        if (!tabLoaded.readings) loadReadings();
        renderReadingEditorList();
        tabLoaded.readingEditor = true;
      }
      if (tab === 'trash') renderTrash();
      if (tab === 'reports') {
        if (!tabLoaded.reports) loadReports();
        if (!reportsOpsLastScan) refreshReportsOpsSummary(true);
      }
      if (tab === 'assignments' && !tabLoaded.assignments) {
        loadAssignments();
        loadPresets();
      }
      if (tab === 'users' && !tabLoaded.users) {
        loadUsers();
        loadRoles();
      }
    };

    function showToast(msg, err = false) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.className = 'toast show' + (err ? ' error' : '');
      setTimeout(() => t.classList.remove('show'), 3000);
    }
    window.showToast = showToast;

    const preprocessReadingCallouts = (content) => {
      if (!content) return '';
      const lines = content.split(/\r?\n/);
      const output = [];
      let index = 0;

      while (index < lines.length) {
        const line = lines[index];
        const trimmed = line.trim();
        const match = trimmed.match(/^>\s*\[!(\w+)\]\s*(.*)$/);
        if (match) {
          const type = match[1].toLowerCase();
          const title = match[2] ? match[2].trim() : type;
          const bodyLines = [];
          index += 1;
          while (index < lines.length && lines[index].trim().startsWith('>') && !/^>\s*\[!(\w+)\]/.test(lines[index].trim())) {
            bodyLines.push(lines[index].replace(/^\s*>\s?/, ''));
            index += 1;
          }
          const body = bodyLines.join('\n');
          output.push(
            `<div class="reading-callout reading-callout-${type}">` +
              `<div class="reading-callout-title">${title}</div>` +
              `<div class="reading-callout-body">${marked.parse(body)}</div>` +
            `</div>`
          );
          continue;
        }
        output.push(line);
        index += 1;
      }
      return output.join('\n');
    };

    const ensureReadingPreviewStyles = () => {
      if (document.getElementById('reading-preview-callout-style')) return;
      const style = document.createElement('style');
      style.id = 'reading-preview-callout-style';
      style.textContent = `
        .reading-callout {
          border-left: 4px solid #00BCD4;
          background: rgba(0,188,212,0.08);
          padding: 10px 14px;
          margin: 12px 0;
          border-radius: 8px;
        }
        .reading-callout-title { font-weight: 700; margin-bottom: 6px; }
        .reading-callout-warning { border-left-color: #ff9800; background: rgba(255,152,0,0.12); }
        .reading-callout-tip { border-left-color: #4caf50; background: rgba(76,175,80,0.12); }
        .reading-callout-note { border-left-color: #7c4dff; background: rgba(124,77,255,0.12); }
      `;
      document.head.appendChild(style);
    };

    window.renderReadingEditorList = () => {
      const list = document.getElementById('reading-editor-list');
      const queryText = normalizeText(document.getElementById('reading-editor-search').value || '');
      const filtered = allReadings.filter(r => {
        const hay = normalizeText(`${r.title || ''} ${r.id || ''} ${r.category || ''} ${r.categoryName || ''} ${(r.tags || []).join(' ')}`);
        return hay.includes(queryText);
      }).sort((a, b) => (a.title || a.id || '').localeCompare(b.title || b.id || ''));
      if (!filtered.length) {
        list.innerHTML = '<div class="loading">No readings found.</div>';
        return;
      }
      list.innerHTML = filtered.map(r => `
        <div class="list-item ${r.id === readingEditorSelectedId ? 'active' : ''}" onclick="openReadingInEditor('${r.id}')">
          <div style="font-weight:600;">${r.title || r.id}</div>
          <div style="opacity:0.7;">${r.categoryName || r.category || ''}</div>
        </div>
      `).join('');
    };

    window.openReadingInEditor = (id) => {
      const reading = allReadings.find(r => r.id === id);
      if (!reading) return;
      readingEditorSelectedId = id;
      document.getElementById('reading-editor-title').value = reading.title || '';
      document.getElementById('reading-editor-category').value = reading.category || reading.categoryName || '';
      document.getElementById('reading-editor-tags').value = (reading.tags || []).join(', ');
      const questionIds = reading.questionIds || reading.relatedQuestions || [];
      const questionText = Array.isArray(questionIds) ? questionIds.join('\n') : String(questionIds || '');
      document.getElementById('reading-editor-question-ids').value = questionText;
      document.getElementById('reading-editor-content').value = reading.content || '';
      renderReadingEditorList();
      refreshReadingPreview();
    };

    window.refreshReadingPreview = () => {
      const preview = document.getElementById('reading-editor-preview');
      if (!preview) return;
      marked.setOptions({ gfm: true, breaks: false });
      ensureReadingPreviewStyles();
      const raw = document.getElementById('reading-editor-content').value || '';
      const html = marked.parse(preprocessReadingCallouts(raw));
      preview.innerHTML = html;
    };

    window.saveReadingEditor = async () => {
      if (!readingEditorSelectedId) {
        showToast('Select a reading to edit.', true);
        return;
      }
      try {
        const title = document.getElementById('reading-editor-title').value.trim();
        const category = document.getElementById('reading-editor-category').value.trim();
        const tags = document.getElementById('reading-editor-tags').value.split(',').map(s => s.trim()).filter(Boolean);
        const questionIds = document.getElementById('reading-editor-question-ids').value
          .split(/[\n,]+/)
          .map(s => s.trim())
          .filter(Boolean);
        const content = document.getElementById('reading-editor-content').value;
        await updateDoc(doc(db, 'readings', readingEditorSelectedId), {
          title,
          category,
          categoryName: categoryNames?.[category] || category,
          tags,
          questionIds,
          content,
          updatedAt: serverTimestamp(),
        });
        const idx = allReadings.findIndex(r => r.id === readingEditorSelectedId);
        if (idx !== -1) {
          allReadings[idx] = { ...allReadings[idx], title, category, categoryName: categoryNames?.[category] || category, tags, questionIds, content };
        }
        showToast('Reading saved.');
        renderReadingEditorList();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    const normalizeText = (value) => (value || '').toString().toLowerCase();
    const normalizeList = (value) => {
      if (!value) return '';
      if (Array.isArray(value)) return value.join(' ');
      return value.toString();
    };

    const buildSearchText = (parts) => parts.map(part => normalizeText(normalizeList(part))).join(' ');

    const getQuestionSearchText = (q) => buildSearchText([
      q.id,
      q.category,
      q.subcategory,
      q.difficulty,
      q.stem,
      q.leadIn,
      q.explanation,
      q.keyPoint,
      q.options,
      q.tags,
      q.references,
    ]);

    const getFlashcardSearchText = (fc) => buildSearchText([
      fc.id,
      fc.category,
      fc.subcategory,
      fc.difficulty,
      fc.text,
      fc.front,
      fc.back,
      fc.notes,
      fc.relatedReading,
      fc.relatedQuestions,
      fc.tags,
    ]);

    const getReadingSearchText = (r) => buildSearchText([
      r.id,
      r.category,
      r.categoryName,
      r.title,
      r.content,
      r.priority,
      r.questionIds,
      r.tags,
    ]);

    const getReportSearchText = (r) => buildSearchText([
      r.id,
      r.type,
      r.status,
      r.itemId,
      r.itemTitle,
      r.itemContent,
      r.description,
      r.adminNotes,
      r.userEmail,
    ]);

    const updateTagOptions = () => {
      const tags = new Set();
      allQuestions.forEach(q => (q.tags || []).forEach(tag => tags.add(tag)));
      allFlashcards.forEach(fc => (fc.tags || []).forEach(tag => tags.add(tag)));
      allReadings.forEach(r => (r.tags || []).forEach(tag => tags.add(tag)));

      const datalist = document.getElementById('tag-options');
      if (!datalist) return;
      datalist.innerHTML = Array.from(tags)
        .sort((a, b) => a.localeCompare(b))
        .map(tag => `<option value="${tag}"></option>`)
        .join('');
    };

    const updateLoadStatus = (elementId, loadedCount, totalCount, hasMore) => {
      const el = document.getElementById(elementId);
      if (!el) return;
      const totalText = totalCount ? `${loadedCount}/${totalCount}` : `${loadedCount}`;
      el.textContent = `${totalText} loaded${hasMore ? '' : ' (all)'}`
    };

    const escapeHtml = (value) => String(value ?? '').replace(/[&<>"']/g, (ch) => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
    }[ch]));
    const toDomId = (value) => encodeURIComponent(String(value ?? ''));

    window.selectPageItems = (type) => {
      document.querySelectorAll(`.bulk-select[data-type="${type}"]`).forEach(el => { el.checked = true; });
    };

    window.clearSelections = (type) => {
      document.querySelectorAll(`.bulk-select[data-type="${type}"]`).forEach(el => { el.checked = false; });
    };

    const getSelectedIds = (type) => Array.from(document.querySelectorAll(`.bulk-select[data-type="${type}"]:checked`))
      .map(el => el.value)
      .filter(Boolean);

    window.applyBulkChanges = async (type) => {
      const selected = getSelectedIds(type);
      if (!selected.length) {
        showToast('Select items first.', true);
        return;
      }

      const config = {
        questions: {
          collection: 'questions',
          addTags: document.getElementById('q-bulk-add-tags').value,
          removeTags: document.getElementById('q-bulk-remove-tags').value,
          category: document.getElementById('q-bulk-category').value,
          subcategory: document.getElementById('q-bulk-subcategory').value,
          items: allQuestions,
        },
        flashcards: {
          collection: 'flashcards',
          addTags: document.getElementById('fc-bulk-add-tags').value,
          removeTags: document.getElementById('fc-bulk-remove-tags').value,
          category: document.getElementById('fc-bulk-category').value,
          subcategory: document.getElementById('fc-bulk-subcategory').value,
          items: allFlashcards,
        },
        readings: {
          collection: 'readings',
          addTags: document.getElementById('r-bulk-add-tags').value,
          removeTags: document.getElementById('r-bulk-remove-tags').value,
          category: document.getElementById('r-bulk-category').value,
          subcategory: null,
          items: allReadings,
        },
      }[type];

      if (!config) return;
      const addTags = config.addTags.split(',').map(s => s.trim()).filter(Boolean);
      const removeTags = config.removeTags.split(',').map(s => s.trim()).filter(Boolean);
      const updates = selected.map(async (id) => {
        const item = config.items.find(i => i.id === id);
        if (!item) return;
        const nextTags = Array.from(new Set([...(item.tags || []), ...addTags])).filter(t => !removeTags.includes(t));
        const payload = { tags: nextTags, updatedAt: new Date().toISOString() };
        if (config.category) {
          payload.category = config.category;
          if (type === 'readings') {
            payload.categoryName = READING_CATEGORY_NAMES[config.category] || config.category;
          }
        }
        if (config.subcategory !== null && config.subcategory !== undefined && config.subcategory !== '') {
          payload.subcategory = config.subcategory;
        }
        await updateDoc(doc(db, config.collection, id), payload);
        Object.assign(item, payload);
      });

      try {
        await Promise.all(updates);
        showToast('Bulk update applied');
        if (type === 'questions') filterQuestions();
        if (type === 'flashcards') filterFlashcards();
        if (type === 'readings') filterReadings();
        updateTagOptions();
      } catch (e) {
        console.error(e);
        showToast('Bulk update failed.', true);
      }
    };

    window.toggleQuickEdit = (event, type, id) => {
      if (event) event.stopPropagation();
      const panel = document.getElementById(`qe-${type}-${toDomId(id)}`);
      if (!panel) return;
      panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
    };

    window.saveQuickEditQuestion = async (event, id) => {
      if (event) event.stopPropagation();
      const domId = toDomId(id);
      const stem = document.getElementById(`qe-q-stem-${domId}`).value;
      const leadIn = document.getElementById(`qe-q-leadin-${domId}`).value;
      const difficulty = document.getElementById(`qe-q-difficulty-${domId}`).value;
      const keyPoint = document.getElementById(`qe-q-keypoint-${domId}`).value;
      try {
        await updateDoc(doc(db, 'questions', id), {
          stem, leadIn, difficulty, keyPoint,
          updatedAt: new Date().toISOString(),
        });
        const item = allQuestions.find(q => q.id === id);
        if (item) Object.assign(item, { stem, leadIn, difficulty, keyPoint });
        showToast('Question updated');
        filterQuestions();
      } catch (e) {
        showToast('Quick edit failed', true);
      }
    };

    window.saveQuickEditFlashcard = async (event, id) => {
      if (event) event.stopPropagation();
      const domId = toDomId(id);
      const front = document.getElementById(`qe-fc-front-${domId}`).value;
      const back = document.getElementById(`qe-fc-back-${domId}`).value;
      const text = document.getElementById(`qe-fc-cloze-${domId}`).value.trim();
      const tags = document.getElementById(`qe-fc-tags-${domId}`).value.split(',').map(s => s.trim()).filter(Boolean);
      try {
        await updateDoc(doc(db, 'flashcards', id), {
          front, back, text: text || null, type: text ? 'cloze' : 'basic', tags,
          updatedAt: new Date().toISOString(),
        });
        const item = allFlashcards.find(fc => fc.id === id);
        if (item) Object.assign(item, { front, back, text: text || null, type: text ? 'cloze' : 'basic', tags });
        showToast('Flashcard updated');
        filterFlashcards();
      } catch (e) {
        showToast('Quick edit failed', true);
      }
    };

    window.saveQuickEditReading = async (event, id) => {
      if (event) event.stopPropagation();
      const domId = toDomId(id);
      const title = document.getElementById(`qe-r-title-${domId}`).value;
      const readingTime = parseInt(document.getElementById(`qe-r-time-${domId}`).value, 10) || 5;
      const tags = document.getElementById(`qe-r-tags-${domId}`).value.split(',').map(s => s.trim()).filter(Boolean);
      try {
        await updateDoc(doc(db, 'readings', id), {
          title, readingTime, tags,
          updatedAt: new Date().toISOString(),
        });
        const item = allReadings.find(r => r.id === id);
        if (item) Object.assign(item, { title, readingTime, tags });
        showToast('Reading updated');
        filterReadings();
      } catch (e) {
        showToast('Quick edit failed', true);
      }
    };

    const slugifyId = (value) => {
      return (value || '')
        .toLowerCase()
        .replace(/&/g, 'and')
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .replace(/_+/g, '_');
    };

    const getCategoryPrefix = (category) => {
      if (!category) return '';
      const key = category.trim().toUpperCase();
      const activeMap = getActivePrefixMap();
      return activeMap[key] || slugifyId(key);
    };

    window.openPrefixModal = () => {
      const textarea = document.getElementById('prefix-config');
      textarea.value = JSON.stringify(getActivePrefixMap(), null, 2);
      document.getElementById('prefix-modal').classList.add('active');
    };

    window.closePrefixModal = () => {
      document.getElementById('prefix-modal').classList.remove('active');
    };

    window.savePrefixOverrides = () => {
      try {
        const textarea = document.getElementById('prefix-config');
        const parsed = JSON.parse(textarea.value || '{}');
        if (!parsed || typeof parsed !== 'object') {
          showToast('Invalid JSON for prefix map.', true);
          return;
        }
        categoryPrefixOverrides = parsed;
        localStorage.setItem(PREFIX_STORAGE_KEY, JSON.stringify(parsed));
        showToast('Prefix map saved.');
        closePrefixModal();
      } catch (e) {
        showToast('Invalid JSON for prefix map.', true);
      }
    };

    window.resetPrefixOverrides = () => {
      categoryPrefixOverrides = {};
      localStorage.removeItem(PREFIX_STORAGE_KEY);
      document.getElementById('prefix-config').value = JSON.stringify(CATEGORY_PREFIXES, null, 2);
      showToast('Prefix map reset to defaults.');
    };

    window.generateQuestionId = async () => {
      const category = document.getElementById('qf-category').value;
      if (!category) {
        showToast('Select a category first.', true);
        return;
      }
      const subcategoryRaw = document.getElementById('qf-subcategory').value || 'general';
      const categoryPrefix = getCategoryPrefix(category);
      const subcategorySlug = slugifyId(subcategoryRaw) || 'general';
      const basePrefix = `${categoryPrefix}_`;
      const idPrefix = `${categoryPrefix}_${subcategorySlug}_`;

      try {
        const snap = await getDocs(
          query(
            collection(db, 'questions'),
            orderBy('__name__'),
            startAt(basePrefix),
            endAt(`${basePrefix}\uf8ff`)
          )
        );
        let maxNum = 0;
        snap.forEach(d => {
          const id = d.id || '';
          if (!id.startsWith(basePrefix)) return;
          const parts = id.split('_');
          const last = parts[parts.length - 1];
          const num = parseInt(last, 10);
          if (Number.isFinite(num) && num > maxNum) {
            maxNum = num;
          }
        });
        const next = String(maxNum + 1).padStart(3, '0');
        document.getElementById('qf-id').value = `${idPrefix}${next}`;
        showToast(`Generated ID: ${idPrefix}${next}`);
      } catch (e) {
        console.error(e);
        showToast('Failed to generate ID.', true);
      }
    };

    const loadAllPages = async (loader) => {
      let hasMore = true;
      while (hasMore) {
        const prevLoaded = loader.loadedCount();
        await loader.loadMore();
        hasMore = loader.hasMore();
        if (loader.loadedCount() === prevLoaded) break;
      }
    };

    window.runLinkerSearch = () => {
      const keyword = normalizeText(document.getElementById('linker-search').value.trim());
      const filteredQuestions = allQuestions.filter(q => !q.deletedAt && (!keyword || getQuestionSearchText(q).includes(keyword)));
      const filteredFlashcards = allFlashcards.filter(fc => !fc.deletedAt && (!keyword || getFlashcardSearchText(fc).includes(keyword)));
      const filteredReadings = allReadings.filter(r => !r.deletedAt && (!keyword || getReadingSearchText(r).includes(keyword)));

      const questionHtml = filteredQuestions.length
        ? filteredQuestions.map(q => `
            <div class="item-card">
              <div class="id"><input type="checkbox" class="linker-question" value="${q.id}" /> ${q.id}</div>
              <div class="title">${q.stem || q.leadIn || 'No stem'}</div>
              <div class="meta">
                <span class="tag tag-blue">${q.category || 'Uncategorized'}</span>
                <span>${q.subcategory || ''}</span>
              </div>
            </div>
          `).join('')
        : '<div class="loading">No questions found.</div>';

      const flashcardHtml = filteredFlashcards.length
        ? filteredFlashcards.map(fc => `
            <div class="item-card">
              <div class="id"><input type="checkbox" class="linker-flashcard" value="${fc.id}" /> ${fc.id}</div>
              <div class="title">${fc.front || fc.text || 'Flashcard'}</div>
              <div class="meta">
                <span class="tag tag-purple">${fc.category || 'Uncategorized'}</span>
                <span>${fc.subcategory || ''}</span>
              </div>
            </div>
          `).join('')
        : '<div class="loading">No flashcards found.</div>';

      const readingHtml = filteredReadings.length
        ? filteredReadings.map(r => `
            <div class="item-card">
              <div class="id"><input type="checkbox" class="linker-reading" value="${r.id}" /> ${r.id}</div>
              <div class="title">${r.title || 'Untitled'}</div>
              <div class="meta">
                <span class="tag tag-blue">${r.categoryName || r.category || ''}</span>
                <span>${r.readingTime || '?'} min</span>
              </div>
            </div>
          `).join('')
        : '<div class="loading">No readings found.</div>';

      document.getElementById('linker-questions').innerHTML = questionHtml;
      document.getElementById('linker-flashcards').innerHTML = flashcardHtml;
      document.getElementById('linker-readings').innerHTML = readingHtml;
    };

    window.loadLinkerData = async () => {
      if (!confirm('Load full questions, flashcards, and readings for Linker? This increases Firestore reads.')) return;
      try {
        const [qSnap, fcSnap, rSnap] = await Promise.all([
          getDocs(query(collection(db, 'questions'), orderBy('__name__'))),
          getDocs(query(collection(db, 'flashcards'), orderBy('__name__'))),
          getDocs(query(collection(db, 'readings'), orderBy('__name__')))
        ]);
        allQuestions = [];
        qSnap.forEach(d => allQuestions.push({ id: d.id, ...d.data() }));
        allFlashcards = [];
        fcSnap.forEach(d => allFlashcards.push({ id: d.id, ...d.data() }));
        allReadings = [];
        rSnap.forEach(d => allReadings.push({ id: d.id, ...d.data() }));
        updateTagOptions();
        filterQuestions();
        filterFlashcards();
        filterReadings();
        showToast('Linker data loaded');
      } catch (e) {
        showToast(e.message, true);
      }
    };

    const getCheckedValues = (selector) => {
      return Array.from(document.querySelectorAll(selector))
        .filter(el => el.checked)
        .map(el => el.value);
    };

    window.linkSelectedQuestionsToReadings = async () => {
      const questionIds = getCheckedValues('.linker-question');
      const readingIds = getCheckedValues('.linker-reading');
      if (questionIds.length === 0 || readingIds.length === 0) {
        showToast('Select questions and readings first.', true);
        return;
      }
      try {
        for (const readingId of readingIds) {
          const reading = allReadings.find(r => r.id === readingId);
          const existing = reading?.questionIds || [];
          const next = Array.from(new Set([...existing, ...questionIds]));
          await updateDoc(doc(db, 'readings', readingId), {
            questionIds: next,
            updatedAt: new Date().toISOString()
          });
        }
        showToast('Linked questions to readings');
        loadReadings();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.linkSelectedQuestionsToFlashcards = async () => {
      const questionIds = getCheckedValues('.linker-question');
      const flashcardIds = getCheckedValues('.linker-flashcard');
      if (questionIds.length === 0 || flashcardIds.length === 0) {
        showToast('Select questions and flashcards first.', true);
        return;
      }
      try {
        for (const flashcardId of flashcardIds) {
          const fc = allFlashcards.find(f => f.id === flashcardId);
          const existing = fc?.relatedQuestions || [];
          const next = Array.from(new Set([...existing, ...questionIds]));
          await updateDoc(doc(db, 'flashcards', flashcardId), {
            relatedQuestions: next,
            updatedAt: new Date().toISOString()
          });
        }
        showToast('Linked questions to flashcards');
        loadFlashcards();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    const ensureLinkerDataLoaded = async () => {
      if (!allQuestions.length || !allFlashcards.length || !allReadings.length) {
        await loadLinkerData();
      }
    };

    const buildQuestionLinkMaps = () => {
      const qToFlashcards = new Map();
      const qToReadings = new Map();
      allFlashcards.forEach(fc => {
        (fc.relatedQuestions || []).forEach(qid => {
          if (!qToFlashcards.has(qid)) qToFlashcards.set(qid, []);
          qToFlashcards.get(qid).push(fc.id);
        });
      });
      allReadings.forEach(r => {
        const qids = r.questionIds || r.relatedQuestions || [];
        qids.forEach(qid => {
          if (!qToReadings.has(qid)) qToReadings.set(qid, []);
          qToReadings.get(qid).push(r.id);
        });
      });
      return { qToFlashcards, qToReadings };
    };

    const getQuestionTitle = (q) => {
      return q.title || q.stem || q.question || q.text || 'Untitled question';
    };

    const getFlashcardTitle = (fc) => {
      return fc.front || fc.text || 'Flashcard';
    };

    const renderAuditList = (items, containerId, type) => {
      const cont = document.getElementById(containerId);
      if (!items.length) {
        cont.innerHTML = '<div class="loading">No issues found.</div>';
        return;
      }
      cont.innerHTML = items.map(item => {
        const meta = [
          item.category ? `<span class="tag tag-purple">${item.category}</span>` : '',
          item.subcategory ? `<span>${item.subcategory}</span>` : '',
          item.reason ? `<span>${item.reason}</span>` : ''
        ].filter(Boolean).join(' ');
        return `
          <div class="item-card">
            <div class="id">${item.id}</div>
            <div class="title">${item.title}</div>
            ${meta ? `<div class="meta">${meta}</div>` : ''}
          </div>
        `;
      }).join('');
    };

    let auditResults = { questions: [], flashcards: [], readings: [] };

    window.runAuditReport = async () => {
      await ensureLinkerDataLoaded();
      const { qToFlashcards, qToReadings } = buildQuestionLinkMaps();
      const questionsMissing = [];
      const flashcardsMissing = [];
      const readingsMissing = [];

      allQuestions.forEach(q => {
        if (q.deletedAt) return;
        const qid = q.id;
        const fcLinks = qToFlashcards.get(qid) || [];
        const rdLinks = qToReadings.get(qid) || [];
        if (fcLinks.length === 0 && rdLinks.length === 0) {
          questionsMissing.push({
            id: qid,
            title: getQuestionTitle(q),
            category: q.category || '',
            reason: 'No flashcards or readings linked'
          });
        }
      });

      allFlashcards.forEach(fc => {
        if (fc.deletedAt) return;
        const relatedQuestions = fc.relatedQuestions || [];
        const relatedReading = fc.relatedReading || '';
        if (!relatedQuestions.length && !relatedReading) {
          flashcardsMissing.push({
            id: fc.id,
            title: getFlashcardTitle(fc),
            category: fc.category || '',
            subcategory: fc.subcategory || '',
            reason: 'No relatedQuestions or relatedReading'
          });
        }
      });

      allReadings.forEach(r => {
        if (r.deletedAt) return;
        const questionIds = r.questionIds || r.relatedQuestions || [];
        if (!questionIds.length) {
          readingsMissing.push({
            id: r.id,
            title: r.title || 'Untitled reading',
            category: r.categoryName || r.category || '',
            reason: 'No questionIds linked'
          });
        }
      });

      auditResults = {
        questions: questionsMissing,
        flashcards: flashcardsMissing,
        readings: readingsMissing
      };

      const summary = `Questions missing: ${questionsMissing.length} • Flashcards missing: ${flashcardsMissing.length} • Readings missing: ${readingsMissing.length}`;
      document.getElementById('audit-summary').textContent = summary;

      renderAuditList(questionsMissing, 'audit-questions', 'question');
      renderAuditList(flashcardsMissing, 'audit-flashcards', 'flashcard');
      renderAuditList(readingsMissing, 'audit-readings', 'reading');
    };

    window.downloadAuditCsv = () => {
      const rows = [['type', 'id', 'title', 'category', 'subcategory', 'reason']];
      auditResults.questions.forEach(item => {
        rows.push(['question', item.id, item.title, item.category || '', item.subcategory || '', item.reason || '']);
      });
      auditResults.flashcards.forEach(item => {
        rows.push(['flashcard', item.id, item.title, item.category || '', item.subcategory || '', item.reason || '']);
      });
      auditResults.readings.forEach(item => {
        rows.push(['reading', item.id, item.title, item.category || '', item.subcategory || '', item.reason || '']);
      });
      if (rows.length === 1) {
        showToast('Run audit first to download CSV.', true);
        return;
      }
      const csv = rows.map(r => r.map(val => `"${String(val).replace(/\"/g, '""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `link_audit_${new Date().toISOString().slice(0, 10)}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    };

    const downloadTextFile = (content, filename, mimeType) => {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    };

    const serializeExportValue = (value) => {
      if (value === null || value === undefined) return value;
      if (value instanceof Date) return value.toISOString();
      if (typeof value === 'object' && typeof value.toDate === 'function') {
        return value.toDate().toISOString();
      }
      if (Array.isArray(value)) return value.map(serializeExportValue);
      if (typeof value === 'object') {
        const next = {};
        Object.keys(value).forEach(key => {
          next[key] = serializeExportValue(value[key]);
        });
        return next;
      }
      return value;
    };

    const normalizeExportDocs = (docs) => {
      return docs.map(item => serializeExportValue(item));
    };

    window.exportCollection = async (collectionType, format) => {
      const allowed = ['questions', 'flashcards', 'readings'];
      if (!allowed.includes(collectionType)) {
        showToast('Unsupported export type.', true);
        return;
      }
      const exportFormat = format === 'js' ? 'js' : 'json';
      try {
        showToast(`Exporting ${collectionType}...`);
        const snap = await getDocs(query(collection(db, collectionType), orderBy('__name__')));
        const rows = [];
        snap.forEach(docSnap => rows.push({ id: docSnap.id, ...docSnap.data() }));
        const normalized = normalizeExportDocs(rows);
        const stamp = new Date().toISOString().slice(0, 10);
        if (exportFormat === 'js') {
          const payload = `export const ${collectionType} = ${JSON.stringify(normalized, null, 2)};\nexport default ${collectionType};\n`;
          downloadTextFile(payload, `${collectionType}_${stamp}.js`, 'text/javascript;charset=utf-8;');
        } else {
          const payload = JSON.stringify(normalized, null, 2);
          downloadTextFile(payload, `${collectionType}_${stamp}.json`, 'application/json;charset=utf-8;');
        }
        showToast(`Exported ${rows.length} ${collectionType}.`);
      } catch (e) {
        console.error(e);
        showToast(`Export failed: ${e.message}`, true);
      }
    };

    window.exportReportsCSV = async () => {
      try {
        showToast('Exporting reports as CSV...');
        const snap = await getDocs(query(collection(db, 'reports'), orderBy('__name__')));
        const rows = [];
        snap.forEach(d => {
          rows.push({ cloudId: d.id, ...d.data() });
        });
        const normalizedRows = normalizeExportDocs(rows).sort((a, b) => {
          const left = valueToMillis(b.createdAt || b.timestamp);
          const right = valueToMillis(a.createdAt || a.timestamp);
          return left - right;
        });
        const headers = ['cloudId', 'type', 'itemId', 'itemTitle', 'status', 'description', 'userEmail', 'createdAt', 'updatedAt', 'adminNotes'];
        const csvRows = [headers.join(',')];
        normalizedRows.forEach(r => {
          csvRows.push(headers.map(h => {
            const val = r[h] ?? '';
            return '"' + String(val).replace(/"/g, '""') + '"';
          }).join(','));
        });
        const stamp = new Date().toISOString().slice(0, 10);
        downloadTextFile(csvRows.join('\n'), `reports_${stamp}.csv`, 'text/csv;charset=utf-8;');
        showToast(`Exported ${normalizedRows.length} reports as CSV.`);
      } catch (e) {
        console.error(e);
        showToast(`Export failed: ${e.message}`, true);
      }
    };

    window.exportReportsJSON = async () => {
      try {
        showToast('Exporting reports as JSON...');
        const snap = await getDocs(query(collection(db, 'reports'), orderBy('__name__')));
        const rows = [];
        snap.forEach(d => rows.push({ id: d.id, ...d.data() }));
        const normalized = normalizeExportDocs(rows).sort((a, b) => {
          const left = valueToMillis(b.createdAt || b.timestamp);
          const right = valueToMillis(a.createdAt || a.timestamp);
          return left - right;
        });
        const stamp = new Date().toISOString().slice(0, 10);
        downloadTextFile(JSON.stringify(normalized, null, 2), `reports_${stamp}.json`, 'application/json;charset=utf-8;');
        showToast(`Exported ${rows.length} reports as JSON.`);
      } catch (e) {
        console.error(e);
        showToast(`Export failed: ${e.message}`, true);
      }
    };

    const getSelectedQuestionTags = (questionIds) => {
      const tagSet = new Set();
      questionIds.forEach(id => {
        const q = allQuestions.find(item => item.id === id);
        (q?.tags || []).forEach(tag => tagSet.add(tag));
      });
      return Array.from(tagSet);
    };

    window.autoLinkQuestionsToFlashcardsByTags = async () => {
      const questionIds = getCheckedValues('.linker-question');
      if (!questionIds.length) {
        showToast('Select questions first.', true);
        return;
      }
      await ensureLinkerDataLoaded();
      const tags = getSelectedQuestionTags(questionIds);
      if (!tags.length) {
        showToast('Selected questions have no tags.', true);
        return;
      }
      try {
        const updates = [];
        allFlashcards.forEach(fc => {
          const fcTags = fc.tags || [];
          if (!fcTags.length) return;
          const matches = fcTags.some(tag => tags.includes(tag));
          if (!matches) return;
          const existing = fc.relatedQuestions || [];
          const next = Array.from(new Set([...existing, ...questionIds]));
          updates.push(updateDoc(doc(db, 'flashcards', fc.id), {
            relatedQuestions: next,
            updatedAt: new Date().toISOString(),
          }));
          fc.relatedQuestions = next;
        });
        await Promise.all(updates);
        showToast('Auto-linked by tags');
        loadFlashcards();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.autoLinkQuestionsToReadingsByTags = async () => {
      const questionIds = getCheckedValues('.linker-question');
      if (!questionIds.length) {
        showToast('Select questions first.', true);
        return;
      }
      await ensureLinkerDataLoaded();
      const tags = getSelectedQuestionTags(questionIds);
      if (!tags.length) {
        showToast('Selected questions have no tags.', true);
        return;
      }
      try {
        const updates = [];
        allReadings.forEach(r => {
          const rTags = r.tags || [];
          if (!rTags.length) return;
          const matches = rTags.some(tag => tags.includes(tag));
          if (!matches) return;
          const existing = r.questionIds || r.relatedQuestions || [];
          const next = Array.from(new Set([...existing, ...questionIds]));
          updates.push(updateDoc(doc(db, 'readings', r.id), {
            questionIds: next,
            updatedAt: new Date().toISOString(),
          }));
          r.questionIds = next;
        });
        await Promise.all(updates);
        showToast('Auto-linked by tags');
        loadReadings();
      } catch (e) {
        showToast(e.message, true);
      }
    };

    const parseLineList = (value) => {
      if (!value) return [];
      return value.split(/[\n,]+/).map(v => v.trim()).filter(Boolean);
    };

    const getCategoryName = (cat) => {
      return READING_CATEGORY_NAMES[cat] || cat;
    };

    const toggleQuickPanels = () => {
      const type = document.getElementById('quick-type').value;
      document.getElementById('quick-question').style.display = type === 'question' ? 'block' : 'none';
      document.getElementById('quick-flashcard').style.display = type === 'flashcard' ? 'block' : 'none';
      document.getElementById('quick-reading').style.display = type === 'reading' ? 'block' : 'none';
    };
    document.getElementById('quick-type').addEventListener('change', toggleQuickPanels);
    toggleQuickPanels();

    window.quickAdd = async () => {
      const type = document.getElementById('quick-type').value;
      try {
        if (type === 'question') {
          const id = document.getElementById('quick-q-id').value.trim() || `new_${Date.now()}`;
          const options = [
            document.getElementById('quick-q-option-a').value.trim(),
            document.getElementById('quick-q-option-b').value.trim(),
            document.getElementById('quick-q-option-c').value.trim(),
            document.getElementById('quick-q-option-d').value.trim()
          ].filter(Boolean);
          const correctLetter = document.getElementById('quick-q-correct').value.trim().toUpperCase();
          const correctIndex = ['A', 'B', 'C', 'D'].indexOf(correctLetter);
          await setDoc(doc(db, 'questions', id), {
            id,
            category: document.getElementById('quick-q-category').value.trim(),
            subcategory: document.getElementById('quick-q-subcategory').value.trim(),
            difficulty: document.getElementById('quick-q-difficulty').value,
            tags: parseLineList(document.getElementById('quick-q-tags').value),
            stem: document.getElementById('quick-q-stem').value.trim(),
            leadIn: document.getElementById('quick-q-leadin').value.trim(),
            options,
            correctIndex: correctIndex >= 0 ? correctIndex : 0,
            explanation: document.getElementById('quick-q-explanation').value.trim(),
            updatedAt: new Date().toISOString()
          });
          showToast('Question saved');
          loadQuestions();
        } else if (type === 'flashcard') {
          const id = document.getElementById('quick-fc-id').value.trim() || `fc_${Date.now()}`;
          const cloze = document.getElementById('quick-fc-cloze').value.trim();
          await setDoc(doc(db, 'flashcards', id), {
            id,
            category: document.getElementById('quick-fc-category').value.trim(),
            subcategory: document.getElementById('quick-fc-subcategory').value.trim(),
            difficulty: document.getElementById('quick-fc-difficulty').value,
            text: cloze || null,
            type: cloze ? 'cloze' : 'basic',
            front: document.getElementById('quick-fc-front').value.trim(),
            back: document.getElementById('quick-fc-back').value.trim(),
            notes: document.getElementById('quick-fc-notes').value.trim(),
            tags: parseLineList(document.getElementById('quick-fc-tags').value),
            relatedQuestions: parseLineList(document.getElementById('quick-fc-related').value),
            relatedReading: document.getElementById('quick-fc-reading').value.trim(),
            updatedAt: new Date().toISOString()
          });
          showToast('Flashcard saved');
          loadFlashcards();
        } else {
          const id = document.getElementById('quick-r-id').value.trim() || `reading_${Date.now()}`;
          const cat = document.getElementById('quick-r-category').value.trim();
          const tags = parseLineList(document.getElementById('quick-r-tags').value);
          await setDoc(doc(db, 'readings', id), {
            id,
            category: cat,
            categoryName: getCategoryName(cat),
            title: document.getElementById('quick-r-title').value.trim(),
            readingTime: parseInt(document.getElementById('quick-r-time').value, 10) || 5,
            wordCount: parseInt(document.getElementById('quick-r-words').value, 10) || 0,
            priority: document.getElementById('quick-r-priority').value,
            questionIds: parseLineList(document.getElementById('quick-r-questions').value),
            tags,
            content: document.getElementById('quick-r-content').value,
            updatedAt: new Date().toISOString()
          });
          showToast('Reading saved');
          loadReadings();
        }
      } catch (e) {
        showToast(e.message, true);
      }
    };

    const sanitizeReadingId = (value) => value.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_/-]/g, '');

    const getFilenameBase = (filename = '') => {
      if (!filename) return `reading_${Date.now()}`;
      const base = filename.replace(/\.[^.]+$/, '');
      return sanitizeReadingId(base) || `reading_${Date.now()}`;
    };

    window.loadMarkdownReading = async () => {
      const fileInput = document.getElementById('markdown-reading-file');
      const category = document.getElementById('markdown-reading-category').value.trim();
      if (!fileInput.files || !fileInput.files[0]) {
        showToast('Select a markdown file first.', true);
        return;
      }
      if (!category) {
        showToast('Enter a category first.', true);
        return;
      }
      try {
        const file = fileInput.files[0];
        const text = await file.text();
        const titleMatch = text.match(/^#\s+(.+)$/m);
        const fallbackTitle = file.name.replace(/\.[^.]+$/, '');
        const title = titleMatch ? titleMatch[1].trim() : fallbackTitle;
        const wordCount = (text.match(/\b\w+\b/g) || []).length;
        const readingTime = Math.max(1, Math.round(wordCount / 200));
        const manualId = document.getElementById('markdown-reading-id').value.trim();
        const baseId = manualId || `${category}/${getFilenameBase(file.name)}`;

        document.getElementById('quick-type').value = 'reading';
        toggleQuickPanels();
        document.getElementById('quick-r-id').value = baseId;
        document.getElementById('quick-r-category').value = category;
        document.getElementById('quick-r-title').value = title;
        document.getElementById('quick-r-time').value = readingTime;
        document.getElementById('quick-r-words').value = wordCount;
        document.getElementById('quick-r-priority').value = document.getElementById('markdown-reading-priority').value;
        document.getElementById('quick-r-questions').value = document.getElementById('markdown-reading-questions').value.trim();
        document.getElementById('quick-r-tags').value = '';
        document.getElementById('quick-r-content').value = text;
        showToast('Loaded markdown into Quick Add');
      } catch (e) {
        showToast(e.message, true);
      }
    };

    window.importFromTemplate = async () => {
      const raw = document.getElementById('bulk-import').value.trim();
      if (!raw) {
        showToast('Paste content first.', true);
        return;
      }

      const blocks = raw.split(/\n---+\n/);
      let successCount = 0;

      for (const block of blocks) {
        const lines = block.split('\n');
        const data = {};
        let currentKey = null;
        let buffer = [];
        const flushBuffer = () => {
          if (currentKey) {
            data[currentKey] = buffer.join('\n').trim();
          }
          currentKey = null;
          buffer = [];
        };

        lines.forEach(line => {
          const trimmed = line.trim();
          if (!trimmed) return;
          if (trimmed.endsWith('<<')) {
            flushBuffer();
            currentKey = trimmed.replace(/<<$/, '').replace(/[:=]\s*$/, '').toUpperCase();
            buffer = [];
            return;
          }
          if (trimmed === '>>') {
            flushBuffer();
            return;
          }
          const match = trimmed.match(/^([A-Z_]+)\s*[:=]\s*(.*)$/);
          if (match) {
            flushBuffer();
            data[match[1].toUpperCase()] = match[2];
          } else if (currentKey) {
            buffer.push(line);
          }
        });
        flushBuffer();

        const type = (data.TYPE || '').toLowerCase();
        if (!type) continue;

        try {
          if (type === 'question') {
            const id = data.ID || `new_${Date.now()}`;
            const options = (data.OPTIONS || '').split('|').map(s => s.trim()).filter(Boolean);
            const correctLetter = (data.CORRECT || '').trim().toUpperCase();
            const correctIndex = ['A', 'B', 'C', 'D'].indexOf(correctLetter);
            await setDoc(doc(db, 'questions', id), {
              id,
              category: data.CATEGORY || '',
              subcategory: data.SUBCATEGORY || '',
              difficulty: data.DIFFICULTY || 'intermediate',
              tags: parseLineList(data.TAGS || ''),
              stem: data.STEM || '',
              leadIn: data.LEADIN || '',
              options,
              correctIndex: correctIndex >= 0 ? correctIndex : 0,
              explanation: data.EXPLANATION || '',
              updatedAt: new Date().toISOString()
            });
          } else if (type === 'flashcard') {
            const id = data.ID || `fc_${Date.now()}`;
            const cloze = data.CLOZE || '';
            await setDoc(doc(db, 'flashcards', id), {
              id,
              category: data.CATEGORY || '',
              subcategory: data.SUBCATEGORY || '',
              difficulty: data.DIFFICULTY || 'intermediate',
              text: cloze || null,
              type: cloze ? 'cloze' : 'basic',
              front: data.FRONT || '',
              back: data.BACK || '',
              notes: data.NOTES || '',
              tags: parseLineList(data.TAGS || ''),
              relatedQuestions: parseLineList(data.RELATED_QUESTIONS || ''),
              relatedReading: data.RELATED_READING || '',
              updatedAt: new Date().toISOString()
            });
          } else if (type === 'reading') {
            const id = data.ID || `reading_${Date.now()}`;
            const cat = data.CATEGORY || '';
            await setDoc(doc(db, 'readings', id), {
              id,
              category: cat,
              categoryName: getCategoryName(cat),
              title: data.TITLE || '',
              content: data.CONTENT || '',
              readingTime: parseInt(data.READING_TIME, 10) || 5,
              wordCount: parseInt(data.WORD_COUNT, 10) || 0,
              priority: data.PRIORITY || 'suggested',
              questionIds: parseLineList(data.QUESTION_IDS || ''),
              tags: parseLineList(data.TAGS || ''),
              updatedAt: new Date().toISOString()
            });
          }
          successCount += 1;
        } catch (e) {
          console.error(e);
        }
      }

      showToast(`Imported ${successCount} item${successCount !== 1 ? 's' : ''}`);
      loadQuestions();
      loadFlashcards();
      loadReadings();
    };
  </script>
</body>
</html>
