import React, { useCallback, useState, useEffect, useMemo, useRef } from 'react';
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  SafeAreaView,
  Dimensions,
  Alert,
  TextInput,
  Platform,
  Modal,
  Pressable,
  Linking,
  Appearance,
  useColorScheme,
  Animated,
  AppState,
  PanResponder,
  InteractionManager,
} from 'react-native';

// Cross-platform alert helper that works on web
const showAlert = (title, message, buttons = [{ text: 'OK' }]) => {
  if (Platform.OS === 'web') {
    // For web, use confirm for two buttons, alert for one
    if (buttons.length === 2) {
      const confirmed = window.confirm(`${title}\n\n${message}`);
      if (confirmed && buttons[1]?.onPress) {
        buttons[1].onPress();
      } else if (!confirmed && buttons[0]?.onPress) {
        buttons[0].onPress();
      }
    } else {
      window.alert(`${title}\n\n${message}`);
      if (buttons[0]?.onPress) {
        buttons[0].onPress();
      }
    }
  } else {
    Alert.alert(title, message, buttons);
  }
};
import { StatusBar } from 'expo-status-bar';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';
import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  updateDoc,
  query,
  where,
  serverTimestamp,
  setDoc,
} from 'firebase/firestore';
import { db } from './src/config/firebase';
import MarkdownContent from './src/components/MarkdownContent';
import WatermarkOverlay from './src/components/WatermarkOverlay';
import TermsModal from './src/components/TermsModal';
import { TERMS_OF_SERVICE_TEXT, TERMS_TITLE } from './src/content/terms';
import PetArt from './src/components/PetArt';
import AdminEditModal from './src/components/AdminEditModal';

console.log('[App.js] Starting imports...');

// Auth imports
import { AuthProvider, useAuth } from './src/context/AuthContext';
console.log('[App.js] AuthContext imported');
import AuthScreen from './src/screens/AuthScreen';
console.log('[App.js] AuthScreen imported');

// Cloud sync imports
import {
  loadUserDataFromCloud,
  saveUserDataToCloud,
  updateUserDataInCloud,
  mergeData,
  initializeCloudData,
  submitReportToCloud,
  fetchUserFlashcards,
  upsertUserFlashcard,
  upsertUserFlashcardsBatch,
  loadUserSrsSettings,
  saveUserSrsSettings,
  upsertUserQuestionState,
  createRemediationTask,
  appendReviewLogsBatch,
} from './src/data/cloudSync';
console.log('[App.js] cloudSync imported');

// Import learning algorithms
import {
  calculateNextReview,
  getSrsEngine,
  getDueCards,
  getNewCards,
  calculateRetention,
  QUALITY
} from './src/data/spacedRepetition';
import {
  ENT_CATEGORIES,
  PEDS_ENDO_CATEGORIES,
  getInterleavedQuestions,
  getWeakAreaQuestions,
  getInterleavedQuestionsWithDue,
  filterOutRecentQuestions
} from './src/data/interleaving';
import { SPECIALTIES, getSpecialty, isPedsEndoQuestion as isPedsEndoQuestionFromSpecialties } from './src/data/specialties';
import {
  generateCardsFromQuestion,
  renderClozeCard,
  rateFlashcard,
  getDueFlashcards,
  getFlashcardStats,
  predictNextIntervals,
  createManualClozeCard,
  toggleSuspendCard,
  setCustomInterval,
  unlockRelatedFlashcards,
  getUnlockedCount,
  getLockedCount,
} from './src/data/flashcards';
import {
  flushPendingProgressEvents,
  recordQuestionAttempt,
  recordFlashcardReview,
  recordReadingCompletion,
  recordBattleResult,
  fetchUserStats,
  fetchQuestionStats,
  fetchFlashcardStats,
  mergeQuestionStats,
  applyFlashcardStats,
} from './src/data/progressSync';
import {
  getSuggestedReadingForMissedQuestions,
  analyzeWeaknesses,
  getImprovementSuggestions,
} from './src/data/contentLoader';
import { RESOURCE_TYPES, formatCitation } from './src/data/resources';
import storage, {
  loadAllData,
  saveSessionHistory,
  saveCardData,
  saveFlashcards,
  saveRecentCategories,
  saveReadTopics,
  saveReportedIssues,
  savePetData,
  saveCoinData,
  saveShopData,
  saveRoomData,
  saveThemeMode,
  saveSavedSessions,
  saveCustomTestPresets,
  saveGameProgress,
  saveReviewLogs,
  loadReviewLogs,
  savePendingReviewLogs,
  loadPendingReviewLogs,
  clearPendingReviewLogs,
  exportData,
  importData,
  getStorageStats,
  savePendingCloudUpdates,
  loadPendingCloudUpdates,
  clearPendingCloudUpdates,
} from './src/data/storage';
console.log('[App.js] storage imported');

// Pet system imports
import {
  COIN_RATES,
  XP_RATES,
  createInitialCoinData,
  awardCoins,
  spendCoins,
  checkDailyLogin,
  checkFirstSessionBonus,
  calculateSessionBonus,
  formatCoins,
} from './src/data/coinSystem';
import {
  PET_STAGES,
  STAGE_NAMES,
  STAGE_THRESHOLDS,
  PET_SPECIES,
  MAX_PETS,
  HAPPINESS_BOOSTS,
  createInitialPetData,
  createPet,
  addExperience,
  updateHappiness,
  calculateHappinessDecay,
  getPetDisplayInfo,
  canAddPet,
  getAvailableSpecies,
  feedPet,
  interactWithPet,
  renamePet,
} from './src/data/petSystem';
import {
  ITEM_CATEGORIES,
  SHOP_ITEMS,
  ROOM_EXPANSIONS,
  getItemsByCategory,
  getMedicalItems,
  getNextRoomExpansion,
  getItemById,
  getRarityColor,
  canAfford,
  createInitialShopData,
} from './src/data/shopItems';
import {
  MAX_ROOMS,
  createInitialRoomData,
  addRoom,
  setRoomBackground,
  placeFurniture,
  moveFurniture,
  removeFurniture,
  getRoomById,
  getNextExpansion,
  canExpandRooms,
  initializePetPosition,
  updatePetPosition,
  movePetToRoom,
  getPetsInRoom,
  getRoomStats,
} from './src/data/roomSystem';
import {
  createInitialGameProgress,
  ensureGameProgress,
  applyGameMetricUpdate,
  setBattleDataOnProgress,
} from './src/data/gameProgress';
import {
  createInitialBattleData,
  getBattleCooldown,
  runPracticeBattle,
} from './src/data/battleSystem';

// Content service for Firestore integration
import { initializeContent } from './src/data/contentService';

const ALL_RESOURCES = [];

const { width, height } = Dimensions.get('window');

// Note: Questions are loaded dynamically from Firestore via initializeContent()

// Board Exam Question Distribution (Written & OTE)
// Based on Patient Care Process categories
const EXAM_DISTRIBUTION_PROCESS = {
  BASICS: { name: 'Basic Science', percent: 10, count: 20 },
  DATA_GATHERING: { name: 'Data Gathering & Interpretation', percent: 24, count: 48 },
  DIAGNOSIS: { name: 'Diagnosis', percent: 20, count: 40 },
  MANAGEMENT_NON_SURGICAL: { name: 'Non-Surgical Management', percent: 13, count: 26 },
  MANAGEMENT_SURGICAL_PRINCIPLES: { name: 'Surgical Principles', percent: 5, count: 10 },
  MANAGEMENT_SURGICAL: { name: 'Surgical Management', percent: 13, count: 26 },
  CLINICAL_FUNDAMENTALS: { name: 'Clinical Fundamentals', percent: 15, count: 30 },
};

// Written Board Exam Distribution by Practice Area (Subspecialty)
// Now imported from specialties.js - use getSpecialty(activePracticeContext).examDistribution
// Keeping EXAM_DISTRIBUTION_SPECIALTY as alias for backward compatibility
const EXAM_DISTRIBUTION_SPECIALTY = SPECIALTIES.ent.examDistribution;

// Practice Test Modes (question-based)
const PRACTICE_TEST_MODES = {
  EXAM_SIMULATION: {
    id: 'exam_sim',
    name: 'Exam Simulation',
    description: 'Full 200-question exam with board distribution',
    icon: 'school-outline',
    color: '#9C27B0'
  },
  TIMED_TEST: {
    id: 'timed',
    name: 'Quick Test',
    description: 'Timed 25-question practice session',
    icon: 'timer-outline',
    color: '#4CAF50'
  },
  MIXED_PRACTICE: {
    id: 'interleaved',
    name: 'Mixed Practice',
    description: 'Random questions from all topics',
    icon: 'shuffle-outline',
    color: '#FF9800'
  },
  CATEGORY: {
    id: 'category',
    name: 'By Category',
    description: 'Focus on specific ENT subspecialties',
    icon: 'folder-outline',
    color: '#2196F3'
  },
  // PEDS_ENDO mode removed - specialty selection now in Settings via PracticeContextModal
  WEAK_AREAS: {
    id: 'weak',
    name: 'Target Weak Areas',
    description: 'Practice questions you struggle with',
    icon: 'fitness-outline',
    color: '#F44336'
  }
};

// Review Modes (flashcard/spaced repetition based)
const REVIEW_MODES = {
  FLASHCARDS: {
    id: 'flashcards',
    name: 'Flashcards',
    description: 'Review cloze cards with spaced repetition',
    icon: 'albums-outline',
    color: '#E91E63'
  },
  WEAKNESS_ANALYSIS: {
    id: 'weakness',
    name: 'Dashboard',
    description: 'KPI overview, trends, and topic breakdown',
    icon: 'analytics-outline',
    color: '#FF5722'
  }
};

// Combined for backward compatibility
const PRACTICE_MODES = { ...PRACTICE_TEST_MODES, ...REVIEW_MODES };
const MAX_SAVED_SESSIONS = 20;
const PROGRESS_SERVER_FIRST = true;
const DAY_MS = 24 * 60 * 60 * 1000;

const getDayKey = (timestamp) => {
  const date = new Date(timestamp);
  if (Number.isNaN(date.getTime())) return null;
  return date.toISOString().slice(0, 10);
};

const buildRecentSessionTrend = (history = [], days = 7) => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const buckets = [];
  const bucketByKey = new Map();
  for (let i = days - 1; i >= 0; i -= 1) {
    const date = new Date(today.getTime() - i * DAY_MS);
    const key = date.toISOString().slice(0, 10);
    const bucket = {
      key,
      shortLabel: date.toLocaleDateString(undefined, { weekday: 'short' }),
      attempts: 0,
      correct: 0,
      sessions: 0,
      accuracy: 0,
    };
    buckets.push(bucket);
    bucketByKey.set(key, bucket);
  }

  (Array.isArray(history) ? history : []).forEach((session) => {
    const timestamp = typeof session?.timestamp === 'number' ? session.timestamp : null;
    if (!timestamp) return;

    const key = getDayKey(timestamp);
    const bucket = key ? bucketByKey.get(key) : null;
    if (!bucket) return;

    const attempts = Number(session.total) || 0;
    const correct = Number(session.correct) || 0;
    if (attempts <= 0) return;

    bucket.attempts += attempts;
    bucket.correct += Math.min(attempts, Math.max(0, correct));
    bucket.sessions += 1;
  });

  buckets.forEach((bucket) => {
    bucket.accuracy = bucket.attempts > 0
      ? Math.round((bucket.correct / bucket.attempts) * 100)
      : 0;
  });

  return buckets;
};

const normalizeReadingResources = (readings) => {
  if (!Array.isArray(readings)) return [];
  return readings.map((reading) => {
    const questionIds = Array.isArray(reading.questionIds)
      ? reading.questionIds
      : Array.isArray(reading.relatedQuestions)
        ? reading.relatedQuestions
        : typeof reading.relatedQuestions === 'string'
          ? reading.relatedQuestions.split(/[\n,]+/).map(s => s.trim()).filter(Boolean)
          : [];

    const tags = Array.isArray(reading.tags) && reading.tags.length > 0
      ? reading.tags
      : reading.categoryName
        ? [reading.categoryName]
        : reading.category
          ? [reading.category]
          : [];

    return {
      ...reading,
      questionIds,
      tags,
    };
  });
};

const normalizeRemoteFlashcards = (cards) => {
  if (!Array.isArray(cards)) return [];
  return cards.map((card) => {
    const text = card.text || '';
    const answers = Array.isArray(card.answers)
      ? card.answers
      : (text.match(/\{\{c::([^}]+)\}\}/g) || []).map(m => m.replace(/^\{\{c::/, '').replace(/\}\}$/, ''));

    return {
      type: card.type || ((card.front || card.back) && !text ? 'basic' : 'cloze'),
      answers: (card.front || card.back) && !text ? [] : answers,
      tags: Array.isArray(card.tags) ? card.tags : [],
      relatedQuestions: Array.isArray(card.relatedQuestions) ? card.relatedQuestions : [],
      easeFactor: card.easeFactor ?? 2.5,
      interval: card.interval ?? 0,
      repetitions: card.repetitions ?? 0,
      nextReview: card.nextReview ?? null,
      lastReview: card.lastReview ?? null,
      updatedAt: card.updatedAt ?? card.lastReview ?? card.created ?? null,
      created: card.created ?? Date.now(),
      reviewCount: card.reviewCount ?? 0,
      suspended: card.suspended ?? false,
      customInterval: card.customInterval ?? null,
      lastRating: card.lastRating ?? null,
      boostUntil: card.boostUntil ?? null,
      leech: card.leech ?? null,
      locked: card.locked ?? true,
      ...card,
      text,
    };
  });
};

const getCardUpdatedAt = (card) => {
  if (!card) return 0;
  const raw = card.updatedAt;
  if (raw && typeof raw.toMillis === 'function') return raw.toMillis();
  if (typeof raw === 'number') return raw;
  return card.lastReview || card.created || 0;
};

const touchFlashcard = (card) => ({
  ...card,
  updatedAt: Date.now(),
});

const mergeFlashcardsByUpdatedAt = (localCards, cloudCards) => {
  const map = new Map();
  (Array.isArray(localCards) ? localCards : []).forEach(card => {
    if (card?.id) map.set(card.id, card);
  });
  (Array.isArray(cloudCards) ? cloudCards : []).forEach(card => {
    if (!card?.id) return;
    const existing = map.get(card.id);
    if (!existing || getCardUpdatedAt(card) > getCardUpdatedAt(existing)) {
      map.set(card.id, card);
    }
  });
  return Array.from(map.values());
};

const getMissingFlashcardQuestions = (questionIds, flashcards, allQuestions) => {
  const ids = Array.isArray(questionIds) ? questionIds : [];
  if (ids.length === 0) return [];
  const idSet = new Set(ids);
  const hasCard = new Set();

  flashcards.forEach(card => {
    if (!card) return;
    if (card.sourceQuestionId && idSet.has(card.sourceQuestionId)) {
      hasCard.add(card.sourceQuestionId);
    }
    if (Array.isArray(card.relatedQuestions)) {
      card.relatedQuestions.forEach(qid => {
        if (idSet.has(qid)) hasCard.add(qid);
      });
    }
  });

  return ids
    .filter(id => !hasCard.has(id))
    .map(id => allQuestions.find(q => q.id === id))
    .filter(Boolean);
};

// Storage key
// Data is now persisted via AsyncStorage (see src/data/storage.js)

// Main App Component - wraps everything in AuthProvider
// Error Boundary to catch and display errors
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('App Error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      const isDark = Appearance.getColorScheme() === 'dark';
      return (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: isDark ? '#1a1a2e' : '#f7f7f8', padding: 32 }}>
          <Ionicons name="warning-outline" size={48} color="#f44336" style={{ marginBottom: 16 }} />
          <Text style={{ color: isDark ? '#fff' : '#1a1a2e', fontSize: 22, fontWeight: '700', marginBottom: 8 }}>Something went wrong</Text>
          <Text style={{ color: isDark ? '#aaa' : '#666', fontSize: 14, textAlign: 'center', lineHeight: 20, marginBottom: 24 }}>
            {this.state.error?.message || 'An unexpected error occurred'}
          </Text>
          <TouchableOpacity
            style={{ backgroundColor: '#4f8cff', paddingHorizontal: 28, paddingVertical: 14, borderRadius: 12 }}
            onPress={() => this.setState({ hasError: false, error: null })}
          >
            <Text style={{ color: '#fff', fontSize: 16, fontWeight: '600' }}>Try Again</Text>
          </TouchableOpacity>
        </View>
      );
    }
    return this.props.children;
  }
}

const ResultsReviewItem = React.memo(function ResultsReviewItem({ item, theme, onSelect }) {
  return (
    <TouchableOpacity
      style={[
        styles.testReviewItem,
        { backgroundColor: theme.card },
        item.isCorrect ? styles.testReviewCorrect : styles.testReviewIncorrect
      ]}
      onPress={() => onSelect(item.originalIndex)}
    >
      <View style={[styles.testReviewNumber, { backgroundColor: theme.surfaceAlt }]}>
        <Text style={[styles.testReviewNumberText, { color: theme.subtext }]}>{item.originalIndex + 1}</Text>
      </View>
      <View style={styles.testReviewContent}>
        <Text style={[styles.testReviewQuestionText, { color: theme.textSecondary }]} numberOfLines={2}>
          {item.question.stem?.slice(0, 100) || item.question.leadIn}...
        </Text>
        <View style={styles.testReviewStatus}>
          <Ionicons
            name={item.isCorrect ? 'checkmark-circle' : 'close-circle'}
            size={18}
            color={item.isCorrect ? '#4CAF50' : '#F44336'}
          />
          <Text style={[
            styles.testReviewStatusText,
            { color: item.isCorrect ? '#4CAF50' : '#F44336' }
          ]}>
            {item.isCorrect ? 'Correct' : 'Incorrect'}
          </Text>
        </View>
      </View>
      <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
    </TouchableOpacity>
  );
});

const TopicListItem = React.memo(function TopicListItem({ resource, isRead, theme, onSelect }) {
  return (
    <TouchableOpacity
      style={[
        styles.topicItem,
        { backgroundColor: theme.card },
        isRead && styles.topicItemRead
      ]}
      onPress={() => onSelect(resource)}
    >
      <View style={[styles.topicItemIcon, { backgroundColor: theme.surfaceAlt }]}>
        <Ionicons
          name={resource.type === RESOURCE_TYPES.CUSTOM_NOTE ? 'document-text' :
                resource.type === RESOURCE_TYPES.PUBMED ? 'link' :
                resource.type === RESOURCE_TYPES.VIDEO ? 'play-circle' : 'book'}
          size={22}
          color={isRead ? '#4CAF50' : '#00BCD4'}
        />
      </View>
      <View style={styles.topicItemContent}>
        <Text style={[
          styles.topicItemTitle,
          { color: theme.text },
          isRead && styles.topicItemTitleRead
        ]} numberOfLines={2}>
          {resource.title}
        </Text>
        <View style={styles.topicItemMeta}>
          {resource.readingTime && (
            <Text style={[styles.topicItemMetaText, { color: theme.subtext }]}>{resource.readingTime} min</Text>
          )}
          {resource.priority === 'essential' && (
            <View style={styles.topicEssentialBadge}>
              <Text style={styles.topicEssentialText}>Essential</Text>
            </View>
          )}
          {isRead && (
            <View style={styles.topicCompletedBadge}>
              <Ionicons name="checkmark" size={12} color="#4CAF50" />
              <Text style={styles.topicCompletedText}>Read</Text>
            </View>
          )}
        </View>
      </View>
      <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
    </TouchableOpacity>
  );
});

export default function App() {
  // Debug: log that App component is rendering
  console.log('[App] Rendering main App component');

  try {
    return (
      <ErrorBoundary>
        <AuthProvider>
          <AppContent />
        </AuthProvider>
      </ErrorBoundary>
    );
  } catch (error) {
    console.error('[App] Fatal error:', error);
    const isDark = Appearance.getColorScheme() === 'dark';
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: isDark ? '#1a1a2e' : '#f7f7f8', padding: 20 }}>
        <Text style={{ color: '#f44336', fontSize: 20, fontWeight: 'bold' }}>Fatal Error</Text>
        <Text style={{ color: isDark ? '#fff' : '#1a1a2e', fontSize: 14 }}>{error?.message}</Text>
      </View>
    );
  }
}

// Pure utility - hash a string to a stable integer
function hashStringUtil(value) {
  const str = String(value || '');
  let hash = 0;
  for (let i = 0; i < str.length; i += 1) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash);
}

// Pure utility - lighten a hex color by mixing toward white
function mixColorUtil(hex, mix = 0.4) {
  if (!hex || hex[0] !== '#' || (hex.length !== 7 && hex.length !== 4)) return hex;
  const fullHex = hex.length === 4
    ? `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}`
    : hex;
  const r = parseInt(fullHex.slice(1, 3), 16);
  const g = parseInt(fullHex.slice(3, 5), 16);
  const b = parseInt(fullHex.slice(5, 7), 16);
  const mixValue = Math.max(0, Math.min(1, mix));
  const mixChannel = (c) => Math.round(c + (255 - c) * mixValue);
  return `rgb(${mixChannel(r)}, ${mixChannel(g)}, ${mixChannel(b)})`;
}

// Memoized PetSprite - extracted to avoid re-creating animation loops on parent re-render
const PetSprite = React.memo(({ speciesId, stage, size = 64, moodColor, themeOverride, animated = true, style, interactionKey, petId, eggGroup }) => {
  const species = PET_SPECIES[speciesId] || PET_SPECIES.blobby;
  const accentColor = mixColorUtil(species.colors?.[2] || species.colors?.[1] || '#FFE0B2', 0.35);
  const isEgg = stage === PET_STAGES.EGG;
  const stageScale = isEgg ? 0.9 : stage === PET_STAGES.HATCHLING ? 0.95 : stage === PET_STAGES.JUVENILE ? 1.05 : 1.12;
  const bodySize = size * stageScale;

  const bounce = useRef(new Animated.Value(0)).current;
  const breathe = useRef(new Animated.Value(1)).current;
  const blink = useRef(new Animated.Value(1)).current;
  const sway = useRef(new Animated.Value(0)).current;
  const wiggle = useRef(new Animated.Value(0)).current;
  const pop = useRef(new Animated.Value(0)).current;
  const sparkle = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (!animated) return;
    const bounceLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(bounce, { toValue: 1, duration: 1400, useNativeDriver: true }),
        Animated.timing(bounce, { toValue: 0, duration: 1400, useNativeDriver: true }),
      ])
    );
    const breatheLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(breathe, { toValue: 1.03, duration: 1600, useNativeDriver: true }),
        Animated.timing(breathe, { toValue: 1, duration: 1600, useNativeDriver: true }),
      ])
    );
    const blinkLoop = Animated.loop(
      Animated.sequence([
        Animated.delay(2400),
        Animated.timing(blink, { toValue: 0.2, duration: 120, useNativeDriver: true }),
        Animated.timing(blink, { toValue: 1, duration: 140, useNativeDriver: true }),
      ])
    );
    const swayLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(sway, { toValue: 1, duration: 3200, useNativeDriver: true }),
        Animated.timing(sway, { toValue: 0, duration: 3200, useNativeDriver: true }),
      ])
    );

    bounceLoop.start();
    breatheLoop.start();
    blinkLoop.start();
    swayLoop.start();

    return () => {
      bounceLoop.stop();
      breatheLoop.stop();
      blinkLoop.stop();
      swayLoop.stop();
    };
  }, [animated, bounce, breathe, blink, sway]);

  useEffect(() => {
    if (!animated || !interactionKey) return;
    wiggle.setValue(0);
    pop.setValue(0);
    sparkle.setValue(0);

    Animated.parallel([
      Animated.sequence([
        Animated.timing(pop, { toValue: 1, duration: 140, useNativeDriver: true }),
        Animated.timing(pop, { toValue: 0, duration: 220, useNativeDriver: true }),
      ]),
      Animated.sequence([
        Animated.timing(wiggle, { toValue: 1, duration: 120, useNativeDriver: true }),
        Animated.timing(wiggle, { toValue: -1, duration: 200, useNativeDriver: true }),
        Animated.timing(wiggle, { toValue: 0, duration: 120, useNativeDriver: true }),
      ]),
      Animated.sequence([
        Animated.delay(60),
        Animated.timing(sparkle, { toValue: 1, duration: 220, useNativeDriver: true }),
        Animated.timing(sparkle, { toValue: 0, duration: 260, useNativeDriver: true }),
      ]),
    ]).start();
  }, [animated, interactionKey, wiggle, pop, sparkle]);

  const lift = bounce.interpolate({ inputRange: [0, 1], outputRange: [0, -4] });
  const shadowScale = bounce.interpolate({ inputRange: [0, 1], outputRange: [1, 0.86] });
  const shadowColor = themeOverride?.border || 'rgba(0,0,0,0.15)';
  const swayRotate = sway.interpolate({ inputRange: [0, 1], outputRange: ['-2deg', '2deg'] });
  const wiggleRotate = wiggle.interpolate({ inputRange: [-1, 1], outputRange: ['-6deg', '6deg'] });
  const popScale = pop.interpolate({ inputRange: [0, 1], outputRange: [1, 1.08] });
  const auraOpacity = breathe.interpolate({ inputRange: [1, 1.03], outputRange: [0.18, 0.28] });
  const sparkleLift = sparkle.interpolate({ inputRange: [0, 1], outputRange: [0, -14] });
  const sparkleScale = sparkle.interpolate({ inputRange: [0, 1], outputRange: [0.6, 1.1] });
  const sparkleOpacity = sparkle.interpolate({ inputRange: [0, 1], outputRange: [0, 1] });

  const seedBase = hashStringUtil(petId || speciesId);
  const seed = seedBase + (eggGroup || 0);
  const eggPalettes = [
    ['#f6b8c4', '#ffe1b2', '#fff6c7'],
    ['#cfe7ff', '#f7d6ff', '#fff3c2'],
    ['#c7f0d8', '#ffe5c7', '#d9e6ff'],
    ['#f4c1a5', '#f6f0b7', '#c9f0ff'],
  ];
  const artColors = isEgg ? eggPalettes[seed % eggPalettes.length] : (species.colors || ['#f6b8c4', '#ffe1b2', '#fff6c7']);

  return (
    <View style={[styles.petSpriteWrap, { width: size, height: size }, style]}>
      <Animated.View
        style={[
          styles.petAura,
          {
            width: bodySize * 1.16,
            height: bodySize * 1.16,
            borderRadius: bodySize * 0.6,
            backgroundColor: moodColor || accentColor,
            opacity: auraOpacity,
          },
        ]}
      />
      <Animated.View
        style={[
          styles.petShadow,
          {
            width: bodySize * 0.7,
            backgroundColor: shadowColor,
            transform: [{ scaleX: shadowScale }],
          },
        ]}
      />
      <Animated.View style={{ transform: [{ translateY: lift }, { rotate: swayRotate }, { rotate: wiggleRotate }, { scale: breathe }, { scale: popScale }] }}>
        <PetArt
          size={bodySize}
          stage={stage}
          colors={artColors}
          seed={seed}
        />
        {!isEgg && (
          <>
            <Animated.View
              style={[
                styles.petSparkle,
                {
                  left: bodySize * 0.12,
                  top: bodySize * 0.08,
                  opacity: sparkleOpacity,
                  transform: [{ translateY: sparkleLift }, { scale: sparkleScale }],
                },
              ]}
            />
            <Animated.View
              style={[
                styles.petSparkle,
                {
                  right: bodySize * 0.1,
                  top: bodySize * 0.22,
                  opacity: sparkleOpacity,
                  transform: [{ translateY: sparkleLift }, { scale: sparkleScale }],
                },
              ]}
            />
            <Animated.View
              style={[
                styles.petSparkle,
                {
                  right: bodySize * 0.28,
                  bottom: bodySize * 0.02,
                  opacity: sparkleOpacity,
                  transform: [{ translateY: sparkleLift }, { scale: sparkleScale }],
                },
              ]}
            />
          </>
        )}
      </Animated.View>
    </View>
  );
});

// App Content - the actual app logic (uses auth context)
function AppContent() {
  // Auth state
  const { user, isAuthenticated, loading: authLoading, logout } = useAuth();
  const statsSyncTimeout = useRef(null);
  const statsLastSent = useRef(null);
  const cloudPullInterval = useRef(null);
  const appStateRef = useRef(AppState.currentState);
  const lastCloudPull = useRef(0);
  const lastCloudSyncUser = useRef(null);
  const flashcardCloudSyncDone = useRef(false);
  const cloudSyncInFlight = useRef(false);
  const cloudSyncCooldownUntil = useRef(0);
  const cloudSyncAttempted = useRef(false);
  const localDataRef = useRef({
    cardData: {},
    flashcards: [],
    recentCategories: [],
    readTopics: {},
    reportedIssues: [],
    sessionHistory: [],
    savedSessions: [],
    customTestPresets: [],
    petData: null,
    coinData: null,
    shopData: null,
    roomData: null,
    userSettings: {},
    srsSettings: {},
    gameProgress: createInitialGameProgress(),
  });
  const savedDataRef = useRef(null);
  const systemScheme = useColorScheme();

  const defaultLearningSettings = {
    interleavingDefault: false,
    retrievalPriority: false,
    confidenceRatings: false,
    immediateFeedback: false,
    microTestsEnabled: false,
    microTestSize: 5,
    renewReadingOnMiss: false,
    showPetFeatures: true,
  };

  const defaultSrsSettings = {
    flashcardsAlgo: 'sm2',
    questionsAlgo: 'sm2',
    requestRetention: 0.9,
    enableFuzz: true,
    leechThreshold: 8,
    leechWindowDays: 30,
  };

  const LEECH_THRESHOLD = 8;
  const LEECH_WINDOW_DAYS = 30;

  // App state
  const [screen, setScreen] = useState('home');
  const [currentMode, setCurrentMode] = useState(null);
  const [selectedCategory, setSelectedCategory] = useState(null);

  // Question state
  const [questions, setQuestions] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [showExplanation, setShowExplanation] = useState(false);
  const [shuffledOptions, setShuffledOptions] = useState([]);
  const [questionAnswers, setQuestionAnswers] = useState({}); // Track answers for navigation: { [index]: { answer, shuffledOptions, isCorrect } }

  // Performance tracking
  const [cardData, setCardData] = useState({});
  const [serverStats, setServerStats] = useState(null);
  const [sessionStats, setSessionStats] = useState({ correct: 0, incorrect: 0, total: 0 });
  const [recentCategories, setRecentCategories] = useState([]);
  const [sessionHistory, setSessionHistory] = useState([]);

  // Timer state for timed tests
  const [timeRemaining, setTimeRemaining] = useState(null);
  const [timerActive, setTimerActive] = useState(false);
  const [questionStartedAt, setQuestionStartedAt] = useState(null);

  // Flashcard state
  const [flashcards, setFlashcards] = useState([]);
  const [currentFlashcardIndex, setCurrentFlashcardIndex] = useState(0);
  const [flashcardRevealed, setFlashcardRevealed] = useState(false);
  const [dueFlashcards, setDueFlashcards] = useState([]);
  const [flashcardViewStartedAt, setFlashcardViewStartedAt] = useState(null);
  const [showAddCardModal, setShowAddCardModal] = useState(false);
  const [newCardText, setNewCardText] = useState('');

  // Resources and weakness analysis state
  const [selectedResource, setSelectedResource] = useState(null);
  const [weaknessAnalysis, setWeaknessAnalysis] = useState(null);
  const [suggestedReading, setSuggestedReading] = useState([]);

  // Issue reporting state
  const [showReportModal, setShowReportModal] = useState(false);
  const [reportType, setReportType] = useState('question'); // 'question' or 'flashcard'
  const [reportItemId, setReportItemId] = useState(null);
  const [reportText, setReportText] = useState('');
  const [reportedIssues, setReportedIssues] = useState([]);
  const [reviewLogs, setReviewLogs] = useState([]);

  // Flashcard tools
  const [flashcardToolsTag, setFlashcardToolsTag] = useState('');

  // Flashcard settings modal state
  const [showCardSettingsModal, setShowCardSettingsModal] = useState(false);
  const [cardSettingsTarget, setCardSettingsTarget] = useState(null);
  const [customIntervalInput, setCustomIntervalInput] = useState('');

  // Reading/Study state
  const [readTopics, setReadTopics] = useState({}); // { resourceId: { readAt: timestamp, completed: bool } }

  // Settings state
  const [themeMode, setThemeMode] = useState('system'); // 'system' | 'dark' | 'light'
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);

  // Theme colors based on dark mode
  const isDark = themeMode === 'system' ? systemScheme === 'dark' : themeMode === 'dark';
  const theme = useMemo(() => (isDark ? {
    bg: ['#1a1a2e', '#16213e', '#0f3460'],
    card: 'rgba(37, 37, 71, 0.9)',
    cardSolid: '#252547',
    surface: 'rgba(30, 58, 95, 0.9)',
    surfaceAlt: 'rgba(50, 130, 184, 0.15)',
    text: '#fff',
    textSecondary: '#d4d4d8',
    subtext: '#8a8f9a',
    mutedText: '#999',
    border: 'rgba(255, 255, 255, 0.12)',
    inputBg: '#1a1a2e',
    optionBg: '#1a1a2e',
    optionBorder: '#0f4c75',
    optionLetterBg: '#FFB74D',
    optionLetterText: '#fff',
    progressTrack: '#333',
    badgeBg: '#0f4c75',
    badgeText: '#fff',
    accent: '#5eadd5',
    accentSoft: 'rgba(94, 173, 213, 0.2)',
    progressTitle: '#FFB74D',
    flashcardsTitle: '#FF8A65',
    modalOverlay: 'rgba(0,0,0,0.9)',
    statusBar: 'light',
    // Reading-specific colors
    readingBg: '#1e2438',
    readingText: '#e8e8ec',
    readingH1Border: '#5eadd5',
    readingH2Bg: 'rgba(94, 173, 213, 0.08)',
    readingH2Border: '#5eadd5',
    readingH3Border: 'rgba(255, 255, 255, 0.25)',
    readingQuoteBg: 'rgba(94, 173, 213, 0.06)',
    readingTableHeaderBg: 'rgba(255, 255, 255, 0.05)',
    readingTableAltBg: 'rgba(255, 255, 255, 0.02)',
  } : {
    bg: ['#f7f7f8', '#f7f7f8', '#f7f7f8'],
    card: '#ffffff',
    cardSolid: '#ffffff',
    surface: '#f2f4f7',
    surfaceAlt: '#eef2f7',
    text: '#1a1a2e',
    textSecondary: '#374151',
    subtext: '#5d6470',
    mutedText: '#7b828f',
    border: 'rgba(26, 26, 46, 0.12)',
    inputBg: '#ffffff',
    optionBg: '#ffffff',
    optionBorder: 'rgba(26, 26, 46, 0.15)',
    optionLetterBg: '#FFB74D',
    optionLetterText: '#ffffff',
    progressTrack: 'rgba(26, 26, 46, 0.08)',
    badgeBg: '#dce7f5',
    badgeText: '#1a1a2e',
    accent: '#0077b6',
    accentSoft: 'rgba(0, 119, 182, 0.15)',
    progressTitle: '#FF8A65',
    flashcardsTitle: '#FF7043',
    modalOverlay: 'rgba(0,0,0,0.55)',
    statusBar: 'dark',
    // Reading-specific colors
    readingBg: '#ffffff',
    readingText: '#1f2937',
    readingH1Border: '#0077b6',
    readingH2Bg: 'rgba(0, 119, 182, 0.04)',
    readingH2Border: '#0077b6',
    readingH3Border: 'rgba(0, 0, 0, 0.15)',
    readingQuoteBg: 'rgba(0, 119, 182, 0.03)',
    readingTableHeaderBg: 'rgba(0, 0, 0, 0.03)',
    readingTableAltBg: 'rgba(0, 0, 0, 0.015)',
  }), [isDark]);
  const watermarkLabel = useMemo(() => {
    const display = user?.displayName || user?.email || (user?.uid ? user.uid.slice(-6) : null);
    return display || '';
  }, [user?.displayName, user?.email, user?.uid]);
  const noSelectStyle = useMemo(() => (Platform.OS === 'web' ? { userSelect: 'none' } : null), []);
  const devEmails = new Set(['alexandr.al.harris@gmail.com', 'alexandria.l.harris@gmail.com']);
  const adminEmails = new Set(['alexandria.l.harris@gmail.com']);
  const isDevAccount = devEmails.has((user?.email || '').toLowerCase());
  const [selectedReadingTopic, setSelectedReadingTopic] = useState(null);
  const [readingHeadings, setReadingHeadings] = useState([]);
  const readingScrollRef = useRef(null);
  const readingHeadingPositionsRef = useRef({});
  const [tocExpanded, setTocExpanded] = useState(false);
  const [readingScrollProgress, setReadingScrollProgress] = useState(0);
  const readingContentHeightRef = useRef(0);
  const readingViewportHeightRef = useRef(0);

  // Test Mode State
  const [testMode, setTestMode] = useState('tutor'); // 'tutor' (show answers after each) or 'test' (show at end)
  const [timedMode, setTimedMode] = useState(true); // Whether to use timer (test mode only, tutor is always untimed)
  const [showModeSelection, setShowModeSelection] = useState(false);
  const [pendingModeSession, setPendingModeSession] = useState(null);
  const [quickTestQuestionCount, setQuickTestQuestionCount] = useState(25); // Default 25 questions
  const [testAnswers, setTestAnswers] = useState([]); // Store answers for review at end in test mode
  const [reviewFilter, setReviewFilter] = useState('all'); // 'all', 'correct', 'incorrect'
  const [selectedReviewIndex, setSelectedReviewIndex] = useState(null); // Index of question being reviewed in detail
  const [showCustomTestModal, setShowCustomTestModal] = useState(false);
  const [customTestCategories, setCustomTestCategories] = useState([]);
  const [customTestFocusTags, setCustomTestFocusTags] = useState([]);
  const [customTestCount, setCustomTestCount] = useState(25);
  const [customTestCountText, setCustomTestCountText] = useState('25');
  const [customTestMode, setCustomTestMode] = useState('tutor'); // 'tutor' | 'timed' | 'untimed'
  const [customTestCategoryMode, setCustomTestCategoryMode] = useState('all'); // 'all' | 'choose'
  const [customTestIncludeDueFirst, setCustomTestIncludeDueFirst] = useState(false);
  const [customPresetName, setCustomPresetName] = useState('');

  // Pet system state
  const [petData, setPetData] = useState(null);
  const [coinData, setCoinData] = useState(null);
  const [shopData, setShopData] = useState(null);
  const [roomData, setRoomData] = useState(null);
  const [selectedPetId, setSelectedPetId] = useState(null);
  const [showPetShop, setShowPetShop] = useState(false);
  const [shopCategory, setShopCategory] = useState(ITEM_CATEGORIES.EGGS);
  const [selectedRoom, setSelectedRoom] = useState('room_1');
  const [isDecorating, setIsDecorating] = useState(false);
  const [draggedFurniture, setDraggedFurniture] = useState(null);
  const [roomLayout, setRoomLayout] = useState(null);
  const [showEggHatchModal, setShowEggHatchModal] = useState(false);
  const [hatchingEgg, setHatchingEgg] = useState(null);
  const [newPetName, setNewPetName] = useState('');
  const [showRenameModal, setShowRenameModal] = useState(false);
  const [renameText, setRenameText] = useState('');
  const [showCoinEarnedToast, setShowCoinEarnedToast] = useState(null);
  const [petInteractionTick, setPetInteractionTick] = useState(0);
  const [savedSessions, setSavedSessions] = useState([]);
  const [activeSessionId, setActiveSessionId] = useState(null);
  const [showEndSessionModal, setShowEndSessionModal] = useState(false);
  const [customTestPresets, setCustomTestPresets] = useState([]);
  const [focusFilter, setFocusFilter] = useState('all');
  const [userRole, setUserRole] = useState('user');
  const [assignedExams, setAssignedExams] = useState([]);
  const [showAssignExamModal, setShowAssignExamModal] = useState(false);
  const [assignmentTitle, setAssignmentTitle] = useState('');
  const [assignmentEmail, setAssignmentEmail] = useState('');
  const [assignmentQuestionIdsText, setAssignmentQuestionIdsText] = useState('');
  const [assignmentCategories, setAssignmentCategories] = useState([]);
  const [assignmentFocusTags, setAssignmentFocusTags] = useState([]);
  const [assignmentCountText, setAssignmentCountText] = useState('');
  const [assignmentMode, setAssignmentMode] = useState('tutor');
  const [assignmentDueDateEnabled, setAssignmentDueDateEnabled] = useState(false);
  const [assignmentDueDateText, setAssignmentDueDateText] = useState('');
  const [activeAssignmentId, setActiveAssignmentId] = useState(null);
  const [showTermsModal, setShowTermsModal] = useState(false);
  const [unlockAllFlashcards, setUnlockAllFlashcards] = useState(false);
  const [gameProgress, setGameProgress] = useState(createInitialGameProgress());
  const [lastBattleResult, setLastBattleResult] = useState(null);
  const [practiceContext, setPracticeContext] = useState(null);
  const [showPracticeContextModal, setShowPracticeContextModal] = useState(false);
  const [practiceContextLoaded, setPracticeContextLoaded] = useState(false);
  const practiceContextPrompted = useRef(false);
  const [learningSettings, setLearningSettings] = useState(defaultLearningSettings);
  const [srsSettings, setSrsSettings] = useState(defaultSrsSettings);
  const [pendingConfidenceMeta, setPendingConfidenceMeta] = useState(null);
  const [lastCloudPullAt, setLastCloudPullAt] = useState(null);
  const [lastCloudWriteAt, setLastCloudWriteAt] = useState(null);
  const [cloudChunkMeta, setCloudChunkMeta] = useState(null);
  const [lastCloudError, setLastCloudError] = useState(null);
  const [lastCloudErrorAt, setLastCloudErrorAt] = useState(null);
  const [isBanned, setIsBanned] = useState(false);
  const [banReason, setBanReason] = useState('');
  const [isApproved, setIsApproved] = useState(null);
  const [adminEditVisible, setAdminEditVisible] = useState(false);
  const [adminEditType, setAdminEditType] = useState(null);
  const [adminEditItem, setAdminEditItem] = useState(null);

  // Loading state for async data
  const [isLoading, setIsLoading] = useState(true);
  const [isLocalHydrating, setIsLocalHydrating] = useState(false);
  const [isContentHydrating, setIsContentHydrating] = useState(false);

  // Content from Firestore (questions, resources)
  const [allQuestions, setAllQuestions] = useState([]);
  const [allResources, setAllResources] = useState(ALL_RESOURCES);
  const [contentLoadStatus, setContentLoadStatus] = useState('loading'); // 'loading', 'ready', 'error'
  const roomFloat = useRef(new Animated.Value(0)).current;
  const roomFloatAlt = useRef(new Animated.Value(0)).current;
  const activePracticeContext = practiceContext || 'ent';

  // Load saved data on startup from AsyncStorage
  useEffect(() => {
    let isActive = true;
    const initializeData = async () => {
      try {
      } catch (error) {
        console.error('Error loading saved data:', error);
      } finally {
        if (isActive) {
          setIsLoading(false);
        }
      }
    };

    initializeData();
    const runLocalLoad = () => {
      if (!isActive) return;
      const doLocalLoad = async () => {
        if (!isActive) return;
        setIsLocalHydrating(true);
        try {
          const savedData = await loadAllData();
          savedDataRef.current = savedData;

          setCardData(savedData.cardData || {});
          setRecentCategories(savedData.recentCategories || []);
          setReadTopics(savedData.readTopics || {});
          setReportedIssues(savedData.reportedIssues || []);
          setSessionHistory(savedData.sessionHistory || []);
          setSavedSessions(savedData.savedSessions || []);
          setCustomTestPresets(savedData.customTestPresets || []);
          setGameProgress(ensureGameProgress(savedData.gameProgress));
          setLearningSettings({ ...defaultLearningSettings, ...(savedData.userSettings || {}) });
          setSrsSettings({ ...defaultSrsSettings, ...(savedData.srsSettings || {}) });
          setReviewLogs(Array.isArray(savedData.reviewLogs) ? savedData.reviewLogs : []);

          // Load theme setting
          if (savedData.themeMode) {
            setThemeMode(savedData.themeMode);
          }

          // Load saved flashcards after first render
          const savedCards = Array.isArray(savedData.flashcards) ? savedData.flashcards : [];
          setFlashcards(savedCards);

          // Initialize pet system data
          const loadedPetData = savedData.petData || createInitialPetData();
          const loadedCoinData = savedData.coinData || createInitialCoinData();
          const loadedShopData = savedData.shopData || createInitialShopData();
          const loadedRoomData = savedData.roomData || createInitialRoomData();

          // Apply happiness decay to all pets before setting state
          let petDataToSet = loadedPetData;
          if (loadedPetData.pets?.length > 0) {
            let anyDecayed = false;
            const decayedPets = loadedPetData.pets.map(pet => {
              const decayed = calculateHappinessDecay(pet);
              if (decayed.happiness !== pet.happiness) anyDecayed = true;
              return decayed;
            });
            if (anyDecayed) {
              petDataToSet = { ...loadedPetData, pets: decayedPets };
              savePetData(petDataToSet);
            }
          }

          setPetData(petDataToSet);
          setCoinData(loadedCoinData);
          setShopData(loadedShopData);
          setRoomData(loadedRoomData);

          // Set active pet if exists
          if (loadedPetData.activePetId) {
            setSelectedPetId(loadedPetData.activePetId);
          } else if (loadedPetData.pets?.length > 0) {
            setSelectedPetId(loadedPetData.pets[0].id);
          }

          // Check for daily login bonus
          if (loadedCoinData) {
            const { coinData: updatedCoins, awarded, streakBonus } = checkDailyLogin(loadedCoinData);
            if (awarded > 0) {
              let nextCoins = updatedCoins;
              let nextGameProgress = ensureGameProgress(savedData.gameProgress);
              const loginProgress = applyGameMetricUpdate(nextGameProgress, [
                { metric: 'login_streak', value: updatedCoins.loginStreak || 0 },
              ]);
              nextGameProgress = loginProgress.gameProgress;

              if (loginProgress.rewardCoins > 0) {
                nextCoins = awardCoins(nextCoins, loginProgress.rewardCoins, 'gamification_reward');
              }

              setCoinData(nextCoins);
              await saveCoinData(nextCoins);
              setGameProgress(nextGameProgress);
              await saveGameProgress(nextGameProgress);
              // Show toast for daily login (after a short delay)
              setTimeout(() => {
                setShowCoinEarnedToast({
                  amount: awarded + streakBonus + (loginProgress.rewardCoins || 0),
                  source: loginProgress.rewardCoins
                    ? `Daily Login + Goals (+${loginProgress.rewardCoins})`
                    : (streakBonus > 0 ? `Daily Login (+${streakBonus} streak bonus!)` : 'Daily Login')
                });
                setTimeout(() => setShowCoinEarnedToast(null), 3000);
              }, 1000);
            }
          }

          // Load any pending cloud updates that weren't synced before app closed
          try {
            const savedPendingUpdates = await loadPendingCloudUpdates();
            if (savedPendingUpdates && Object.keys(savedPendingUpdates).length > 0) {
              console.log('[CloudSync] Restored pending updates from storage:', Object.keys(savedPendingUpdates));
              pendingCloudUpdates.current = savedPendingUpdates;
              pendingUpdatesLoaded.current = true;
            }
            const savedPendingReviewLogs = await loadPendingReviewLogs();
            if (Array.isArray(savedPendingReviewLogs) && savedPendingReviewLogs.length > 0) {
              pendingReviewLogs.current = savedPendingReviewLogs;
            }
          } catch (pendingError) {
            console.error('[CloudSync] Error loading pending updates:', pendingError);
          }
        } catch (error) {
          console.error('Error loading saved data:', error);
        } finally {
          if (isActive) {
            setIsLocalHydrating(false);
          }
        }
      };

      // Run immediately on all platforms - InteractionManager can block if animations are running
      doLocalLoad();
    };
    runLocalLoad();
    const runContentLoad = async () => {
      if (!isActive) return;
      console.log('[App] runContentLoad starting, Platform:', Platform.OS);

      const doLoad = async () => {
        if (!isActive) return;
        setIsContentHydrating(true);
        console.log('[App] Loading content from Firestore...');
        setContentLoadStatus('loading');
        let contentPayload = { questions: [], flashcards: [], readings: [] };
        try {
          const content = await initializeContent((progress) => {
            console.log(`[App] Content load: ${progress.status} - ${progress.message}`);
          });
          contentPayload = content || contentPayload;

          if (content.questions && content.questions.length > 0) {
            console.log(`[App] Loaded ${content.questions.length} questions from Firestore`);
            setAllQuestions(content.questions);
          } else {
            console.log('[App] No questions from Firestore, using fallback');
          }
          if (content.readings && content.readings.length > 0) {
            const normalizedReadings = normalizeReadingResources(content.readings);
            console.log(`[App] Loaded ${normalizedReadings.length} readings from Firestore/cache`);
            setAllResources(normalizedReadings);
          } else {
            console.log('[App] No readings from Firestore, using fallback');
          }

          await new Promise(resolve => setTimeout(resolve, 0));

          const savedData = savedDataRef.current || await loadAllData();
          const savedCards = Array.isArray(savedData.flashcards) ? savedData.flashcards : [];
          const remoteFlashcards = normalizeRemoteFlashcards(contentPayload.flashcards || []);
          let mergedFlashcards = remoteFlashcards;

          if (savedCards.length > 0 && remoteFlashcards.length > 0) {
            const savedById = new Map(savedCards.map(card => [card.id, card]));
            const mergedRemote = remoteFlashcards.map(card => {
              const saved = savedById.get(card.id);
              if (!saved) return card;
              return {
                ...card,
                ...saved,
                text: card.text || saved.text,
                front: card.front || saved.front,
                back: card.back || saved.back,
                tags: Array.isArray(card.tags) && card.tags.length ? card.tags : (saved.tags || []),
                category: card.category || saved.category,
                subcategory: card.subcategory || saved.subcategory,
                relatedQuestions: card.relatedQuestions || saved.relatedQuestions,
                sourceQuestionId: card.sourceQuestionId || saved.sourceQuestionId,
              };
            });
            const remoteIds = new Set(remoteFlashcards.map(c => c.id));
            const extraSaved = savedCards.filter(card => !remoteIds.has(card.id));
            mergedFlashcards = [...mergedRemote, ...extraSaved];
          } else if (remoteFlashcards.length === 0) {
            mergedFlashcards = savedCards;
          }

          setFlashcards(mergedFlashcards);
          // Save flashcards asynchronously without blocking
          setTimeout(() => {
            saveFlashcards(mergedFlashcards);
          }, 100);
          setContentLoadStatus('ready');
        } catch (contentError) {
          console.error('[App] Error loading content from Firestore:', contentError);
          setContentLoadStatus('error');
          // Continue with fallback local questions
        } finally {
          if (isActive) {
            setIsContentHydrating(false);
          }
        }
      };

      // Run content load immediately on all platforms
      console.log('[App] Running content load directly');
      doLoad();
    };
    runContentLoad();
    return () => {
      isActive = false;
    };
  }, []);

  // Ensure user profile doc exists for role management/admin lookup
  useEffect(() => {
    if (!user?.uid) return;
    const syncProfile = async () => {
      try {
        const profileRef = doc(db, 'users', user.uid);
        const snap = await getDoc(profileRef);
        const profile = {
          email: user.email || null,
          displayName: user.displayName || null,
          updatedAt: serverTimestamp(),
        };
        if (!snap.exists()) {
          // New user - set approved based on admin status
          const isAdmin = adminEmails.has((user.email || '').toLowerCase());
          profile.approved = isAdmin ? true : false;
          profile.createdAt = serverTimestamp();
        }
        await setDoc(profileRef, profile, { merge: true });
      } catch (err) {
        console.error('[Users] Failed to sync profile:', err);
      }
    };
    syncProfile();
  }, [user?.uid, user?.email, user?.displayName]);

  const loadUserRole = useCallback(async () => {
    if (!user?.uid) {
      setUserRole('user');
      return;
    }
    if (adminEmails.has((user?.email || '').toLowerCase())) {
      setUserRole('admin');
      return;
    }
    try {
      const snap = await getDoc(doc(db, 'userRoles', user.uid));
      if (snap.exists()) {
        setUserRole(snap.data().role || 'user');
      } else {
        setUserRole('user');
      }
    } catch (error) {
      console.error('[Roles] Failed to load role:', error);
      setUserRole('user');
    }
  }, [user?.uid]);

  const openAdminEdit = (type, item) => {
    setAdminEditType(type);
    setAdminEditItem(item);
    setAdminEditVisible(true);
  };

  const handleAdminEditSave = async (contentType, itemId, updatedFields) => {
    const collectionName = contentType === 'question' ? 'questions'
      : contentType === 'flashcard' ? 'flashcards' : 'readings';
    await updateDoc(doc(db, collectionName, itemId), {
      ...updatedFields,
      updatedAt: serverTimestamp(),
    });
    // Update local state
    if (contentType === 'question') {
      setAllQuestions(prev => prev.map(q => q.id === itemId ? { ...q, ...updatedFields } : q));
    } else if (contentType === 'flashcard') {
      setFlashcards(prev => prev.map(fc => fc.id === itemId ? { ...fc, ...updatedFields } : fc));
    } else if (contentType === 'reading') {
      setAllResources(prev => prev.map(r => r.id === itemId ? { ...r, ...updatedFields } : r));
    }
    setAdminEditVisible(false);
  };

  const exportReports = async () => {
    try {
      const snap = await getDocs(collection(db, 'reports'));
      const rows = [];
      snap.forEach(d => {
        const r = { cloudId: d.id, ...d.data() };
        if (r.createdAt?.toDate) r.createdAt = r.createdAt.toDate().toISOString();
        else if (r.createdAt) r.createdAt = String(r.createdAt);
        if (r.updatedAt?.toDate) r.updatedAt = r.updatedAt.toDate().toISOString();
        else if (r.updatedAt) r.updatedAt = String(r.updatedAt);
        rows.push(r);
      });
      const headers = ['cloudId', 'type', 'itemId', 'itemTitle', 'status', 'description', 'userEmail', 'createdAt', 'updatedAt', 'adminNotes'];
      const csvRows = [headers.join(',')];
      rows.forEach(r => {
        csvRows.push(headers.map(h => {
          const val = r[h] ?? '';
          return '"' + String(val).replace(/"/g, '""') + '"';
        }).join(','));
      });
      const csv = csvRows.join('\n');
      if (Platform.OS === 'web') {
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `reports_${new Date().toISOString().slice(0, 10)}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        showAlert('Export Complete', `Downloaded ${rows.length} reports as CSV.`);
      } else {
        showAlert('Export Complete', `${rows.length} reports exported.\n\nCSV preview (first 500 chars):\n${csv.substring(0, 500)}`);
      }
    } catch (error) {
      console.error('[ExportReports]', error);
      showAlert('Export Failed', error.message);
    }
  };

  const loadAssignedExams = useCallback(async () => {
    if (!user?.email) {
      setAssignedExams([]);
      return;
    }
    if (userRole !== 'admin') {
      setAssignedExams([]);
      return;
    }
    try {
      const q = query(
        collection(db, 'assignments'),
        where('assignedToEmail', '==', user.email)
      );
      const snapshot = await getDocs(q);
      const assignments = [];
      snapshot.forEach(docSnap => {
        assignments.push({ id: docSnap.id, ...docSnap.data() });
      });
      assignments.sort((a, b) => {
        const at = a.createdAt?.toMillis ? a.createdAt.toMillis() : (a.createdAt || 0);
        const bt = b.createdAt?.toMillis ? b.createdAt.toMillis() : (b.createdAt || 0);
        return bt - at;
      });
      setAssignedExams(assignments);
    } catch (error) {
      console.error('[Assignments] Failed to load assignments:', error);
      setAssignedExams([]);
    }
  }, [user?.email, userRole]);

  const formatSyncDate = (value) => {
    if (!value) return '';
    try {
      return new Date(value).toLocaleString();
    } catch (e) {
      return '';
    }
  };

  const recordCloudError = (message) => {
    const text = typeof message === 'string' ? message : (message?.message || 'Unknown error');
    setLastCloudError(text);
    setLastCloudErrorAt(Date.now());
  };

  const pendingCloudUpdates = useRef({});
  const cloudWriteTimer = useRef(null);
  const cloudWriteInFlight = useRef(false);
  const pendingUpdatesLoaded = useRef(false);
  const pendingReviewLogs = useRef([]);
  const reviewLogWriteTimer = useRef(null);
  const reviewLogInFlight = useRef(false);
  const CLOUD_WRITE_DEBOUNCE = 10000; // Reduced from 30s to 10s for better sync
  const CLOUD_WRITE_RETRY = 60000;

  const flushCloudUpdates = useCallback(async ({ force = false } = {}) => {
    if (!user?.uid || isLoading) return;
    if (cloudWriteInFlight.current) return;
    const updates = pendingCloudUpdates.current;
    if (!force && (!updates || Object.keys(updates).length === 0)) return;

    if (cloudWriteTimer.current) {
      clearTimeout(cloudWriteTimer.current);
      cloudWriteTimer.current = null;
    }

    cloudWriteInFlight.current = true;
    pendingCloudUpdates.current = {};
    try {
      const result = await updateUserDataInCloud(user.uid, updates);
      if (result?.success) {
        setLastCloudWriteAt(Date.now());
        // Clear persisted pending updates on success
        clearPendingCloudUpdates().catch(() => null);
      } else {
        throw new Error(result?.error || 'Cloud update failed');
      }
    } catch (error) {
      // Restore failed updates and persist them
      pendingCloudUpdates.current = { ...updates, ...pendingCloudUpdates.current };
      savePendingCloudUpdates(pendingCloudUpdates.current).catch(() => null);
      recordCloudError(error);
      cloudWriteTimer.current = setTimeout(() => {
        flushCloudUpdates({ force: true }).catch(() => null);
      }, CLOUD_WRITE_RETRY);
    } finally {
      cloudWriteInFlight.current = false;
    }
  }, [user?.uid, isLoading, recordCloudError]);

  const queueCloudUpdate = useCallback((updates, options = {}) => {
    if (!user?.uid || isLoading) return;
    if (!updates || Object.keys(updates).length === 0) return;
    pendingCloudUpdates.current = {
      ...pendingCloudUpdates.current,
      ...updates,
    };
    // Persist pending updates to storage for reliability
    savePendingCloudUpdates(pendingCloudUpdates.current).catch(() => null);

    const heavyKeys = ['cardData', 'sessionHistory', 'savedSessions'];
    const hasHeavyPayload = heavyKeys.some((key) => Object.prototype.hasOwnProperty.call(updates, key));
    const shouldDefer =
      options.deferHeavy &&
      hasHeavyPayload &&
      appStateRef.current === 'active' &&
      Platform.OS !== 'web';
    if (!shouldDefer) {
      if (cloudWriteTimer.current) {
        clearTimeout(cloudWriteTimer.current);
      }
      cloudWriteTimer.current = setTimeout(() => {
        flushCloudUpdates().catch(() => null);
      }, CLOUD_WRITE_DEBOUNCE);
    }
  }, [user?.uid, isLoading, flushCloudUpdates]);

  const appendLocalReviewLog = useCallback((log) => {
    if (!log) return;
    setReviewLogs(prev => {
      const next = [log, ...(Array.isArray(prev) ? prev : [])].slice(0, 200);
      saveReviewLogs(next);
      return next;
    });
  }, []);

  const flushReviewLogs = useCallback(async ({ force = false } = {}) => {
    if (!user?.uid || isLoading) return;
    if (reviewLogInFlight.current) return;
    const logs = pendingReviewLogs.current;
    if (!force && (!logs || logs.length === 0)) return;

    if (reviewLogWriteTimer.current) {
      clearTimeout(reviewLogWriteTimer.current);
      reviewLogWriteTimer.current = null;
    }

    reviewLogInFlight.current = true;
    pendingReviewLogs.current = [];
    try {
      const result = await appendReviewLogsBatch(user.uid, logs);
      if (result?.success) {
        clearPendingReviewLogs().catch(() => null);
      } else {
        throw new Error(result?.error || 'Review log append failed');
      }
    } catch (error) {
      pendingReviewLogs.current = [...logs, ...pendingReviewLogs.current];
      savePendingReviewLogs(pendingReviewLogs.current).catch(() => null);
      reviewLogWriteTimer.current = setTimeout(() => {
        flushReviewLogs({ force: true }).catch(() => null);
      }, 60000);
    } finally {
      reviewLogInFlight.current = false;
    }
  }, [user?.uid, isLoading]);

  const queueReviewLog = useCallback((log) => {
    if (!log) return;
    appendLocalReviewLog(log);
    pendingReviewLogs.current = [...pendingReviewLogs.current, log];
    savePendingReviewLogs(pendingReviewLogs.current).catch(() => null);
    if (!user?.uid || isLoading) return;
    if (reviewLogWriteTimer.current) {
      clearTimeout(reviewLogWriteTimer.current);
    }
    reviewLogWriteTimer.current = setTimeout(() => {
      flushReviewLogs().catch(() => null);
    }, 5000);
  }, [appendLocalReviewLog, user?.uid, isLoading, flushReviewLogs]);

  const localSyncStats = useMemo(() => ({
    cardData: Object.keys(cardData || {}).length,
    flashcards: (flashcards || []).length,
    sessionHistory: (sessionHistory || []).length,
    savedSessions: (savedSessions || []).length,
  }), [cardData, flashcards, sessionHistory, savedSessions]);

  const persistLocalSnapshot = async (data) => {
    await saveCardData(data.cardData || {});
    await saveFlashcards(data.flashcards || []);
    await saveRecentCategories(data.recentCategories || []);
    await saveReadTopics(data.readTopics || {});
    await saveSessionHistory(data.sessionHistory || []);
    await saveReportedIssues(data.reportedIssues || []);
    await saveSavedSessions(data.savedSessions || []);
    await saveCustomTestPresets(data.customTestPresets || []);
    await savePetData(data.petData || null);
    await saveCoinData(data.coinData || null);
    await saveShopData(data.shopData || null);
    await saveRoomData(data.roomData || null);
    await saveGameProgress(data.gameProgress || null);
    await saveThemeMode(data.themeMode || 'system');
    if (typeof storage?.saveUserSettings === 'function') {
      storage.saveUserSettings(data.userSettings || {});
    }
    if (typeof storage?.saveSrsSettings === 'function') {
      storage.saveSrsSettings(data.srsSettings || {});
    }
  };

  const handleReplaceLocalWithCloud = async () => {
    if (!user?.uid) {
      showAlert('Restore', 'Sign in to restore from cloud.');
      return;
    }
    const result = await loadUserDataFromCloud(user.uid);
    if (!result.success || !result.data) {
      showAlert('Restore Failed', result.message || 'No cloud data available.');
      return;
    }
    applyCloudData(result.data);
    if (result.data.themeMode) {
      setThemeMode(result.data.themeMode);
    }
    const cloudFlashcards = await fetchUserFlashcards(user.uid);
    const normalizedCloudFlashcards = normalizeRemoteFlashcards(cloudFlashcards || []);
    setFlashcards(normalizedCloudFlashcards);
    saveFlashcards(normalizedCloudFlashcards);
    result.data.flashcards = normalizedCloudFlashcards;
    await persistLocalSnapshot(result.data);
    setLastCloudPullAt(Date.now());
    setCloudChunkMeta(result.data.chunkMeta || null);
    showAlert('Restored', 'Cloud data replaced local data on this device.');
  };

  useEffect(() => {
    loadUserRole();
  }, [loadUserRole]);

  useEffect(() => {
    loadAssignedExams();
  }, [loadAssignedExams]);

  useEffect(() => {
    localDataRef.current = {
      cardData,
      flashcards,
      recentCategories,
      readTopics,
      reportedIssues,
      sessionHistory,
      savedSessions,
      customTestPresets,
      petData,
      coinData,
      shopData,
      roomData,
      gameProgress,
      userSettings: learningSettings,
      srsSettings,
    };
  }, [
    cardData,
    flashcards,
    recentCategories,
    readTopics,
    reportedIssues,
    sessionHistory,
    savedSessions,
    customTestPresets,
    petData,
    coinData,
    shopData,
    roomData,
    gameProgress,
    learningSettings,
    srsSettings,
  ]);

  useEffect(() => {
    if (!coinData && !petData) return;
    const updates = [];
    if (coinData) {
      updates.push({ metric: 'coins_earned', value: coinData.totalEarned || 0 });
      updates.push({ metric: 'login_streak', value: coinData.loginStreak || 0 });
    }
    if (petData) {
      updates.push({ metric: 'pets_hatched', value: petData.totalPetsHatched || 0 });
    }
    applyGameMetrics(updates, { baseCoinData: coinData, source: 'gamification_reward' });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [coinData?.totalEarned, coinData?.loginStreak, petData?.totalPetsHatched]);

  const applyCloudData = useCallback((data) => {
    if (!data) return;
    if (!PROGRESS_SERVER_FIRST && data.cardData) setCardData(data.cardData);
    if (data.recentCategories) setRecentCategories(data.recentCategories);
    if (data.readTopics) setReadTopics(data.readTopics);
    if (data.reportedIssues) setReportedIssues(data.reportedIssues);
    if (data.sessionHistory) setSessionHistory(data.sessionHistory);
    if (data.savedSessions) setSavedSessions(data.savedSessions);
    if (data.customTestPresets) setCustomTestPresets(data.customTestPresets);
    if (data.petData) setPetData(data.petData);
    if (data.coinData) setCoinData(data.coinData);
    if (data.shopData) setShopData(data.shopData);
    if (data.roomData) setRoomData(data.roomData);
    if (data.gameProgress) setGameProgress(ensureGameProgress(data.gameProgress));
    if (data.userSettings) {
      setLearningSettings(prev => ({ ...prev, ...data.userSettings }));
    }
    if (typeof data.unlockAllFlashcards !== 'undefined') {
      setUnlockAllFlashcards(!!data.unlockAllFlashcards);
    }

  }, [user?.uid]);

  const pullCloudData = useCallback(async ({ force = false } = {}) => {
    if (!user?.uid || isLoading) return { success: false, message: 'Not signed in' };
    try {
      const cloudResult = await loadUserDataFromCloud(user.uid);
      if (!cloudResult.success || !cloudResult.data) {
        return { success: false, message: 'No cloud data available' };
      }

      const updatedAt = cloudResult.data.updatedAt?.toMillis
        ? cloudResult.data.updatedAt.toMillis()
        : (cloudResult.data.updatedAt ? new Date(cloudResult.data.updatedAt).getTime() : 0);
      if (!force && updatedAt && updatedAt <= lastCloudPull.current) {
        return { success: true, skipped: true };
      }

      const localData = localDataRef.current;
      const mergedData = mergeData(localData, cloudResult.data);
      applyCloudData(mergedData);
      lastCloudPull.current = updatedAt || Date.now();
      setLastCloudPullAt(updatedAt || Date.now());
      if (cloudResult.data?.chunkMeta) {
        setCloudChunkMeta(cloudResult.data.chunkMeta);
      }
      return { success: true };
    } catch (error) {
      console.error('[CloudSync] Pull failed:', error);
      recordCloudError(error);
      return { success: false, message: error.message };
    }
  }, [user?.uid, isLoading, applyCloudData]);

  // Cloud sync effect - sync data when user logs in
  useEffect(() => {
    cloudSyncAttempted.current = false;
    flashcardCloudSyncDone.current = false;
  }, [user?.uid]);

  useEffect(() => {
    if (user?.uid) return;
    setIsBanned(false);
    setBanReason('');
    setIsApproved(null);
  }, [user?.uid]);

  useEffect(() => {
    const syncCloudData = async () => {
      if (!user?.uid || isLoading) return;
      if (lastCloudSyncUser.current === user.uid) return;
      if (cloudSyncInFlight.current) return;
      if (Date.now() < cloudSyncCooldownUntil.current) return;
      if (cloudSyncAttempted.current) return;

      console.log('[CloudSync] User authenticated, syncing data...');

      try {
        cloudSyncInFlight.current = true;
        cloudSyncAttempted.current = true;
        // Get current local data
        const localData = localDataRef.current;

        // Initialize cloud data (merges local with cloud)
        const result = await initializeCloudData(user.uid, localData);

        if (result.success && result.data) {
          console.log('[CloudSync] Data merged successfully');
          applyCloudData(result.data);
          lastCloudSyncUser.current = user.uid;
          setLastCloudWriteAt(Date.now());
          if (result.data?.chunkMeta) {
            setCloudChunkMeta(result.data.chunkMeta);
          }
        }

        try {
          const profileSnap = await getDoc(doc(db, 'users', user.uid));
          if (profileSnap.exists()) {
            const profileData = profileSnap.data();
            setUnlockAllFlashcards(!!profileData.unlockAllFlashcards);
            const profileContext = profileData.practiceContext;
            if (profileContext && SPECIALTIES[profileContext]) {
              setPracticeContext(profileContext);
            }
            if (profileData.banned) {
              setIsBanned(true);
              setBanReason(profileData.bannedReason || '');
            } else {
              setIsBanned(false);
              setBanReason('');
            }
            // Approval check: admin auto-approved, undefined = grandfathered, false = pending
            if (adminEmails.has((user.email || '').toLowerCase())) {
              setIsApproved(true);
            } else if (profileData.approved === false) {
              setIsApproved(false);
            } else {
              // approved === true or approved is undefined (grandfathered)
              setIsApproved(true);
            }
          }
        } catch (profileError) {
          console.error('[Users] Failed to load profile:', profileError);
        } finally {
          setPracticeContextLoaded(true);
        }

      } catch (error) {
        console.error('[CloudSync] Error syncing data:', error);
        recordCloudError(error);
        cloudSyncCooldownUntil.current = Date.now() + 60 * 1000;
        setPracticeContextLoaded(true);
      } finally {
        cloudSyncInFlight.current = false;
      }
    };

    syncCloudData();
  }, [user?.uid, isLoading, applyCloudData]);

  useEffect(() => {
    if (!user?.uid || !practiceContextLoaded) return;
    if (practiceContext || practiceContextPrompted.current) return;
    setShowPracticeContextModal(true);
    practiceContextPrompted.current = true;
  }, [user?.uid, practiceContextLoaded, practiceContext]);

  // Load SRS settings from cloud (users/{uid}/settings/srs)
  useEffect(() => {
    if (!user?.uid || isLoading) return;
    let isActive = true;

    const loadSrs = async () => {
      const result = await loadUserSrsSettings(user.uid);
      if (!isActive) return;
      if (result.success && result.data) {
        setSrsSettings(prev => ({ ...defaultSrsSettings, ...prev, ...result.data }));
      }
    };

    loadSrs();
    return () => {
      isActive = false;
    };
  }, [user?.uid, isLoading]);

  useEffect(() => {
    if (!user?.uid || isLocalHydrating) return;
    if (flashcardCloudSyncDone.current) return;
    let isActive = true;

    const syncFlashcards = async () => {
      try {
        const cloudCardsRaw = await fetchUserFlashcards(user.uid);
        if (!isActive) return;
        let cloudCards = normalizeRemoteFlashcards(cloudCardsRaw || []);
        if (cloudCards.length === 0) {
          const legacy = await loadUserDataFromCloud(user.uid);
          if (legacy?.data?.flashcards?.length) {
            cloudCards = normalizeRemoteFlashcards(legacy.data.flashcards);
            await upsertUserFlashcardsBatch(user.uid, cloudCards);
          }
        }
        const merged = mergeFlashcardsByUpdatedAt(flashcards, cloudCards);
        setFlashcards(merged);
        saveFlashcards(merged);

        const cloudIds = new Set(cloudCards.map(c => c.id));
        const toBackfill = merged.filter(c => c?.id && !cloudIds.has(c.id));
        if (toBackfill.length > 0) {
          const payload = toBackfill.map(card => card.updatedAt ? card : touchFlashcard(card));
          await upsertUserFlashcardsBatch(user.uid, payload);
        }
        flashcardCloudSyncDone.current = true;
      } catch (err) {
        console.error('[CloudSync] Failed to sync flashcards:', err);
      }
    };

    syncFlashcards();
    return () => {
      isActive = false;
    };
  }, [user?.uid, isLocalHydrating]);

  useEffect(() => {
    if (!user?.uid || isLoading) return;
    const runPull = () => {
      pullCloudData().catch(() => null);
    };
    runPull();
    if (cloudPullInterval.current) clearInterval(cloudPullInterval.current);
    cloudPullInterval.current = setInterval(runPull, 15 * 60 * 1000);

    const subscription = AppState.addEventListener('change', (state) => {
      if (state === 'active') {
        appStateRef.current = 'active';
        runPull();
        // Apply happiness decay when returning to foreground
        setPetData(prev => {
          if (!prev?.pets?.length) return prev;
          let anyDecayed = false;
          const decayedPets = prev.pets.map(pet => {
            const decayed = calculateHappinessDecay(pet);
            if (decayed.happiness !== pet.happiness) anyDecayed = true;
            return decayed;
          });
          if (anyDecayed) {
            const updated = { ...prev, pets: decayedPets };
            savePetData(updated);
            return updated;
          }
          return prev;
        });
        if (!cloudPullInterval.current) {
          cloudPullInterval.current = setInterval(runPull, 15 * 60 * 1000);
        }
      } else if (state === 'background' || state === 'inactive') {
        appStateRef.current = state;
        flushCloudUpdates({ force: true }).catch(() => null);
        flushReviewLogs({ force: true }).catch(() => null);
      } else {
        appStateRef.current = state;
        if (cloudPullInterval.current) {
          clearInterval(cloudPullInterval.current);
          cloudPullInterval.current = null;
        }
      }
    });

    return () => {
      if (cloudPullInterval.current) {
        clearInterval(cloudPullInterval.current);
        cloudPullInterval.current = null;
      }
      subscription.remove();
    };
  }, [user?.uid, isLoading, pullCloudData, flushCloudUpdates]);

  // Server-first progress: pull user stats and per-item progress from Firestore
  useEffect(() => {
    if (!PROGRESS_SERVER_FIRST || !user?.uid || isLoading) return;
    let isActive = true;

    const loadServerProgress = async () => {
      try {
        await flushPendingProgressEvents(user.uid);
        const [stats, questionStats, flashcardStats] = await Promise.all([
          fetchUserStats(user.uid),
          fetchQuestionStats(user.uid),
          fetchFlashcardStats(user.uid),
        ]);
        if (!isActive) return;
        if (stats) setServerStats(stats);
        if (questionStats && Object.keys(questionStats).length > 0) {
          setCardData((prev) => mergeQuestionStats(prev, questionStats));
        }
        if (flashcardStats && Object.keys(flashcardStats).length > 0) {
          setFlashcards((prev) => applyFlashcardStats(prev, flashcardStats));
        }
      } catch (err) {
        console.error('[ProgressSync] Failed to load server progress:', err);
      }
    };

    if (contentLoadStatus === 'ready') {
      loadServerProgress();
    }

    return () => {
      isActive = false;
    };
  }, [user?.uid, isLoading, contentLoadStatus]);

  // Active-session cloud sync disabled to prevent UI lag; syncs now flush on background/inactive + manual.

  // Sync pet system data to cloud when it changes
  useEffect(() => {
    // Skip initial render and when not authenticated
    if (!user?.uid || isLoading) return;

    // Debounce cloud sync to avoid too many updates
    const timeoutId = setTimeout(() => {
      const updates = {};
      if (petData) updates.petData = petData;
      if (coinData) updates.coinData = coinData;
      if (shopData) updates.shopData = shopData;
      if (roomData) updates.roomData = roomData;

      if (Object.keys(updates).length > 0) {
        queueCloudUpdate(updates);
      }
    }, 60000); // 60 second debounce

    return () => clearTimeout(timeoutId);
  }, [petData, coinData, shopData, roomData, user?.uid, isLoading, queueCloudUpdate]);

  // Flush any pending cloud updates when user becomes authenticated
  useEffect(() => {
    if (!user?.uid || isLoading) return;
    // If there are pending updates from storage, flush them now
    const pending = pendingCloudUpdates.current;
    if (pending && Object.keys(pending).length > 0 && pendingUpdatesLoaded.current) {
      console.log('[CloudSync] Flushing pending updates after auth:', Object.keys(pending));
      // Small delay to let other sync complete first
      const timeoutId = setTimeout(() => {
        flushCloudUpdates({ force: true }).catch(() => null);
      }, 5000);
      return () => clearTimeout(timeoutId);
    }
  }, [user?.uid, isLoading, flushCloudUpdates]);

  useEffect(() => {
    if (!user?.uid || isLoading) return;
    if (pendingReviewLogs.current.length > 0) {
      flushReviewLogs({ force: true }).catch(() => null);
    }
  }, [user?.uid, isLoading, flushReviewLogs]);

  // Save theme setting when it changes
  useEffect(() => {
    if (!isLoading) {
      saveThemeMode(themeMode);
    }
  }, [themeMode, isLoading]);

  useEffect(() => {
    const floatLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(roomFloat, { toValue: 1, duration: 5200, useNativeDriver: true }),
        Animated.timing(roomFloat, { toValue: 0, duration: 5200, useNativeDriver: true }),
      ])
    );
    const floatAltLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(roomFloatAlt, { toValue: 1, duration: 6800, useNativeDriver: true }),
        Animated.timing(roomFloatAlt, { toValue: 0, duration: 6800, useNativeDriver: true }),
      ])
    );

    floatLoop.start();
    floatAltLoop.start();

    return () => {
      floatLoop.stop();
      floatAltLoop.stop();
    };
  }, [roomFloat, roomFloatAlt]);

  useEffect(() => {
    if (isLoading) return;
    if (typeof storage?.saveUserSettings === 'function') {
      storage.saveUserSettings(learningSettings);
    } else {
      console.warn('[Storage] saveUserSettings is unavailable, skipping local save');
    }
    if (user?.uid) {
      queueCloudUpdate({ userSettings: learningSettings });
    }
  }, [learningSettings, user?.uid, isLoading, queueCloudUpdate]);

  useEffect(() => {
    if (isLoading) return;
    if (typeof storage?.saveSrsSettings === 'function') {
      storage.saveSrsSettings(srsSettings);
    } else {
      console.warn('[Storage] saveSrsSettings is unavailable, skipping local save');
    }
    if (user?.uid) {
      saveUserSrsSettings(user.uid, srsSettings).catch((error) => {
        console.error('[CloudSync] Failed to save SRS settings:', error);
      });
    }
  }, [srsSettings, user?.uid, isLoading]);

  // Timer logic
  useEffect(() => {
    let interval = null;
    if (timerActive && timeRemaining > 0) {
      interval = setInterval(() => {
        setTimeRemaining(time => time - 1);
      }, 1000);
    } else if (timeRemaining === 0 && timerActive) {
      setTimerActive(false);
      showAlert('Time\'s Up!', 'Your timed session has ended.');
      finishSession();
    }
    return () => clearInterval(interval);
  }, [timerActive, timeRemaining]);

  useEffect(() => {
    if (screen === 'question' && questions.length > 0) {
      setQuestionStartedAt(Date.now());
    }
  }, [screen, currentIndex, questions.length]);

  useEffect(() => {
    if (screen === 'flashcard' && dueFlashcards.length > 0) {
      setFlashcardViewStartedAt(Date.now());
    }
  }, [screen, currentFlashcardIndex, dueFlashcards.length]);

  // Apply happiness decay when viewing pet screen
  useEffect(() => {
    if (screen !== 'pet' || !petData?.pets?.length) return;
    let anyDecayed = false;
    const decayedPets = petData.pets.map(pet => {
      const decayed = calculateHappinessDecay(pet);
      if (decayed.happiness !== pet.happiness) anyDecayed = true;
      return decayed;
    });
    if (anyDecayed) {
      const updated = { ...petData, pets: decayedPets };
      setPetData(updated);
      savePetData(updated);
    }
  }, [screen]);

  // Save data to AsyncStorage and cloud (individual saves for efficiency)
  const saveData = async (newCardData, newRecentCategories, newFlashcards, newReadTopics) => {
    try {
      const cloudUpdates = {};

      // Only save what's been updated
      if (newCardData !== undefined) {
        await saveCardData(newCardData);
        if (!PROGRESS_SERVER_FIRST) {
          cloudUpdates.cardData = newCardData;
        }
      }
      if (newRecentCategories !== undefined) {
        await saveRecentCategories(newRecentCategories);
        cloudUpdates.recentCategories = newRecentCategories;
      }
      if (newFlashcards !== undefined) {
        await saveFlashcards(newFlashcards);
      }
      if (newReadTopics !== undefined) {
        await saveReadTopics(newReadTopics);
        cloudUpdates.readTopics = newReadTopics;
      }

      // Sync to cloud if user is authenticated
      if (user?.uid && Object.keys(cloudUpdates).length > 0) {
        queueCloudUpdate(cloudUpdates, { deferHeavy: true });
      }
    } catch (error) {
      console.error('Error saving data:', error);
    }
  };

  // Sync pet system data to cloud
  const syncPetDataToCloud = (updates) => {
    if (user?.uid) {
      updateUserDataInCloud(user.uid, updates).catch(err => {
        console.error('[CloudSync] Error syncing pet data:', err);
        recordCloudError(err);
      });
    }
  };

  const applyGameMetrics = (updates, { baseCoinData = null, source = 'gamification_reward' } = {}) => {
    if (!Array.isArray(updates) || updates.length === 0) {
      return { rewardCoins: 0, coinData: baseCoinData || coinData || null };
    }

    const currentProgress = ensureGameProgress(gameProgress);
    if (currentProgress.gamificationEnabled === false) {
      return { rewardCoins: 0, coinData: baseCoinData || coinData || null };
    }

    const result = applyGameMetricUpdate(currentProgress, updates);
    const nextProgress = result.gameProgress;
    setGameProgress(nextProgress);
    saveGameProgress(nextProgress);

    let nextCoins = baseCoinData || coinData || null;
    if (result.rewardCoins > 0 && nextCoins) {
      nextCoins = awardCoins(nextCoins, result.rewardCoins, source);
      setCoinData(nextCoins);
      saveCoinData(nextCoins);
    }

    const cloudUpdate = { gameProgress: nextProgress };
    if (result.rewardCoins > 0 && nextCoins) {
      cloudUpdate.coinData = nextCoins;
    }
    queueCloudUpdate(cloudUpdate, { deferHeavy: true });

    return { rewardCoins: result.rewardCoins, coinData: nextCoins };
  };

  // Mark a reading topic as read/completed
  const markTopicAsRead = (resourceOrId, completed = true) => {
    const resourceId = typeof resourceOrId === 'string' ? resourceOrId : resourceOrId?.id;
    if (!resourceId) return;

    const wasCompleted = readTopics[resourceId]?.completed;
    const updatedReadTopics = {
      ...readTopics,
      [resourceId]: {
        readAt: Date.now(),
        completed
      }
    };
    setReadTopics(updatedReadTopics);
    saveData(cardData, recentCategories, flashcards, updatedReadTopics);

    if (PROGRESS_SERVER_FIRST && user?.uid && completed) {
      recordReadingCompletion(user.uid, {
        readingId: resourceId,
        completedAt: Date.now(),
      });
    }

    if (!wasCompleted && completed) {
      const gameResult = applyGameMetrics([
        { metric: 'readings_completed', delta: 1 },
      ]);
      const isAssigned = suggestedReading.some(r => r.id === resourceId);
      if (isAssigned && coinData && petData) {
        const updatedCoins = awardCoins(gameResult.coinData || coinData, COIN_RATES.READING_ASSIGNED, 'reading_assigned');
        setCoinData(updatedCoins);
        saveCoinData(updatedCoins);

        if (selectedPetId && petData.pets?.length > 0) {
          const petIndex = petData.pets.findIndex(p => p.id === selectedPetId);
          if (petIndex !== -1) {
            const previousSpeciesId = petData.pets[petIndex].speciesId;
            const { pet: updatedPet, evolved, newStage } = addExperience(petData.pets[petIndex], XP_RATES.READING_ASSIGNED);
            const happyPet = updateHappiness(updatedPet, HAPPINESS_BOOSTS.READING_ASSIGNED);
            const updatedPets = [...petData.pets];
            updatedPets[petIndex] = happyPet;
            const updatedPetData = { ...petData, pets: updatedPets };
            setPetData(updatedPetData);
            savePetData(updatedPetData);
            if (evolved) {
              setTimeout(() => handlePetEvolution(happyPet, newStage, previousSpeciesId), 500);
            }
          }
        }
      }
    }
  };

  // Get questions linked to a resource
  const getQuestionsForResource = (resource) => {
    if (!resource.questionIds || resource.questionIds.length === 0) return [];
    return activeQuestions.filter(q => resource.questionIds.includes(q.id));
  };

  // Get flashcards linked to a resource (by tags)
  const getFlashcardsForResource = (resource) => {
    // First check explicit linkedFlashcardTags, then fall back to tags
    const tagsToMatch = resource.linkedFlashcardTags || resource.tags || [];
    if (tagsToMatch.length === 0) return [];

    // Also include cards linked to the same questionIds
    const questionLinkedCards = activeFlashcards.filter(card =>
      card.sourceQuestionId && resource.questionIds?.includes(card.sourceQuestionId)
    );

    // Get cards by matching tags
    const tagLinkedCards = activeFlashcards.filter(card =>
      card.tags?.some(tag =>
        tagsToMatch.some(rTag =>
          tag.toLowerCase() === rTag.toLowerCase()
        )
      )
    );

    // Combine and dedupe
    const allCards = [...questionLinkedCards, ...tagLinkedCards];
    return [...new Map(allCards.map(c => [c.id, c])).values()];
  };

  // Start a practice session from a reading topic
  const startPracticeFromReading = (resource) => {
    const linkedQuestions = getQuestionsForResource(resource);
    if (linkedQuestions.length === 0) {
      showAlert('No Questions', 'No practice questions are linked to this topic yet.');
      return;
    }
    setQuestions(shuffleArray(linkedQuestions));
    setCurrentMode({ id: 'reading_practice', name: `Practice: ${resource.title}`, color: '#9C27B0' });
    setCurrentIndex(0);
    setSelectedAnswer(null);
    setShowExplanation(false);
    setPendingConfidenceMeta(null);
    setSessionStats({ correct: 0, incorrect: 0, total: 0 });
    setShuffledOptions(prepareQuestion(linkedQuestions[0]));
    setScreen('question');
  };

  // Shuffle array using Fisher-Yates
  const shuffleArray = (array) => {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  };

  // Prepare question with shuffled options
  const prepareQuestion = (question) => {
    const explanations = question.optionExplanations || [];
    const optionsWithIndex = question.options.map((opt, idx) => ({
      text: opt,
      originalIndex: idx,
      isCorrect: idx === question.correctIndex,
      explanation: explanations[idx] || '',
    }));
    return shuffleArray(optionsWithIndex);
  };

  // Start a practice session
  // Start session with mode selection for exam/test modes
  const startSessionWithModeSelection = (mode) => {
    setPendingModeSession(mode);
    setShowModeSelection(true);
  };

  const createSessionId = () => `session_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

  const applyFocusFilter = (questionsList) => {
    if (focusFilter === 'all') return questionsList;
    return questionsList.filter(q => {
      const data = cardData[q.id] || {};
      const attempts = data.attempts || 0;
      const incorrect = data.incorrect || 0;
      const correct = data.correct || 0;
      const accuracy = attempts > 0 ? correct / attempts : 0;

      if (focusFilter === 'unseen') return attempts === 0;
      if (focusFilter === 'missed') return attempts > 0 && incorrect > 0;
      if (focusFilter === 'danger') {
        return data.markedDifficult || data.needsReview || (attempts > 0 && accuracy < 0.6);
      }
    return true;
  });
  };

  const normalizeTag = (value) => String(value || '')
    .toLowerCase()
    .trim()
    .replace(/[_\s]+/g, '-')
    .replace(/[^a-z0-9-]/g, '');
  const normalizeTagList = (list) => (Array.isArray(list) ? list : [])
    .map(normalizeTag)
    .filter(Boolean);

  const activeCategoryMap = useMemo(() => (
    getSpecialty(activePracticeContext).categories
  ), [activePracticeContext]);

  const getCategoryLabelForQuestion = (question) => {
    if (!question) return '';
    if (activePracticeContext !== 'peds_endo') {
      return activeCategoryMap[question.category]?.name || question.category;
    }
    const tags = normalizeTagList(question.tags);
    const match = Object.entries(activeCategoryMap).find(([, category]) => {
      const categoryTags = normalizeTagList(category.tags);
      return categoryTags.some(tag => tags.includes(tag));
    });
    return match ? match[1].name : question.category;
  };

  const isQuestionInCategory = (question, categoryKey) => {
    if (!question || !categoryKey) return false;
    if (activePracticeContext !== 'peds_endo') {
      return question.category === categoryKey;
    }
    const categoryTags = normalizeTagList(activeCategoryMap[categoryKey]?.tags);
    if (categoryTags.length === 0) return false;
    const tags = normalizeTagList(question.tags);
    return categoryTags.some(tag => tags.includes(tag));
  };

  const isQuestionInAnyCategory = (question, categorySet) => {
    if (!categorySet || categorySet.size === 0) return true;
    for (const categoryKey of categorySet) {
      if (isQuestionInCategory(question, categoryKey)) return true;
    }
    return false;
  };

  const isPedsEndoQuestion = (q) => {
    const tags = Array.isArray(q.tags) ? q.tags : [];
    const hasPedsEndoTag = tags.some(tag => String(tag || '').toLowerCase().trim() === 'peds_endo');
    const isPedsEndoCategory = normalizeTag(q.category) === 'pediatrics'
      && normalizeTag(q.subcategory) === 'endocrinology';
    return hasPedsEndoTag || isPedsEndoCategory;
  };

  const isPedsEndoReading = (reading) => {
    const tags = Array.isArray(reading?.tags) ? reading.tags : [];
    return tags.some(tag => String(tag || '').toLowerCase().trim() === 'peds_endo');
  };

  const pedsEndoQuestionIds = useMemo(() => (
    new Set(allQuestions.filter(isPedsEndoQuestion).map(q => q.id))
  ), [allQuestions]);

  const isPedsEndoFlashcard = (card) => {
    const tags = Array.isArray(card?.tags) ? card.tags : [];
    if (tags.some(tag => String(tag || '').toLowerCase().trim() === 'peds_endo')) return true;
    if (card?.sourceQuestionId && pedsEndoQuestionIds.has(card.sourceQuestionId)) return true;
    if (Array.isArray(card?.relatedQuestions) && card.relatedQuestions.some(id => pedsEndoQuestionIds.has(id))) return true;
    return false;
  };

  const activeQuestions = useMemo(() => {
    const specialty = getSpecialty(activePracticeContext);
    return allQuestions.filter(specialty.questionFilter);
  }, [allQuestions, activePracticeContext]);

  const activeQuestionIdSet = useMemo(() => (
    new Set(activeQuestions.map(q => q.id))
  ), [activeQuestions]);

  const activeFlashcards = useMemo(() => (
    activePracticeContext === 'peds_endo'
      ? flashcards.filter(isPedsEndoFlashcard)
      : flashcards.filter(card => !isPedsEndoFlashcard(card))
  ), [flashcards, activePracticeContext, pedsEndoQuestionIds]);

  const applyPracticeContext = (questionsList) => {
    const specialty = getSpecialty(activePracticeContext);
    return questionsList.filter(specialty.questionFilter);
  };

  const savePracticeContext = async (nextContext, { suppressAlert = false } = {}) => {
    setPracticeContext(nextContext);
    setShowPracticeContextModal(false);
    practiceContextPrompted.current = true;
    if (!user?.uid) return;
    try {
      await setDoc(doc(db, 'users', user.uid), {
        practiceContext: nextContext,
        updatedAt: serverTimestamp(),
      }, { merge: true });
    } catch (error) {
      console.error('[Users] Failed to save practice context:', error);
      if (!suppressAlert) {
        showAlert('Update Failed', 'Unable to update your practice context right now.');
      }
    }
  };

  const getRecentQuestionIds = (limit = 20) => {
    const ids = [];
    for (const session of sessionHistory || []) {
      const list = Array.isArray(session.questionIds) ? session.questionIds : [];
      for (const id of list) {
        if (!id) continue;
        ids.push(id);
        if (ids.length >= limit) return ids;
      }
    }
    return ids;
  };

  const getQuestionDueAt = (questionId, now = Date.now()) => {
    const data = cardData[questionId] || {};
    if (data.leech?.active) return null;
    const srs = data.srs || {};
    if (srs.algo === 'fsrs' && srs.fsrs?.due) return srs.fsrs.due;
    if (srs.algo === 'sm2' && srs.sm2?.nextReview) return srs.sm2.nextReview;
    if (srs.fsrs?.due) return srs.fsrs.due;
    if (srs.sm2?.nextReview) return srs.sm2.nextReview;
    if (data.nextReview) return data.nextReview;
    if (data.attempts > 0 && (data.needsReview || data.markedDifficult || data.incorrect > 0)) {
      return now;
    }
    return null;
  };

  const getDueQuestionIds = (questionsList, cap = 40) => {
    const now = Date.now();
    const dueIds = [];
    for (const q of questionsList) {
      const dueAt = getQuestionDueAt(q.id, now);
      if (dueAt !== null && dueAt <= now) {
        dueIds.push(q.id);
        if (dueIds.length >= cap) break;
      }
    }
    return dueIds;
  };

  const getQuestionSrsSettings = () => ({
    flashcardsAlgo: srsSettings.questionsAlgo || 'sm2',
    requestRetention: srsSettings.requestRetention,
    enableFuzz: srsSettings.enableFuzz,
  });

  const ratingToQuality = (rating) => {
    switch (rating) {
      case 'again':
        return 0;
      case 'hard':
        return 2;
      case 'good':
        return 3;
      case 'easy':
        return 5;
      default:
        return 3;
    }
  };

  const computeQuestionRating = (isCorrect, confidenceLevel = null) => {
    if (!isCorrect) return 'again';
    if (confidenceLevel === 'low') return 'hard';
    if (confidenceLevel === 'high') return 'easy';
    return 'good';
  };

  const pickSnapshot = (snapshot) => {
    const cleaned = {};
    Object.entries(snapshot || {}).forEach(([key, value]) => {
      if (value !== undefined && value !== null) cleaned[key] = value;
    });
    return cleaned;
  };

  const getFlashcardSnapshot = (card, algo) => {
    if (!card) return {};
    if (algo === 'fsrs' && card?.srs?.fsrs) {
      return pickSnapshot({
        due: card.srs.fsrs.due,
        stability: card.srs.fsrs.stability,
        difficulty: card.srs.fsrs.difficulty,
        interval: card.srs.fsrs.scheduled_days,
      });
    }
    return pickSnapshot({
      due: card.nextReview,
      interval: card.interval,
      easeFactor: card.easeFactor,
    });
  };

  const getQuestionSnapshot = (data, algo) => {
    if (!data) return {};
    if (algo === 'fsrs' && data?.srs?.fsrs) {
      return pickSnapshot({
        due: data.srs.fsrs.due,
        stability: data.srs.fsrs.stability,
        difficulty: data.srs.fsrs.difficulty,
        interval: data.srs.fsrs.scheduled_days,
      });
    }
    if (data?.srs?.sm2) {
      return pickSnapshot({
        due: data.srs.sm2.nextReview,
        interval: data.srs.sm2.interval,
        easeFactor: data.srs.sm2.easeFactor,
      });
    }
    return pickSnapshot({
      due: data.nextReview,
      interval: data.interval,
      easeFactor: data.easeFactor,
    });
  };

  const getQuestionDueAtFromData = (data, now = Date.now()) => {
    if (!data || data.leech?.active) return null;
    if (data?.srs?.fsrs?.due) return data.srs.fsrs.due;
    if (data?.srs?.sm2?.nextReview) return data.srs.sm2.nextReview;
    if (data?.nextReview) return data.nextReview;
    if (data.attempts > 0 && (data.needsReview || data.markedDifficult || data.incorrect > 0)) {
      return now;
    }
    return null;
  };

  const updateQuestionLeech = (existing, isCorrect) => {
    if (isCorrect) return existing;
    const now = Date.now();
    const history = Array.isArray(existing.leech?.history) ? existing.leech.history.slice() : [];
    history.push(now);
    const windowDays = srsSettings.leechWindowDays || LEECH_WINDOW_DAYS;
    const cutoff = now - (windowDays * 24 * 60 * 60 * 1000);
    const recent = history.filter(ts => ts >= cutoff);
    const threshold = srsSettings.leechThreshold || LEECH_THRESHOLD;
    const isLeech = recent.length >= threshold;
    return {
      ...existing,
      leech: {
        ...(existing.leech || {}),
        active: isLeech,
        lapses: recent.length,
        history: recent,
        lastLapseAt: now,
        threshold,
      },
      needsReview: true,
    };
  };

  const applyQuestionSrs = (existingData, rating) => {
    const now = Date.now();
    const algo = srsSettings.questionsAlgo || 'sm2';
    if (algo === 'fsrs') {
      const fsrsResult = getSrsEngine(getQuestionSrsSettings()).applyRating(existingData, rating, now);
      const fsrsState = fsrsResult?.srs?.fsrs || existingData?.srs?.fsrs;
      return {
        srs: {
          ...(existingData.srs || {}),
          algo: 'fsrs',
          fsrs: fsrsState,
        },
      };
    }

    const sm2Base = existingData?.srs?.sm2 || {};
    const sm2Result = calculateNextReview(sm2Base, ratingToQuality(rating));
    return {
      srs: {
        ...(existingData.srs || {}),
        algo: 'sm2',
        sm2: sm2Result,
      },
    };
  };

  const applyInterleavingDefault = (questionsList, count = null) => {
    if (!learningSettings.interleavingDefault || questionsList.length === 0) return questionsList;
    const targetCount = count ?? questionsList.length;
    return getInterleavedQuestions(questionsList, targetCount, recentCategories);
  };

  const applyRetrievalPriority = (questionsList) => {
    if (!learningSettings.retrievalPriority || questionsList.length === 0) return questionsList;
    const dueIds = getDueQuestionIds(questionsList, 40);
    return getInterleavedQuestionsWithDue(
      questionsList,
      questionsList.length,
      recentCategories,
      dueIds,
      { dueCap: 40, recentQuestionIds: getRecentQuestionIds(20) }
    );
  };

  const selectQuestionsWithDue = (questionsList, count, options = {}) => {
    if (questionsList.length === 0) return [];
    const includeDue = options.includeDue ?? true;
    const dueCap = options.dueCap ?? 40;
    const recentQuestionIds = options.recentQuestionIds || getRecentQuestionIds(20);
    const filtered = filterOutRecentQuestions(questionsList, recentQuestionIds);
    const baseList = filtered.length >= Math.min(count, questionsList.length) ? filtered : questionsList;
    const base = baseList.filter(q => !cardData[q.id]?.leech?.active);

    if (!includeDue) {
      return getInterleavedQuestions(base, count, recentCategories);
    }

    const dueIds = getDueQuestionIds(base, dueCap);
    return getInterleavedQuestionsWithDue(base, count, recentCategories, dueIds, {
      dueCap,
      recentQuestionIds,
    });
  };

  const getImmediateFeedbackText = (question) => {
    if (question.keyPoint) return question.keyPoint;
    if (question.explanation) {
      const sentence = question.explanation.split(/(?<=\.)\s/)[0];
      return sentence || null;
    }
    return null;
  };

  const persistSavedSessions = async (nextSessions) => {
    setSavedSessions(nextSessions);
    await saveSavedSessions(nextSessions);
    if (user?.uid) {
      updateUserDataInCloud(user.uid, { savedSessions: nextSessions }).catch(err => {
        console.error('[CloudSync] Error syncing saved sessions:', err);
      });
    }
  };

  const persistCustomTestPresets = async (nextPresets) => {
    setCustomTestPresets(nextPresets);
    await saveCustomTestPresets(nextPresets);
    if (user?.uid) {
      updateUserDataInCloud(user.uid, { customTestPresets: nextPresets }).catch(err => {
        console.error('[CloudSync] Error syncing custom test presets:', err);
      });
    }
  };

  const buildSessionSnapshot = () => {
    const questionIds = questions.map(q => q.id);
    return {
      id: activeSessionId || createSessionId(),
      modeId: currentMode?.id || 'custom',
      modeName: currentMode?.name || 'Practice Session',
      color: currentMode?.color || '#FF9800',
      questionIds,
      currentIndex,
      questionAnswers,
      testAnswers,
      sessionStats,
      testMode,
      timedMode,
      timeRemaining,
      timerActive,
      selectedCategory,
      focusFilter,
      categories: [...customTestCategories],
      focusTags: [...customTestFocusTags],
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
  };

  const saveCurrentSession = async () => {
    if (questions.length === 0) return;
    const snapshot = buildSessionSnapshot();
    const existing = savedSessions.findIndex(s => s.id === snapshot.id);
    const merged = existing >= 0
      ? savedSessions.map(s => s.id === snapshot.id ? { ...s, ...snapshot, createdAt: s.createdAt } : s)
      : [snapshot, ...savedSessions];
    const trimmed = merged.slice(0, MAX_SAVED_SESSIONS);
    await persistSavedSessions(trimmed);
    setActiveSessionId(snapshot.id);
  };

  const removeSavedSession = async (sessionId) => {
    if (!sessionId) return;
    const next = savedSessions.filter(s => s.id !== sessionId);
    await persistSavedSessions(next);
  };

  const exitSessionToHome = () => {
    setTimerActive(false);
    setTimeRemaining(null);
    setSelectedAnswer(null);
    setShowExplanation(false);
    setScreen('home');
  };

  const handleEndSessionSave = async () => {
    saveCurrentQuestionState();
    await saveCurrentSession();
    setShowEndSessionModal(false);
    exitSessionToHome();
  };

  const handleEndSessionDiscard = async () => {
    if (activeSessionId) {
      await removeSavedSession(activeSessionId);
      setActiveSessionId(null);
    }
    setShowEndSessionModal(false);
    exitSessionToHome();
  };

  const resumeSavedSession = (session) => {
    const nextQuestions = session.questionIds
      .map(id => allQuestions.find(q => q.id === id))
      .filter(Boolean);
    if (nextQuestions.length === 0) {
      showAlert('Session Not Found', 'Questions in this session are no longer available.');
      return;
    }

    setQuestions(nextQuestions);
    setCurrentMode({ id: session.modeId, name: session.modeName, color: session.color || '#FF9800' });
    setSelectedCategory(session.selectedCategory || null);
    setCurrentIndex(Math.min(session.currentIndex || 0, nextQuestions.length - 1));
    setQuestionAnswers(session.questionAnswers || {});
    setTestAnswers(session.testAnswers || []);
    setSessionStats(session.sessionStats || { correct: 0, incorrect: 0, total: 0 });
    setTestMode(session.testMode || 'tutor');
    setTimedMode(session.timedMode ?? true);
    setTimeRemaining(session.timeRemaining ?? null);
    setTimerActive(session.timerActive ?? false);
    setActiveSessionId(session.id);
    setFocusFilter(session.focusFilter || 'all');
    setCustomTestCategories(session.categories || []);
    setCustomTestFocusTags(session.focusTags || []);

    const resumeIndex = Math.min(session.currentIndex || 0, nextQuestions.length - 1);
    const savedAnswer = session.questionAnswers?.[resumeIndex];
    setSelectedAnswer(savedAnswer?.answer ?? null);
    setShowExplanation(!!savedAnswer?.answer);
    setShuffledOptions(savedAnswer?.shuffledOptions || prepareQuestion(nextQuestions[resumeIndex]));
    setPendingConfidenceMeta(null);

    setScreen('question');
  };

  // Actually start the session after mode is selected
  const confirmModeAndStart = (selectedTestMode, useTimed = false) => {
    setTestMode(selectedTestMode);
    setTimedMode(useTimed);
    setShowModeSelection(false);
    setTestAnswers([]); // Reset test answers
    setReviewFilter('all'); // Reset review filter
    setSelectedReviewIndex(null); // Reset selected review question
    startSession(pendingModeSession, null, selectedTestMode, useTimed);
    setPendingModeSession(null);
  };

  const startSession = (mode, category = null, explicitTestMode = null, explicitTimed = null) => {
    let selectedQuestions = [];
    const activeTestMode = explicitTestMode || testMode;
    const activeTimed = explicitTimed !== null ? explicitTimed : timedMode;
    const baseQuestions = applyFocusFilter(activeQuestions);

    // For exam and timed modes, require mode selection if not already selected
    if ((mode.id === 'exam_sim' || mode.id === 'timed') && explicitTestMode === null && !showModeSelection) {
      startSessionWithModeSelection(mode);
      return;
    }

    // Reset timer state
    setTimeRemaining(null);
    setTimerActive(false);

    switch (mode.id) {
      case 'exam_sim':
        // Full exam simulation with board distribution
        selectedQuestions = shuffleArray(baseQuestions).slice(0, Math.min(200, baseQuestions.length));
        // Only set timer if in test mode AND timed is selected
        if (activeTestMode === 'test' && activeTimed) {
          const examQuestionCount = selectedQuestions.length;
          setTimeRemaining(examQuestionCount * 72); // ~1.2 min per question
          setTimerActive(true);
        }
        break;

      case 'spaced':
        // Get cards due for review using spaced repetition
        selectedQuestions = selectQuestionsWithDue(baseQuestions, 20, { includeDue: true, dueCap: 40 });
        break;

      case 'interleaved':
        // Mix questions from different categories
        selectedQuestions = selectQuestionsWithDue(baseQuestions, 20, { includeDue: true, dueCap: 40 });
        break;

      case 'weak':
        // Focus on questions marked as difficult or needing review
        const markedQuestions = baseQuestions.filter(q => {
          const data = cardData[q.id];
          return data && (data.markedDifficult || data.needsReview);
        });

        // Also include questions with low accuracy (< 50%)
        const lowAccuracyQuestions = baseQuestions.filter(q => {
          const data = cardData[q.id];
          if (!data || !data.attempts || data.attempts < 2) return false;
          const accuracy = data.correct / data.attempts;
          return accuracy < 0.5 && !markedQuestions.includes(q);
        });

        selectedQuestions = shuffleArray([...markedQuestions, ...lowAccuracyQuestions]).slice(0, 20);

        if (selectedQuestions.length < 5) {
          showAlert(
            'Not Enough Data',
            'Mark questions as "Difficult" or "Needs Review" while practicing to build your custom review set.\n\nQuestions you answer incorrectly are automatically added.',
            [{ text: 'OK' }]
          );
          return;
        }
        break;

      case 'category':
        // Filter by selected category
        selectedQuestions = selectQuestionsWithDue(
          baseQuestions.filter(q => isQuestionInCategory(q, category)),
          20,
          { includeDue: learningSettings.retrievalPriority, dueCap: 40 }
        );
        break;

      // peds_endo mode removed - specialty selection now handled via PracticeContextModal in Settings

      case 'timed':
        // Random selection for quick test with user-selected count
        const timedCount = Math.min(quickTestQuestionCount, baseQuestions.length);
        selectedQuestions = shuffleArray(baseQuestions).slice(0, timedCount);
        // Only set timer if in test mode AND timed is selected
        if (activeTestMode === 'test' && activeTimed) {
          setTimeRemaining(timedCount * 90); // ~1.5 min per question
          setTimerActive(true);
        }
        break;

      case 'flashcards':
        // Start flashcard session
        startFlashcardSession();
        return;

      case 'weakness':
        // Show weakness analysis
        showWeaknessAnalysis();
        return;
    }

    if (learningSettings.interleavingDefault && !['interleaved', 'spaced', 'weak', 'flashcards', 'weakness', 'exam_sim', 'timed'].includes(mode.id)) {
      selectedQuestions = applyInterleavingDefault(selectedQuestions, selectedQuestions.length);
    }
    if (learningSettings.retrievalPriority && !['spaced', 'exam_sim', 'timed'].includes(mode.id)) {
      selectedQuestions = applyRetrievalPriority(selectedQuestions);
    }

    if (selectedQuestions.length === 0) {
      showAlert('No Questions', 'No questions match the selected focus filter.');
      return;
    }

    setQuestions(selectedQuestions);
    setCurrentMode(mode);
    setSelectedCategory(category);
    setCurrentIndex(0);
    setSelectedAnswer(null);
    setShowExplanation(false);
    setPendingConfidenceMeta(null);
    setSessionStats({ correct: 0, incorrect: 0, total: 0 });
    setQuestionAnswers({}); // Reset answers for navigation
    setShuffledOptions(prepareQuestion(selectedQuestions[0]));
    setActiveSessionId(createSessionId());
    setCustomTestCategories([]);
    setCustomTestFocusTags([]);
    setScreen('question');
  };

  const startCustomTagSession = () => {
    if (customTestCategoryMode === 'choose' && customTestCategories.length === 0 && customTestFocusTags.length === 0) {
      showAlert('Select Focus', 'Choose at least one category or focus area.');
      return;
    }

    const normalizedFocus = normalizeTagList(customTestFocusTags);
    const activeCategories = customTestCategoryMode === 'choose' ? customTestCategories : [];
    const categorySet = new Set(activeCategories);
    const matches = activeQuestions.filter(q => {
      const categoryOk = isQuestionInAnyCategory(q, categorySet);
      if (!categoryOk) return false;
      if (normalizedFocus.length === 0) return true;
      const tags = normalizeTagList(q.tags);
      const sub = normalizeTag(q.subcategory);
      const qType = normalizeTag(q.questionType);
      const category = normalizeTag(q.category);
      const categoryName = normalizeTag(getCategoryLabelForQuestion(q));
      return normalizedFocus.some(tag =>
        tags.includes(tag) ||
        sub.includes(tag) ||
        qType.includes(tag) ||
        category.includes(tag) ||
        categoryName.includes(tag)
      );
    });
    const filteredMatches = applyFocusFilter(matches);

    if (filteredMatches.length === 0) {
      showAlert('No Matches', 'No questions match those tags yet.');
      return;
    }

    const count = Math.min(customTestCount, filteredMatches.length);
    let selectedQuestions = customTestIncludeDueFirst
      ? selectQuestionsWithDue(filteredMatches, count, { includeDue: true, dueCap: 40 })
      : shuffleArray(filteredMatches).slice(0, count);
    if (learningSettings.interleavingDefault && !customTestIncludeDueFirst) {
      selectedQuestions = applyInterleavingDefault(selectedQuestions, selectedQuestions.length);
    }
    if (learningSettings.retrievalPriority) {
      selectedQuestions = applyRetrievalPriority(selectedQuestions);
    }
    const mode = {
      id: 'custom_tag',
      name: 'Custom Tag Test',
      color: '#FFB74D',
    };

    const explicitTestMode = customTestMode === 'tutor' ? 'tutor' : 'test';
    const explicitTimed = customTestMode === 'timed';
    setTestMode(explicitTestMode);
    setTimedMode(explicitTimed);
    setTimeRemaining(explicitTestMode === 'test' && explicitTimed ? count * 60 : null);
    setTimerActive(explicitTestMode === 'test' && explicitTimed);

    setQuestions(selectedQuestions);
    setCurrentMode(mode);
    setSelectedCategory(null);
    setCurrentIndex(0);
    setSelectedAnswer(null);
    setShowExplanation(false);
    setPendingConfidenceMeta(null);
    setSessionStats({ correct: 0, incorrect: 0, total: 0 });
    setQuestionAnswers({});
    setShuffledOptions(prepareQuestion(selectedQuestions[0]));
    setActiveSessionId(createSessionId());
    setScreen('question');
    setShowCustomTestModal(false);
  };

  const handleCreateAssignment = async () => {
    const email = assignmentEmail.trim().toLowerCase();
    if (!email || !email.includes('@')) {
      showAlert('Assignee Email', 'Enter a valid email address.');
      return;
    }
    const questionIds = parseAssignmentQuestionIds(assignmentQuestionIdsText);
    const count = assignmentCountText ? parseInt(assignmentCountText, 10) : null;
    const dueDate = assignmentDueDateEnabled && assignmentDueDateText
      ? new Date(assignmentDueDateText)
      : null;
    if (assignmentDueDateEnabled && assignmentDueDateText && isNaN(dueDate?.getTime())) {
      showAlert('Due Date', 'Use YYYY-MM-DD format for the due date.');
      return;
    }
    if (questionIds.length === 0 && assignmentCategories.length === 0 && assignmentFocusTags.length === 0) {
      showAlert('Assignment Details', 'Add question IDs or choose at least one topic.');
      return;
    }

    try {
      await addDoc(collection(db, 'assignments'), {
        title: assignmentTitle.trim() || 'Assigned Exam',
        assignedBy: user?.uid || null,
        assignedByEmail: user?.email || null,
        assignedToEmail: email,
        questionIds,
        categories: assignmentCategories,
        focusTags: assignmentFocusTags,
        count: Number.isFinite(count) ? count : null,
        mode: assignmentMode,
        dueDate: dueDate ? dueDate.getTime() : null,
        status: 'assigned',
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });

      setAssignmentTitle('');
      setAssignmentEmail('');
      setAssignmentQuestionIdsText('');
      setAssignmentCategories([]);
      setAssignmentFocusTags([]);
      setAssignmentCountText('');
      setAssignmentMode('tutor');
      setAssignmentDueDateEnabled(false);
      setAssignmentDueDateText('');
      setShowAssignExamModal(false);
      showAlert('Assignment Sent', 'The exam has been assigned.');
    } catch (error) {
      console.error('[Assignments] Failed to create assignment:', error);
      showAlert('Assignment Error', 'Unable to create assignment.');
    }
  };

  const startAssignedExam = async (assignment) => {
    if (!assignment) return;
    const resolved = resolveAssignmentQuestions(assignment);
    if (resolved.length === 0) {
      showAlert('No Questions', 'No questions found for this assignment.');
      return;
    }

    const mode = {
      id: 'assignment',
      name: assignment.title || 'Assigned Exam',
      color: '#7C4DFF',
    };
    const explicitTestMode = assignment.mode === 'tutor' ? 'tutor' : 'test';
    const explicitTimed = assignment.mode === 'timed';

    setTestMode(explicitTestMode);
    setTimedMode(explicitTimed);
    setTimeRemaining(explicitTestMode === 'test' && explicitTimed ? resolved.length * 60 : null);
    setTimerActive(explicitTestMode === 'test' && explicitTimed);
    setQuestions(resolved);
    setCurrentMode(mode);
    setSelectedCategory(null);
    setCurrentIndex(0);
    setSelectedAnswer(null);
    setShowExplanation(false);
    setSessionStats({ correct: 0, incorrect: 0, total: 0 });
    setQuestionAnswers({});
    setShuffledOptions(prepareQuestion(resolved[0]));
    setActiveSessionId(createSessionId());
    setActiveAssignmentId(assignment.id);

    try {
      if (assignment.status !== 'completed') {
        await updateDoc(doc(db, 'assignments', assignment.id), {
          status: 'started',
          startedAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          totalQuestions: resolved.length,
        });
      }
      loadAssignedExams();
    } catch (error) {
      console.error('[Assignments] Failed to mark started:', error);
    }

    setScreen('question');
  };

  const saveCustomPreset = async () => {
    const name = customPresetName.trim();
    if (!name) {
      showAlert('Preset Name', 'Enter a name for this preset.');
      return;
    }
    if (customTestCategoryMode === 'choose' && customTestCategories.length === 0 && customTestFocusTags.length === 0) {
      showAlert('Select Focus', 'Choose at least one category or focus area before saving.');
      return;
    }
    const preset = {
      id: `preset_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,
      name,
      categories: [...customTestCategories],
      focusTags: [...customTestFocusTags],
      count: customTestCount,
      mode: customTestMode,
      focusFilter,
      includeDueFirst: customTestIncludeDueFirst,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    const next = [preset, ...customTestPresets].slice(0, 20);
    await persistCustomTestPresets(next);
    setCustomPresetName('');
  };

  const applyCustomPreset = (preset) => {
    const nextCategories = preset.categories || [];
    setCustomTestCategories(nextCategories);
    setCustomTestFocusTags(preset.focusTags || []);
    setCustomTestCount(preset.count || 25);
    setCustomTestMode(preset.mode || 'tutor');
    setFocusFilter(preset.focusFilter || 'all');
    setCustomTestIncludeDueFirst(!!preset.includeDueFirst);
    setCustomTestCategoryMode(nextCategories.length > 0 ? 'choose' : 'all');
  };

  const deleteCustomPreset = async (presetId) => {
    const next = customTestPresets.filter(p => p.id !== presetId);
    await persistCustomTestPresets(next);
  };

  // Start flashcard session
  const startFlashcardSession = () => {
    const due = getDueFlashcards(activeFlashcards, 30, srsSettings);
    if (due.length === 0) {
      showAlert(
        'No Cards Due',
        'You have no flashcards due for review. Cards are created automatically when you miss questions, or you can add them manually.',
        [{ text: 'OK' }]
      );
      return;
    }
    setDueFlashcards(due);
    setCurrentFlashcardIndex(0);
    setFlashcardRevealed(false);
    setCurrentMode(PRACTICE_MODES.FLASHCARDS);
    setScreen('flashcard');
  };

  // Show weakness analysis
  const showWeaknessAnalysis = () => {
    const analysis = analyzeWeaknesses(cardData, activeQuestions);
    setWeaknessAnalysis(analysis);

    // Get suggested reading based on missed questions
    const reading = getSuggestedReadingForMissedQuestions(activeResources, analysis.missedQuestionIds);
    setSuggestedReading(reading);

    setScreen('weakness');
  };

  // View a resource - track where we came from for back navigation
  const viewResource = useCallback((resource, fromScreen = null) => {
    setSelectedResource(resource);
    // Store the current screen so we can go back to it
    if (fromScreen) {
      setSelectedReadingTopic(fromScreen);
    } else if (screen === 'topics') {
      setSelectedReadingTopic('topics');
    } else if (screen === 'results') {
      setSelectedReadingTopic('results');
    } else if (screen === 'home') {
      setSelectedReadingTopic('home');
    }
    setScreen('resource');
  }, [screen]);

  // Report an issue with a question or flashcard
  const openReportModal = (type, itemId) => {
    setReportType(type);
    setReportItemId(itemId);
    setReportText('');
    setShowReportModal(true);
  };

  const submitReport = async () => {
    if (!reportText.trim()) {
      showAlert('Missing Info', 'Please describe the issue.');
      return;
    }

    // Get the item content for context
    let itemContent = '';
    let itemTitle = '';
    if (reportType === 'question' && reportItemId) {
      const question = allQuestions.find(q => q.id === reportItemId);
      if (question) {
        itemTitle = question.stem || question.leadIn || '';
        const optionLines = (question.options || [])
          .map((opt, idx) => {
            const text = typeof opt === 'string' ? opt : (opt?.text || '');
            return `${String.fromCharCode(65 + idx)}) ${text}`;
          })
          .join('\n');
        const correct = typeof question.correctIndex === 'number'
          ? String.fromCharCode(65 + question.correctIndex)
          : 'Unknown';
        itemContent = [
          `Stem: ${question.stem || ''}`,
          `Lead-in: ${question.leadIn || ''}`,
          `Options:\n${optionLines}`,
          `Correct: ${correct}`,
          `Category: ${question.category || ''}`,
          `Subcategory: ${question.subcategory || ''}`,
        ].join('\n');
      }
    } else if (reportType === 'flashcard' && reportItemId) {
      const card = flashcards.find(f => f.id === reportItemId);
      if (card) {
        itemTitle = card.text || '';
        const tags = (card.tags || []).join(', ');
        itemContent = [
          `Text: ${card.text || ''}`,
          `Extra: ${card.extraInfo || ''}`,
          `Tags: ${tags}`,
        ].join('\n');
      }
    }

    const newReport = {
      id: `report_${Date.now()}`,
      type: reportType,
      itemId: reportItemId,
      itemTitle: itemTitle,
      description: reportText,
      itemContent: itemContent,
      timestamp: Date.now(),
      status: 'pending',
    };

    let updatedReports = [...reportedIssues, newReport];
    setReportedIssues(updatedReports);

    // Save to AsyncStorage
    saveReportedIssues(updatedReports);

    // Save to Firestore for admin review
    let cloudSuccess = false;
    try {
      const result = await submitReportToCloud(newReport, user?.uid, user?.email);
      cloudSuccess = result.success;
      if (result.success && result.reportId) {
        updatedReports = updatedReports.map(r =>
          r.id === newReport.id ? { ...r, cloudId: result.reportId } : r
        );
        setReportedIssues(updatedReports);
        saveReportedIssues(updatedReports);
      } else if (!result.success) {
        console.error('Cloud report failed:', result.error);
      }
    } catch (error) {
      console.error('Error submitting report to cloud:', error);
    }

    setShowReportModal(false);
    setReportText('');

    showAlert(
      'Report Submitted',
      cloudSuccess
        ? 'Thank you for helping improve the app! Your feedback has been sent to the admin.'
        : 'Report saved locally. It will sync when you have a connection.',
      [{ text: 'OK' }]
    );
  };

  // Handle answer selection
  const handleAnswer = (optionIndex) => {
    if (selectedAnswer !== null) return;

    setSelectedAnswer(optionIndex);
    const isCorrect = shuffledOptions[optionIndex].isCorrect;

    // Update session stats
    setSessionStats(prev => ({
      correct: prev.correct + (isCorrect ? 1 : 0),
      incorrect: prev.incorrect + (isCorrect ? 0 : 1),
      total: prev.total + 1
    }));

    // Update performance tracking (simplified - no spaced repetition for questions)
    const question = questions[currentIndex];
    const existingData = cardData[question.id] || {};
    const isFirstAttempt = !existingData.attempts || existingData.attempts === 0;
    const prevStreak = existingData.streak || 0;
    const prevMaturity = existingData.maturity || 0;
    const nextStreak = isCorrect ? prevStreak + 1 : 0;
    const streakPromotes = isCorrect && nextStreak >= 2;
    const nextMaturity = isCorrect
      ? (streakPromotes ? Math.min(3, prevMaturity + 1) : prevMaturity)
      : Math.max(0, prevMaturity - 1);
    const nextNeedsReview = isCorrect
      ? (streakPromotes ? false : existingData.needsReview || false)
      : true;
    const deferSrs = learningSettings.confidenceRatings && testMode !== 'test';
    const questionRating = deferSrs ? null : computeQuestionRating(isCorrect, null);
    const srsUpdate = questionRating ? applyQuestionSrs(existingData, questionRating) : null;

    const nextEntry = {
      ...existingData,
      attempts: (existingData.attempts || 0) + 1,
      correct: (existingData.correct || 0) + (isCorrect ? 1 : 0),
      incorrect: (existingData.incorrect || 0) + (isCorrect ? 0 : 1),
      lastAttempted: Date.now(),
      lastReview: Date.now(), // For progress stats
      lastResult: isCorrect ? 'correct' : 'incorrect',
      firstAttemptCorrect: existingData.firstAttemptCorrect ?? isCorrect,
      streak: nextStreak,
      maturity: nextMaturity,
      // User can mark questions as needing review
      needsReview: nextNeedsReview, // Auto-mark incorrect, clear after consecutive corrects
      markedDifficult: existingData.markedDifficult || false,
      // Quality for retention calculation (0-5 scale)
      quality: isCorrect
        ? (existingData.quality ? Math.min(5, existingData.quality + (streakPromotes ? 1 : 0.5)) : 4)
        : 2,
      ...(srsUpdate || {}),
    };
    const leechEntry = updateQuestionLeech(nextEntry, isCorrect);
    const shouldCreateQuestionRemediation = !!(leechEntry.leech?.active && !existingData.leech?.remediationCreated);
    if (shouldCreateQuestionRemediation) {
      leechEntry.leech.remediationCreated = true;
    }
    const newCardData = {
      ...cardData,
      [question.id]: leechEntry,
    };
    setCardData(newCardData);

    if (questionRating) {
      const now = Date.now();
      const algoUsed = srsSettings.questionsAlgo || 'sm2';
      const beforeDue = getQuestionDueAtFromData(existingData, now);
      queueReviewLog({
        itemType: 'question',
        itemId: question.id,
        reviewedAt: now,
        rating: questionRating,
        correct: isCorrect,
        secondsSpent: questionStartedAt ? Math.max(0, Math.round((now - questionStartedAt) / 1000)) : null,
        wasDue: beforeDue ? beforeDue <= now : true,
        algoUsed,
        before: getQuestionSnapshot(existingData, algoUsed),
        after: getQuestionSnapshot(leechEntry, algoUsed),
      });
    }

    // Update recent categories for interleaving
    const newRecentCategories = [
      question.category,
      ...recentCategories.filter(c => c !== question.category)
    ].slice(0, 10);
    setRecentCategories(newRecentCategories);

    if (learningSettings.confidenceRatings && testMode !== 'test') {
      setPendingConfidenceMeta({ questionId: question.id, isCorrect });
    } else {
      setPendingConfidenceMeta(null);
    }

    // Unlock related pre-made flashcards on wrong answers (no auto-generation)
    let updatedFlashcards = flashcards;
    if (!isCorrect && isFirstAttempt) {
      const prevById = new Map(updatedFlashcards.map(c => [c.id, c]));
      const unlockedCards = unlockRelatedFlashcards(
        updatedFlashcards,
        question.id,
        question.category,
        question.subcategory,
        question.relatedReading
      );
      const changed = [];
      const nextCards = unlockedCards.map(card => {
        const prev = prevById.get(card.id);
        const unlockedNow = prev?.locked && !card.locked;
        const boostedNow = prev?.boostUntil !== card.boostUntil && card.boostUntil;
        if (unlockedNow || boostedNow) {
          const next = touchFlashcard(card);
          changed.push(next);
          return next;
        }
        return card;
      });
      const newlyUnlocked = nextCards.filter(c => !c.locked).length - updatedFlashcards.filter(c => !c.locked).length;
      if (newlyUnlocked > 0) {
        console.log(`[FLASHCARD-UNLOCK] Unlocked ${newlyUnlocked} flashcards for ${question.subcategory || question.category}`);
      }
      updatedFlashcards = nextCards;
      setFlashcards(updatedFlashcards);
      if (user?.uid && changed.length > 0) {
        upsertUserFlashcardsBatch(user.uid, changed).catch(err => {
          console.error('[CloudSync] Failed to sync unlocked flashcards:', err);
        });
      }
    }

    // Save data
    saveData(newCardData, newRecentCategories, updatedFlashcards);

    if (shouldCreateQuestionRemediation && user?.uid) {
      createRemediationTask(user.uid, {
        type: 'question',
        questionId: question.id,
        relatedReadingId: question.relatedReading || null,
        relatedQuestionIds: [question.id],
        status: 'open',
      }).catch(err => {
        console.error('[CloudSync] Failed to create question remediation:', err);
      });
    }

    if (user?.uid) {
      upsertUserQuestionState(user.uid, question.id, newCardData[question.id]).catch(err => {
        console.error('[CloudSync] Failed to upsert question state:', err);
      });
    }

    if (PROGRESS_SERVER_FIRST && user?.uid) {
      recordQuestionAttempt(user.uid, {
        questionId: question.id,
        isCorrect,
        category: question.category || null,
        subcategory: question.subcategory || null,
        relatedReading: question.relatedReading || null,
        attemptNumber: (existingData.attempts || 0) + 1,
        wasFirstAttempt: isFirstAttempt,
        streak: nextStreak,
        maturity: nextMaturity,
        needsReview: nextNeedsReview,
        quality: isCorrect
          ? (existingData.quality ? Math.min(5, existingData.quality + (streakPromotes ? 1 : 0.5)) : 4)
          : 2,
        mode: testMode || null,
      });
    }

    const questionGameResult = applyGameMetrics([
      { metric: 'questions_answered', delta: 1 },
      ...(isCorrect ? [{ metric: 'questions_correct', delta: 1 }] : []),
    ]);

    // Award coins and XP for pet system
    if (coinData && petData) {
      const coinAmount = isCorrect ? COIN_RATES.QUESTION_CORRECT : COIN_RATES.QUESTION_INCORRECT;
      const xpAmount = isCorrect ? XP_RATES.QUESTION_CORRECT : XP_RATES.QUESTION_INCORRECT;

      // Award coins
      const updatedCoins = awardCoins(questionGameResult.coinData || coinData, coinAmount, 'question');
      setCoinData(updatedCoins);
      saveCoinData(updatedCoins);

      // Add XP to active pet
      if (selectedPetId && petData.pets?.length > 0) {
        const petIndex = petData.pets.findIndex(p => p.id === selectedPetId);
        if (petIndex !== -1) {
          const previousSpeciesId = petData.pets[petIndex].speciesId;
          const { pet: updatedPet, evolved, newStage } = addExperience(petData.pets[petIndex], xpAmount);
          // Also boost happiness
          const happyPet = updateHappiness(updatedPet, isCorrect ? HAPPINESS_BOOSTS.QUESTION_CORRECT : HAPPINESS_BOOSTS.QUESTION_INCORRECT);

          const updatedPets = [...petData.pets];
          updatedPets[petIndex] = happyPet;
          const updatedPetData = { ...petData, pets: updatedPets };
          setPetData(updatedPetData);
          savePetData(updatedPetData);

          if (evolved) {
            setTimeout(() => handlePetEvolution(happyPet, newStage, previousSpeciesId), 500);
          }
        }
      }

      // Show coin earned toast (brief)
      const bonusCoins = questionGameResult.rewardCoins || 0;
      setShowCoinEarnedToast({
        amount: coinAmount + bonusCoins,
        source: bonusCoins > 0
          ? `${isCorrect ? 'Correct!' : 'Keep trying!'} + goal reward`
          : (isCorrect ? 'Correct!' : 'Keep trying!'),
      });
      setTimeout(() => setShowCoinEarnedToast(null), 1500);
    }

    // Always store answer for end-of-session review
    setTestAnswers(prev => [...prev, {
      questionId: question.id,
      selectedIndex: optionIndex,
      isCorrect,
      question: question
    }]);

    // In test mode, move to next question without showing explanation
    if (testMode === 'test' && (currentMode?.id === 'exam_sim' || currentMode?.id === 'timed')) {
      // Auto-advance after a brief delay to show selection
      setTimeout(() => {
        if (currentIndex < questions.length - 1) {
          const nextIdx = currentIndex + 1;
          setCurrentIndex(nextIdx);
          setSelectedAnswer(null);
          setShuffledOptions(prepareQuestion(questions[nextIdx]));
        } else {
          finishSession();
        }
      }, 500);
    } else {
      // Tutor mode: show explanation after each question
      setShowExplanation(true);
    }
  };

  const handleConfidenceRating = (level) => {
    const meta = pendingConfidenceMeta;
    if (!meta) return;
    const questionId = meta.questionId;
    setCardData(prev => {
      const existing = prev[questionId] || {};
      const nextConfidenceHistory = [
        ...(existing.confidenceHistory || []),
        { level, correct: meta.isCorrect, at: Date.now() }
      ];
      let nextStreak = existing.streak || 0;
      let nextMaturity = existing.maturity || 0;
      let nextNeedsReview = existing.needsReview || false;

      if (meta.isCorrect && level === 'low') {
        nextNeedsReview = true;
        nextStreak = Math.max(0, nextStreak - 1);
        nextMaturity = Math.max(0, nextMaturity - 1);
      }

      let updated = {
        ...existing,
        lastConfidence: level,
        confidenceHistory: nextConfidenceHistory,
        streak: nextStreak,
        maturity: nextMaturity,
        needsReview: nextNeedsReview,
      };
      const rating = computeQuestionRating(meta.isCorrect, level);
      const srsUpdate = applyQuestionSrs(updated, rating);
      updated = { ...updated, ...srsUpdate };
      if (!meta.isCorrect) {
        updated = updateQuestionLeech(updated, false);
        if (updated.leech?.active && !existing.leech?.remediationCreated) {
          updated.leech.remediationCreated = true;
        }
      }
      const now = Date.now();
      const algoUsed = srsSettings.questionsAlgo || 'sm2';
      const beforeDue = getQuestionDueAtFromData(existing, now);
      queueReviewLog({
        itemType: 'question',
        itemId: questionId,
        reviewedAt: now,
        rating,
        correct: meta.isCorrect,
        secondsSpent: questionStartedAt ? Math.max(0, Math.round((now - questionStartedAt) / 1000)) : null,
        wasDue: beforeDue ? beforeDue <= now : true,
        algoUsed,
        before: getQuestionSnapshot(existing, algoUsed),
        after: getQuestionSnapshot(updated, algoUsed),
      });
      const next = { ...prev, [questionId]: updated };
      saveData(next, recentCategories, flashcards);
      return next;
    });
    if (user?.uid) {
      const existing = cardData[questionId] || {};
      const rating = computeQuestionRating(meta.isCorrect, level);
      let merged = { ...existing, ...applyQuestionSrs(existing, rating), lastConfidence: level };
      if (!meta.isCorrect) {
        merged = updateQuestionLeech(merged, false);
      }
      if (merged.leech?.active && !existing.leech?.remediationCreated) {
        createRemediationTask(user.uid, {
          type: 'question',
          questionId,
          relatedReadingId: null,
          relatedQuestionIds: [questionId],
          status: 'open',
        }).catch(err => {
          console.error('[CloudSync] Failed to create question remediation:', err);
        });
        if (merged.leech) merged.leech.remediationCreated = true;
      }
      upsertUserQuestionState(user.uid, questionId, merged).catch(err => {
        console.error('[CloudSync] Failed to upsert question state:', err);
      });
    }
    setPendingConfidenceMeta(null);
  };

  // Mark a question as difficult or needing review
  const markQuestionForReview = (questionId, markType) => {
    const existingData = cardData[questionId] || {};
    const newCardData = {
      ...cardData,
      [questionId]: {
        ...existingData,
        needsReview: markType === 'review' ? !existingData.needsReview : existingData.needsReview,
        markedDifficult: markType === 'difficult' ? !existingData.markedDifficult : existingData.markedDifficult,
      }
    };
    setCardData(newCardData);
    saveData(newCardData, recentCategories, flashcards);
  };

  // Add flashcards from a missed question
  const addFlashcardsFromQuestion = (question) => {
    const newCards = generateCardsFromQuestion(question, true);
    if (newCards.length === 0) {
      showAlert('No Cards Created', 'Could not generate flashcards from this question.');
      return;
    }

    // Check for duplicates
    const existingIds = new Set(flashcards.map(c => c.sourceQuestionId));
    const uniqueCards = newCards
      .filter(c => !existingIds.has(c.sourceQuestionId))
      .map(card => touchFlashcard(card));

    if (uniqueCards.length === 0) {
      showAlert('Already Added', 'Flashcards for this question already exist.');
      return;
    }

    const updatedFlashcards = [...flashcards, ...uniqueCards];
    setFlashcards(updatedFlashcards);
    saveData(cardData, recentCategories, updatedFlashcards);

    if (user?.uid) {
      upsertUserFlashcardsBatch(user.uid, uniqueCards).catch(err => {
        console.error('[CloudSync] Failed to upsert new flashcards:', err);
      });
    }

    showAlert(
      'Cards Added!',
      `${uniqueCards.length} flashcard${uniqueCards.length > 1 ? 's' : ''} created from this question.`
    );
  };

  // Rate difficulty after seeing answer (for spaced repetition)
  const rateAnswer = (quality) => {
    const question = questions[currentIndex];
    const newSRData = calculateNextReview(cardData[question.id] || {}, quality);

    const newCardData = {
      ...cardData,
      [question.id]: {
        ...cardData[question.id],
        ...newSRData
      }
    };
    setCardData(newCardData);
    saveData(newCardData, recentCategories, flashcards);

    nextQuestion();
  };

  // Save current question state for navigation
  const saveCurrentQuestionState = () => {
    if (selectedAnswer !== null) {
      setQuestionAnswers(prev => ({
        ...prev,
        [currentIndex]: {
          answer: selectedAnswer,
          shuffledOptions: shuffledOptions,
          isCorrect: shuffledOptions[selectedAnswer]?.isCorrect
        }
      }));
    }
  };

  // Move to next question
  const nextQuestion = () => {
    saveCurrentQuestionState();
    setPendingConfidenceMeta(null);
    if (currentIndex < questions.length - 1) {
      const nextIdx = currentIndex + 1;
      setCurrentIndex(nextIdx);
      // Check if we've already answered this question
      const savedState = questionAnswers[nextIdx];
      if (savedState) {
        setSelectedAnswer(savedState.answer);
        setShuffledOptions(savedState.shuffledOptions);
        setShowExplanation(true);
      } else {
        setSelectedAnswer(null);
        setShuffledOptions(prepareQuestion(questions[nextIdx]));
        setShowExplanation(false);
      }
    } else {
      finishSession();
    }
  };

  // Move to previous question
  const previousQuestion = () => {
    saveCurrentQuestionState();
    setPendingConfidenceMeta(null);
    if (currentIndex > 0) {
      const prevIdx = currentIndex - 1;
      setCurrentIndex(prevIdx);
      // Restore previous answer state
      const savedState = questionAnswers[prevIdx];
      if (savedState) {
        setSelectedAnswer(savedState.answer);
        setShuffledOptions(savedState.shuffledOptions);
        setShowExplanation(true);
      } else {
        setSelectedAnswer(null);
        setShuffledOptions(prepareQuestion(questions[prevIdx]));
        setShowExplanation(false);
      }
    }
  };

  // Handle flashcard rating
  const handleFlashcardRating = (rating) => {
    const currentCard = dueFlashcards[currentFlashcardIndex];
    let updatedCard = touchFlashcard(rateFlashcard(currentCard, rating, srsSettings));
    const shouldCreateFlashcardRemediation = !!(updatedCard.leech?.active && !currentCard?.leech?.remediationCreated);
    if (shouldCreateFlashcardRemediation) {
      updatedCard = touchFlashcard({
        ...updatedCard,
        leech: {
          ...(updatedCard.leech || {}),
          remediationCreated: true,
        },
      });
    }

    // Update in main flashcards array
    const updatedFlashcards = flashcards.map(c =>
      c.id === updatedCard.id ? updatedCard : c
    );
    setFlashcards(updatedFlashcards);
    saveData(cardData, recentCategories, updatedFlashcards);

    const now = Date.now();
    const algoUsed = srsSettings.flashcardsAlgo || 'sm2';
    const dueAt = currentCard?.boostUntil && currentCard.boostUntil > now
      ? now
      : (algoUsed === 'fsrs' ? currentCard?.srs?.fsrs?.due : currentCard?.nextReview);
    const flashcardLog = {
      itemType: 'flashcard',
      itemId: updatedCard.id,
      reviewedAt: now,
      rating,
      secondsSpent: flashcardViewStartedAt ? Math.max(0, Math.round((now - flashcardViewStartedAt) / 1000)) : null,
      wasDue: dueAt ? dueAt <= now : true,
      algoUsed,
      before: getFlashcardSnapshot(currentCard, algoUsed),
      after: getFlashcardSnapshot(updatedCard, algoUsed),
    };
    queueReviewLog(flashcardLog);

    if (user?.uid) {
      upsertUserFlashcard(user.uid, updatedCard).catch(err => {
        console.error('[CloudSync] Failed to upsert flashcard:', err);
      });
      if (shouldCreateFlashcardRemediation) {
        createRemediationTask(user.uid, {
          type: 'flashcard',
          cardId: updatedCard.id,
          relatedReadingId: updatedCard.relatedReading || null,
          relatedResourceIds: updatedCard.relatedResourceIds || [],
          relatedQuestionIds: [
            ...(updatedCard.sourceQuestionId ? [updatedCard.sourceQuestionId] : []),
            ...(Array.isArray(updatedCard.relatedQuestions) ? updatedCard.relatedQuestions : []),
          ],
          status: 'open',
        }).catch(err => {
          console.error('[CloudSync] Failed to create flashcard remediation:', err);
        });
      }
    }

    if (PROGRESS_SERVER_FIRST && user?.uid) {
      const fsrsState = updatedCard?.srs?.fsrs;
      const reviewInterval = typeof fsrsState?.scheduled_days === 'number' ? fsrsState.scheduled_days : (updatedCard.interval ?? 0);
      const reviewNext = typeof fsrsState?.due === 'number' ? fsrsState.due : (updatedCard.nextReview ?? null);
      const reviewLast = fsrsState?.last_review ?? updatedCard.lastReview ?? Date.now();

      recordFlashcardReview(user.uid, {
        cardId: updatedCard.id,
        rating,
        interval: reviewInterval,
        easeFactor: updatedCard.easeFactor ?? 2.5,
        repetitions: updatedCard.repetitions ?? 0,
        nextReview: reviewNext,
        lastReview: reviewLast,
        reviewCount: updatedCard.reviewCount ?? 0,
        suspended: !!updatedCard.suspended,
        relatedReading: updatedCard.relatedReading || null,
        relatedResourceIds: updatedCard.relatedResourceIds || [],
        category: updatedCard.category || null,
        subcategory: updatedCard.subcategory || null,
      });
    }

    const flashcardGameResult = applyGameMetrics([
      { metric: 'flashcards_reviewed', delta: 1 },
      { metric: 'flashcard_reviews', delta: 1 },
    ]);

    // Award coins and XP for flashcard review
    if (coinData && petData) {
      const coinRates = {
        'again': COIN_RATES.FLASHCARD_AGAIN,
        'hard': COIN_RATES.FLASHCARD_HARD,
        'good': COIN_RATES.FLASHCARD_GOOD,
        'easy': COIN_RATES.FLASHCARD_EASY,
      };
      const coinAmount = coinRates[rating] || 2;

      // Award coins
      const updatedCoins = awardCoins(flashcardGameResult.coinData || coinData, coinAmount, 'flashcard');
      setCoinData(updatedCoins);
      saveCoinData(updatedCoins);

      // Add XP to active pet
      if (selectedPetId && petData.pets?.length > 0) {
        const petIndex = petData.pets.findIndex(p => p.id === selectedPetId);
        if (petIndex !== -1) {
          const previousSpeciesId = petData.pets[petIndex].speciesId;
          const { pet: updatedPet, evolved, newStage } = addExperience(petData.pets[petIndex], XP_RATES.FLASHCARD_REVIEW);
          const happyPet = updateHappiness(updatedPet, HAPPINESS_BOOSTS.FLASHCARD_REVIEW);

          const updatedPets = [...petData.pets];
          updatedPets[petIndex] = happyPet;
          const updatedPetData = { ...petData, pets: updatedPets };
          setPetData(updatedPetData);
          savePetData(updatedPetData);

          if (evolved) {
            setTimeout(() => handlePetEvolution(happyPet, newStage, previousSpeciesId), 500);
          }
        }
      }
    }

    // Move to next card
    if (currentFlashcardIndex < dueFlashcards.length - 1) {
      setCurrentFlashcardIndex(currentFlashcardIndex + 1);
      setFlashcardRevealed(false);
    } else {
      // Session complete
      setScreen('flashcard-results');
    }
  };

  // Open card settings modal
  const openCardSettings = (card) => {
    setCardSettingsTarget(card);
    setCustomIntervalInput(card.customInterval ? String(card.customInterval) : '');
    setShowCardSettingsModal(true);
  };

  // Suspend/unsuspend current flashcard
  const handleSuspendCard = () => {
    if (!cardSettingsTarget) return;

    const updatedCard = touchFlashcard(toggleSuspendCard(cardSettingsTarget));
    const updatedFlashcards = flashcards.map(c =>
      c.id === updatedCard.id ? updatedCard : c
    );
    setFlashcards(updatedFlashcards);
    saveData(cardData, recentCategories, updatedFlashcards);
    setShowCardSettingsModal(false);

    if (user?.uid) {
      upsertUserFlashcard(user.uid, updatedCard).catch(err => {
        console.error('[CloudSync] Failed to upsert flashcard:', err);
      });
    }

    if (updatedCard.suspended) {
      showAlert('Card Suspended', 'This card will no longer appear in reviews.');
      // Move to next card if in session
      if (screen === 'flashcard' && dueFlashcards.length > 0) {
        // Remove from due cards and move to next
        const newDueCards = dueFlashcards.filter(c => c.id !== updatedCard.id);
        setDueFlashcards(newDueCards);
        if (currentFlashcardIndex >= newDueCards.length && newDueCards.length > 0) {
          setCurrentFlashcardIndex(newDueCards.length - 1);
        }
        setFlashcardRevealed(false);
        if (newDueCards.length === 0) {
          setScreen('flashcard-results');
        }
      }
    } else {
      showAlert('Card Unsuspended', 'This card will appear in reviews again.');
    }
  };

  // Set custom interval for a card
  const handleSetCustomInterval = () => {
    if (!cardSettingsTarget) return;

    const days = parseInt(customIntervalInput, 10);
    if (isNaN(days) || days < 1) {
      showAlert('Invalid Interval', 'Please enter a number of days (1 or more).');
      return;
    }

    const updatedCard = touchFlashcard(setCustomInterval(cardSettingsTarget, days));
    const updatedFlashcards = flashcards.map(c =>
      c.id === updatedCard.id ? updatedCard : c
    );
    setFlashcards(updatedFlashcards);
    saveData(cardData, recentCategories, updatedFlashcards);
    setShowCardSettingsModal(false);

    if (user?.uid) {
      upsertUserFlashcard(user.uid, updatedCard).catch(err => {
        console.error('[CloudSync] Failed to upsert flashcard:', err);
      });
    }

    showAlert('Interval Set', `This card will next appear in ${days} day${days !== 1 ? 's' : ''}.`);

    // Move to next card if in session
    if (screen === 'flashcard' && dueFlashcards.length > 0) {
      const newDueCards = dueFlashcards.filter(c => c.id !== updatedCard.id);
      setDueFlashcards(newDueCards);
      if (currentFlashcardIndex >= newDueCards.length && newDueCards.length > 0) {
        setCurrentFlashcardIndex(newDueCards.length - 1);
      }
      setFlashcardRevealed(false);
      if (newDueCards.length === 0) {
        setScreen('flashcard-results');
      }
    }
  };

  // Clear custom interval (return to algorithm)
  const handleClearCustomInterval = () => {
    if (!cardSettingsTarget) return;

    const updatedCard = touchFlashcard(setCustomInterval(cardSettingsTarget, null));
    const updatedFlashcards = flashcards.map(c =>
      c.id === updatedCard.id ? updatedCard : c
    );
    setFlashcards(updatedFlashcards);
    saveData(cardData, recentCategories, updatedFlashcards);
    setShowCardSettingsModal(false);

    if (user?.uid) {
      upsertUserFlashcard(user.uid, updatedCard).catch(err => {
        console.error('[CloudSync] Failed to upsert flashcard:', err);
      });
    }

    showAlert('Custom Interval Cleared', 'This card will now use the spaced repetition algorithm.');
  };

  // Add manual flashcard
  const addManualFlashcard = () => {
    if (!newCardText.includes('{{c::')) {
      showAlert(
        'Invalid Format',
        'Use {{c::answer}} to mark the part to hide.\n\nExample: "The {{c::internal nasal valve}} is the narrowest part of the nasal airway."'
      );
      return;
    }

    const card = createManualClozeCard(newCardText, ['manual']);
    if (card) {
      const touched = touchFlashcard(card);
      const updatedFlashcards = [...flashcards, touched];
      setFlashcards(updatedFlashcards);
      saveData(cardData, recentCategories, updatedFlashcards);
      setNewCardText('');
      setShowAddCardModal(false);
      showAlert('Card Added!', 'Your flashcard has been created.');

      if (user?.uid) {
        upsertUserFlashcard(user.uid, touched).catch(err => {
          console.error('[CloudSync] Failed to upsert flashcard:', err);
        });
      }
    }
  };

  const handleUnsuspendLeech = (card) => {
    if (!card) return;
    const updatedCard = touchFlashcard({
      ...card,
      suspended: false,
      leech: {
        ...(card.leech || {}),
        active: false,
        remediatedAt: Date.now(),
      },
    });
    const updatedFlashcards = flashcards.map(c =>
      c.id === updatedCard.id ? updatedCard : c
    );
    setFlashcards(updatedFlashcards);
    saveData(cardData, recentCategories, updatedFlashcards);

    if (user?.uid) {
      upsertUserFlashcard(user.uid, updatedCard).catch(err => {
        console.error('[CloudSync] Failed to upsert flashcard:', err);
      });
    }

    showAlert('Card Unsuspended', 'This card is back in rotation.');
  };

  const startMicroTestFromMisses = () => {
    const targetCount = Math.max(3, Math.min(10, learningSettings.microTestSize || 5));
    const missedIds = testAnswers.filter(a => !a.isCorrect).map(a => a.questionId);
    const missedQuestions = activeQuestions.filter(q => missedIds.includes(q.id));
    const weakPool = activeQuestions.filter(q => {
      const data = cardData[q.id];
      if (!data) return false;
      const attempts = data.attempts || 0;
      const incorrect = data.incorrect || 0;
      return data.needsReview || data.markedDifficult || (attempts > 0 && incorrect > 0);
    });
    const combined = [...missedQuestions, ...weakPool];
    const unique = Array.from(new Map(combined.map(q => [q.id, q])).values());
    if (unique.length === 0) {
      showAlert('No Micro-Test Available', 'No missed or weak questions are available yet.');
      return;
    }
    const selectedQuestions = shuffleArray(unique).slice(0, Math.min(targetCount, unique.length));
    setTestMode('tutor');
    setTimedMode(false);
    setTimeRemaining(null);
    setTimerActive(false);
    setQuestions(selectedQuestions);
    setCurrentMode({ id: 'micro', name: 'Micro Test', color: '#4CAF50' });
    setSelectedCategory(null);
    setCurrentIndex(0);
    setSelectedAnswer(null);
    setShowExplanation(false);
    setPendingConfidenceMeta(null);
    setSessionStats({ correct: 0, incorrect: 0, total: 0 });
    setQuestionAnswers({});
    setShuffledOptions(prepareQuestion(selectedQuestions[0]));
    setActiveSessionId(createSessionId());
    setScreen('question');
  };

  // Finish the session
  const finishSession = () => {
    setTimerActive(false);
    setTimeRemaining(null);
    if (activeSessionId) {
      removeSavedSession(activeSessionId);
      setActiveSessionId(null);
    }
    if (activeAssignmentId) {
      const total = sessionStats.total || 0;
      const correct = sessionStats.correct || 0;
      const percentage = total > 0 ? Math.round((correct / total) * 100) : 0;
      updateDoc(doc(db, 'assignments', activeAssignmentId), {
        status: 'completed',
        completedAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        score: { correct, total, percentage },
      }).catch(error => {
        console.error('[Assignments] Failed to mark completed:', error);
      });
      setActiveAssignmentId(null);
      loadAssignedExams();
    }

    // Update weakness analysis and suggested reading based on session results
    const analysis = analyzeWeaknesses(cardData, activeQuestions);
    setWeaknessAnalysis(analysis);
    const reading = getSuggestedReadingForMissedQuestions(activeResources, analysis.missedQuestionIds);
    setSuggestedReading(reading);

    const sessionGameResult = sessionStats.total > 0
      ? applyGameMetrics([{ metric: 'sessions_completed', delta: 1 }])
      : { rewardCoins: 0, coinData: coinData || null };

    // Award session completion bonus
    if (coinData && sessionStats.total > 0) {
      const bonus = calculateSessionBonus(sessionStats.total);
      if (bonus > 0) {
        const updatedCoins = awardCoins(sessionGameResult.coinData || coinData, bonus, 'session_bonus');
        setCoinData(updatedCoins);
        saveCoinData(updatedCoins);

        // Also award XP bonus to pet
        if (selectedPetId && petData?.pets?.length > 0) {
          const petIndex = petData.pets.findIndex(p => p.id === selectedPetId);
          if (petIndex !== -1) {
            const previousSpeciesId = petData.pets[petIndex].speciesId;
            const { pet: updatedPet, evolved, newStage } = addExperience(petData.pets[petIndex], XP_RATES.SESSION_COMPLETE);
            const happyPet = updateHappiness(updatedPet, HAPPINESS_BOOSTS.SESSION_COMPLETE);
            const updatedPets = [...petData.pets];
            updatedPets[petIndex] = happyPet;
            const updatedPetData = { ...petData, pets: updatedPets };
            setPetData(updatedPetData);
            savePetData(updatedPetData);
            if (evolved) {
              setTimeout(() => handlePetEvolution(happyPet, newStage, previousSpeciesId), 500);
            }
          }
        }

        // Show bonus toast
        setShowCoinEarnedToast({
          amount: bonus + (sessionGameResult.rewardCoins || 0),
          source: sessionGameResult.rewardCoins > 0 ? 'Session Bonus + goals!' : 'Session Bonus!',
        });
        setTimeout(() => setShowCoinEarnedToast(null), 3000);
      }
    }

    // Save session to history and sync to cloud
    if (sessionStats.total > 0) {
      const sessionRecord = {
        id: `session_${Date.now()}`,
        timestamp: Date.now(),
        mode: currentMode?.id || 'practice',
        modeName: currentMode?.name || 'Practice',
        category: selectedCategory || null,
        correct: sessionStats.correct,
        incorrect: sessionStats.incorrect,
        total: sessionStats.total,
        percentage: Math.round((sessionStats.correct / sessionStats.total) * 100),
        questionIds: testAnswers.map(a => a.questionId),
      };
      const updatedHistory = [sessionRecord, ...(sessionHistory || [])].slice(0, 100);
      setSessionHistory(updatedHistory);
      saveSessionHistory(updatedHistory);

      // Sync session history to cloud
      if (user?.uid) {
        queueCloudUpdate({ sessionHistory: updatedHistory });
      }
    }

    setScreen('results');
  };

  // Format time for display
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const formatAssignmentDate = (value) => {
    if (!value) return null;
    const ts = value?.toMillis ? value.toMillis() : value;
    const date = new Date(ts);
    if (Number.isNaN(date.getTime())) return null;
    return date.toLocaleDateString();
  };

  const isGeneratedFlashcard = (card) => {
    if (!card) return false;
    const tags = (card.tags || []).map(t => String(t).toLowerCase());
    const hasAutoTag = tags.includes('key-point') || tags.includes('explanation') || tags.includes('manual');
    const hasSource = !!card.sourceQuestionId;
    const hasCreated = typeof card.created === 'number';
    return (hasSource && hasCreated) || (hasAutoTag && hasCreated) || tags.includes('manual');
  };

  const openExternalLink = async (url, fallbackMessage) => {
    try {
      const supported = await Linking.canOpenURL(url);
      if (supported) {
        await Linking.openURL(url);
      } else {
        showAlert('Link Unavailable', fallbackMessage || 'Unable to open this link on your device.');
      }
    } catch (error) {
      showAlert('Link Error', fallbackMessage || 'Unable to open this link right now.');
    }
  };

  const resetFlashcardProgress = (cards) => {
    return cards.map(card => ({
      ...card,
      easeFactor: 2.5,
      interval: 0,
      repetitions: 0,
      nextReview: null,
      lastReview: null,
      reviewCount: 0,
      suspended: false,
      customInterval: null,
      lastRating: null,
      locked: true,
      unlockedAt: null,
      unlockedBy: null,
    }));
  };

  const parseAssignmentQuestionIds = (text) => {
    if (!text) return [];
    return text
      .split(/[\n,]+/)
      .map(id => id.trim())
      .filter(Boolean);
  };

  const resolveAssignmentQuestions = (assignment) => {
    const ids = assignment.questionIds || [];
    const categories = assignment.categories || [];
    const focusTags = normalizeTagList(assignment.focusTags);
    const count = Number.isFinite(assignment.count) ? assignment.count : null;
    const categorySet = new Set(categories);

    const fromIds = ids.length
      ? ids.map(id => allQuestions.find(q => q.id === id)).filter(Boolean)
      : [];

    let fromFilters = [];
    if (categories.length > 0 || focusTags.length > 0) {
      fromFilters = allQuestions.filter(q => {
        const categoryOk = isQuestionInAnyCategory(q, categorySet);
        if (!categoryOk) return false;
        if (focusTags.length === 0) return true;
        const tags = normalizeTagList(q.tags);
        const sub = normalizeTag(q.subcategory);
        const qType = normalizeTag(q.questionType);
        const category = normalizeTag(q.category);
        const categoryName = normalizeTag(getCategoryLabelForQuestion(q));
        return focusTags.some(tag =>
          tags.includes(tag) ||
          sub.includes(tag) ||
          qType.includes(tag) ||
          category.includes(tag) ||
          categoryName.includes(tag)
        );
      });
    }

    const merged = new Map();
    [...fromIds, ...fromFilters].forEach(q => merged.set(q.id, q));
    const combined = Array.from(merged.values());

    if (count && combined.length > count) {
      return shuffleArray(combined).slice(0, count);
    }
    return combined;
  };

  const handleResetProgress = () => {
    showAlert(
      'Reset Progress',
      'This will reset question progress, flashcard schedules, saved sessions, and reading completion. Content and pets/coins stay the same.',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Reset',
          style: 'destructive',
          onPress: async () => {
            const resetCards = resetFlashcardProgress(flashcards);
            setCardData({});
            setRecentCategories([]);
            setReadTopics({});
            setSavedSessions([]);
            setFlashcards(resetCards);
            saveData({}, [], resetCards, {});
            await saveSavedSessions([]);
            if (user?.uid) {
              updateUserDataInCloud(user.uid, { savedSessions: [] }).catch(err => {
                console.error('[CloudSync] Error clearing saved sessions:', err);
              });
            }
            showAlert('Progress Reset', 'Your progress has been reset.');
          }
        }
      ]
    );
  };

  const syncDevPetSystem = (updates) => {
    if (!user?.uid) return;
    updateUserDataInCloud(user.uid, updates).catch(err => {
      console.error('[DevTools] Failed to sync pet system:', err);
    });
  };

  const handleDevAddCoins = (amount = 5000) => {
    const updatedCoins = awardCoins(coinData || createInitialCoinData(), amount, 'dev');
    setCoinData(updatedCoins);
    saveCoinData(updatedCoins);
    syncDevPetSystem({ coinData: updatedCoins });
  };

  const handleDevClearPets = () => {
    const cleared = {
      ...(petData || createInitialPetData()),
      pets: [],
      activePetId: null,
      firstEggClaimed: false,
      totalPetsHatched: 0,
    };
    setPetData(cleared);
    setSelectedPetId(null);
    setSelectedRoom('room_1');
    savePetData(cleared);
    syncDevPetSystem({ petData: cleared });
  };

  const handleDevResetPetSystem = () => {
    const freshPets = createInitialPetData();
    const freshCoins = createInitialCoinData();
    const freshShop = createInitialShopData();
    const freshRooms = createInitialRoomData();

    setPetData(freshPets);
    setCoinData(freshCoins);
    setShopData(freshShop);
    setRoomData(freshRooms);
    setSelectedPetId(null);
    setSelectedRoom('room_1');
    savePetData(freshPets);
    saveCoinData(freshCoins);
    saveShopData(freshShop);
    saveRoomData(freshRooms);
    syncDevPetSystem({
      petData: freshPets,
      coinData: freshCoins,
      shopData: freshShop,
      roomData: freshRooms,
    });
  };

  const handleDevSpawnPet = () => {
    const sourcePets = petData || createInitialPetData();
    const newPet = createPet('blobby', 'Debug', selectedRoom || 'room_1');
    const nextPets = {
      ...sourcePets,
      pets: [...(sourcePets.pets || []), newPet],
      activePetId: newPet.id,
      firstEggClaimed: true,
      totalPetsHatched: (sourcePets.totalPetsHatched || 0) + 1,
    };
    setPetData(nextPets);
    setSelectedPetId(newPet.id);
    savePetData(nextPets);
    syncDevPetSystem({ petData: nextPets });
  };

  const reviewedCards = useMemo(() => (
    Object.entries(cardData)
      .filter(([id]) => activeQuestionIdSet.has(id))
      .map(([id, data]) => ({ id, ...data }))
  ), [cardData, activeQuestionIdSet]);

  const overallStats = useMemo(() => {
    const local = calculateRetention(reviewedCards);
    const totalQuestions = Math.max(activeQuestions.length, reviewedCards.length);
    return { ...local, total: totalQuestions };
  }, [activeQuestions.length, reviewedCards]);

  const focusTagCounts = useMemo(() => {
    const counts = {};
    activeQuestions.forEach(q => {
      const tags = q.tags || [];
      tags.forEach(tag => {
        if (!tag) return;
        counts[tag] = (counts[tag] || 0) + 1;
      });
    });
    return counts;
  }, [activeQuestions]);

  const questionsById = useMemo(() => {
    const map = new Map();
    activeQuestions.forEach(q => {
      if (q?.id) map.set(q.id, q);
    });
    return map;
  }, [activeQuestions]);

  const unlockFlashcardsMatching = useCallback((predicate, label) => {
    if (!flashcards || flashcards.length === 0) {
      showAlert('No Flashcards', 'No flashcards are available to unlock yet.');
      return;
    }
    let unlockedCount = 0;
    const changed = [];
    const updated = flashcards.map(card => {
      if (!card || card.locked === false) return card;
      if (predicate(card)) {
        unlockedCount += 1;
        const next = touchFlashcard({ ...card, locked: false });
        changed.push(next);
        return next;
      }
      return card;
    });

    if (unlockedCount === 0) {
      showAlert('No Matches', `No locked flashcards matched ${label}.`);
      return;
    }

    setFlashcards(updated);
    saveFlashcards(updated);
    if (user?.uid && changed.length > 0) {
      upsertUserFlashcardsBatch(user.uid, changed).catch(err => {
        console.error('[CloudSync] Failed to sync unlocked flashcards:', err);
      });
    }
    showAlert('Unlocked', `Unlocked ${unlockedCount} flashcard${unlockedCount !== 1 ? 's' : ''} ${label}.`);
  }, [flashcards, user?.uid]);

  const unlockFlashcardsForQuestionIds = useCallback((ids, label) => {
    const list = Array.isArray(ids) ? ids.filter(Boolean) : [];
    if (list.length === 0) {
      showAlert('No Questions', 'No question IDs were provided.');
      return;
    }
    const idSet = new Set(list);
    unlockFlashcardsMatching(card => {
      if (card.sourceQuestionId && idSet.has(card.sourceQuestionId)) return true;
      if (Array.isArray(card.relatedQuestions) && card.relatedQuestions.some(id => idSet.has(id))) return true;
      return false;
    }, label);
  }, [unlockFlashcardsMatching]);

  const unlockFlashcardsForReading = useCallback((resource) => {
    if (!resource) return;
    const ids = Array.isArray(resource.questionIds) ? resource.questionIds : [];
    const idSet = new Set(ids);
    const readingId = resource.id;
    unlockFlashcardsMatching(card => {
      if (readingId && Array.isArray(card.relatedResourceIds) && card.relatedResourceIds.includes(readingId)) return true;
      if (readingId && card.relatedReading === readingId) return true;
      if (card.sourceQuestionId && idSet.has(card.sourceQuestionId)) return true;
      if (Array.isArray(card.relatedQuestions) && card.relatedQuestions.some(id => idSet.has(id))) return true;
      return false;
    }, 'for this reading');
  }, [unlockFlashcardsMatching]);

  const unlockFlashcardsForCategory = useCallback((categoryKey) => {
    const label = activeCategoryMap[categoryKey]?.name || categoryKey || 'category';
    unlockFlashcardsMatching(card => {
      if (card.category === categoryKey) return true;
      if (activePracticeContext === 'peds_endo') {
        const categoryTags = normalizeTagList(activeCategoryMap[categoryKey]?.tags);
        const cardTags = normalizeTagList(card?.tags);
        if (categoryTags.some(tag => cardTags.includes(tag))) return true;
      }
      if (card.sourceQuestionId) {
        const q = questionsById.get(card.sourceQuestionId);
        if (isQuestionInCategory(q, categoryKey)) return true;
      }
      if (Array.isArray(card.relatedQuestions)) {
        return card.relatedQuestions.some(id => isQuestionInCategory(questionsById.get(id), categoryKey));
      }
      return false;
    }, `for ${label}`);
  }, [activeCategoryMap, activePracticeContext, isQuestionInCategory, questionsById, unlockFlashcardsMatching]);

  const unlockFlashcardsForTag = useCallback((tag) => {
    const normalized = String(tag || '').trim().toLowerCase();
    if (!normalized) {
      showAlert('Tag Required', 'Enter a tag to unlock flashcards.');
      return;
    }
    unlockFlashcardsMatching(card => {
      const cardTags = Array.isArray(card.tags) ? card.tags.map(t => String(t).toLowerCase()) : [];
      if (cardTags.includes(normalized)) return true;
      if (card.sourceQuestionId) {
        const q = questionsById.get(card.sourceQuestionId);
        const qTags = Array.isArray(q?.tags) ? q.tags.map(t => String(t).toLowerCase()) : [];
        if (qTags.includes(normalized)) return true;
      }
      if (Array.isArray(card.relatedQuestions)) {
        return card.relatedQuestions.some(id => {
          const q = questionsById.get(id);
          const qTags = Array.isArray(q?.tags) ? q.tags.map(t => String(t).toLowerCase()) : [];
          return qTags.includes(normalized);
        });
      }
      return false;
    }, `tagged "${normalized}"`);
  }, [unlockFlashcardsMatching, questionsById]);

  const flashcardStats = useMemo(() => getFlashcardStats(activeFlashcards, srsSettings), [activeFlashcards, srsSettings]);

  const pushUserStats = useCallback(() => {
    if (!user?.uid || isLoading) return;
    const payload = {
      lastActiveAt: new Date().toISOString(),
      stats: {
        reviewed: overallStats.reviewed || 0,
        retention: overallStats.retention || 0,
        mature: overallStats.mature || 0,
        flashcardsDue: flashcardStats.dueToday || 0,
        flashcardsLearned: flashcardStats.learned || 0,
      },
    };
    const last = statsLastSent.current;
    const sameStats = last &&
      last.stats.reviewed === payload.stats.reviewed &&
      last.stats.retention === payload.stats.retention &&
      last.stats.mature === payload.stats.mature &&
      last.stats.flashcardsDue === payload.stats.flashcardsDue &&
      last.stats.flashcardsLearned === payload.stats.flashcardsLearned;
    if (sameStats) return;

    statsLastSent.current = payload;
    updateUserDataInCloud(user.uid, payload).catch(err => {
      console.error('[Users] Failed to sync stats:', err);
    });
  }, [
    user?.uid,
    isLoading,
    overallStats.reviewed,
    overallStats.retention,
    overallStats.mature,
    flashcardStats.dueToday,
    flashcardStats.learned,
  ]);

  useEffect(() => {
    if (!user?.uid || isLoading) return;
    if (statsSyncTimeout.current) clearInterval(statsSyncTimeout.current);
    statsSyncTimeout.current = setInterval(pushUserStats, 15 * 60 * 1000);
    return () => {
      if (statsSyncTimeout.current) clearInterval(statsSyncTimeout.current);
    };
  }, [user?.uid, isLoading, pushUserStats]);

  useEffect(() => {
    if (!user?.uid) return;
    const subscription = AppState.addEventListener('change', (state) => {
      if (state === 'background' || state === 'inactive') {
        pushUserStats();
      }
    });
    return () => subscription.remove();
  }, [user?.uid, pushUserStats]);

  useEffect(() => {
    if (!unlockAllFlashcards || flashcards.length === 0) return;
    if (!flashcards.some(card => card.locked)) return;
    const changed = [];
    const unlocked = flashcards.map(card => {
      if (!card.locked) return card;
      const next = touchFlashcard({ ...card, locked: false });
      changed.push(next);
      return next;
    });
    setFlashcards(unlocked);
    saveFlashcards(unlocked);
    if (user?.uid && changed.length > 0) {
      upsertUserFlashcardsBatch(user.uid, changed).catch(err => {
        console.error('[CloudSync] Failed to sync unlocked flashcards:', err);
      });
    }
  }, [unlockAllFlashcards, flashcards, user?.uid]);

  const missedQuestionIdsForHome = useMemo(() => (
    activeQuestions
      .filter(q => {
        const data = cardData[q.id];
        return data?.attempts > 0 && (data.correct / data.attempts) < 0.6;
      })
      .map(q => q.id)
  ), [activeQuestions, cardData]);

  const activeResources = useMemo(() => (
    activePracticeContext === 'peds_endo'
      ? allResources.filter(isPedsEndoReading)
      : allResources.filter(resource => !isPedsEndoReading(resource))
  ), [allResources, activePracticeContext]);

  const suggestedForYouHome = useMemo(() => {
    const all = getSuggestedReadingForMissedQuestions(activeResources, missedQuestionIdsForHome);
    return all.filter(resource => {
      const entry = readTopics[resource.id];
      if (!entry?.completed) return true;
      if (learningSettings.renewReadingOnMiss) return true;
      const readAt = entry.readAt || 0;
      const hasNewMisses = resource.relevantQuestions.some(qId => {
        const qData = cardData[qId];
        return qData?.lastAttempted > readAt && (qData.correct / qData.attempts) < 0.6;
      });
      return hasNewMisses;
    }).slice(0, 3);
  }, [activeResources, missedQuestionIdsForHome, readTopics, learningSettings.renewReadingOnMiss, cardData]);

  const spacedDueCount = useMemo(() => {
    const questionsWithData = activeQuestions.map(q => ({ ...q, ...cardData[q.id] }));
    return getDueCards(questionsWithData, 100).length;
  }, [activeQuestions, cardData]);

  const questionCountByCategory = useMemo(() => {
    if (activePracticeContext !== 'peds_endo') {
      return activeQuestions.reduce((acc, q) => {
        acc[q.category] = (acc[q.category] || 0) + 1;
        return acc;
      }, {});
    }
    const counts = Object.keys(activeCategoryMap).reduce((acc, key) => {
      acc[key] = 0;
      return acc;
    }, {});
    activeQuestions.forEach(q => {
      const tags = normalizeTagList(q.tags);
      Object.entries(activeCategoryMap).forEach(([key, category]) => {
        const categoryTags = normalizeTagList(category.tags);
        if (categoryTags.some(tag => tags.includes(tag))) {
          counts[key] = (counts[key] || 0) + 1;
        }
      });
    });
    return counts;
  }, [activeQuestions, activePracticeContext, activeCategoryMap]);

  const categorizedResources = useMemo(() => {
    const grouped = {};
    activeResources.forEach(resource => {
      const category = resource.categoryName || resource.category || resource.tags?.[0] || 'General';
      if (!grouped[category]) grouped[category] = [];
      grouped[category].push(resource);
    });
    return grouped;
  }, [activeResources]);

  const categorizedResourceKeys = useMemo(() => (
    Object.keys(categorizedResources).sort()
  ), [categorizedResources]);

  const liveWeaknessAnalysis = useMemo(() => (
    analyzeWeaknesses(cardData, activeQuestions)
  ), [cardData, activeQuestions]);

  const dashboardAnalysis = weaknessAnalysis || liveWeaknessAnalysis;

  const dashboardSuggestedReading = useMemo(() => {
    if (Array.isArray(suggestedReading) && suggestedReading.length > 0) {
      return suggestedReading;
    }
    return getSuggestedReadingForMissedQuestions(
      activeResources,
      dashboardAnalysis?.missedQuestionIds || []
    );
  }, [suggestedReading, activeResources, dashboardAnalysis]);

  const dashboardTrend = useMemo(() => (
    buildRecentSessionTrend(sessionHistory, 7)
  ), [sessionHistory]);

  const dashboardKpis = useMemo(() => {
    const attempts = dashboardAnalysis?.totalAttempts || 0;
    const correct = dashboardAnalysis?.totalCorrect || 0;
    const computedAccuracy = attempts > 0
      ? Math.round((correct / attempts) * 100)
      : (overallStats.retention || 0);

    return {
      accuracy: computedAccuracy,
      attempts,
      dueFlashcards: flashcardStats.dueToday || 0,
      streak: coinData?.loginStreak || 0,
    };
  }, [dashboardAnalysis, overallStats.retention, flashcardStats.dueToday, coinData?.loginStreak]);

  const dashboardBreakdownRows = useMemo(() => {
    const weakCategories = Array.isArray(dashboardAnalysis?.weakCategories)
      ? dashboardAnalysis.weakCategories
      : [];

    if (weakCategories.length > 0) {
      return weakCategories.slice(0, 8).map((item) => ({
        ...item,
        label: activeCategoryMap[item.category]?.name || item.category || 'General',
      }));
    }

    return Object.keys(questionCountByCategory || {})
      .slice(0, 8)
      .map((categoryKey) => ({
        category: categoryKey,
        label: activeCategoryMap[categoryKey]?.name || categoryKey,
        accuracy: null,
        attempts: 0,
        correct: 0,
        questionCount: questionCountByCategory[categoryKey] || 0,
      }));
  }, [dashboardAnalysis, activeCategoryMap, questionCountByCategory]);

  const reviewCounts = useMemo(() => {
    const correct = testAnswers.filter(a => a.isCorrect).length;
    return { all: testAnswers.length, correct, incorrect: testAnswers.length - correct };
  }, [testAnswers]);

  const sortedSavedSessions = useMemo(() => (
    [...savedSessions].sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))
  ), [savedSessions]);

  const filteredReviewAnswers = useMemo(() => (
    testAnswers
      .map((answer, idx) => ({ ...answer, originalIndex: idx }))
      .filter(answer => {
        if (reviewFilter === 'correct') return answer.isCorrect;
        if (reviewFilter === 'incorrect') return !answer.isCorrect;
        return true;
      })
  ), [testAnswers, reviewFilter]);

  const handleSelectReview = useCallback((index) => {
    setSelectedReviewIndex(index);
  }, [setSelectedReviewIndex]);

  const handleViewResource = useCallback((resource) => {
    viewResource(resource);
  }, [viewResource]);

  const missedIdsForResults = useMemo(() => (
    testAnswers.filter(a => !a.isCorrect).map(a => a.questionId)
  ), [testAnswers]);

  const missedOrDifficultIdsForResults = useMemo(() => {
    const ids = new Set();
    testAnswers.forEach(answer => {
      if (!answer?.questionId) return;
      if (!answer.isCorrect || cardData[answer.questionId]?.markedDifficult) {
        ids.add(answer.questionId);
      }
    });
    return Array.from(ids);
  }, [testAnswers, cardData]);

  const missedOrDifficultIdsOverall = useMemo(() => (
    Object.entries(cardData)
      .filter(([id, data]) => {
        if (!activeQuestionIdSet.has(id) || !data) return false;
        const attempts = data.attempts || 0;
        const incorrect = data.incorrect || 0;
        return data.markedDifficult || (attempts > 0 && incorrect > 0);
      })
      .map(([id]) => id)
  ), [cardData, activeQuestionIdSet]);

  const missingFlashcardQuestionsForResults = useMemo(() => (
    getMissingFlashcardQuestions(missedOrDifficultIdsForResults, activeFlashcards, activeQuestions)
  ), [missedOrDifficultIdsForResults, activeFlashcards, activeQuestions]);

  const sessionReadingResults = useMemo(() => (
    getSuggestedReadingForMissedQuestions(activeResources, missedIdsForResults).slice(0, 3)
  ), [activeResources, missedIdsForResults]);


  // Render home screen
  const renderHome = () => {
    const isManager = userRole === 'manager' || userRole === 'admin';
    const showPetFeatures = learningSettings.showPetFeatures !== false;
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <ScrollView contentContainerStyle={styles.scrollContent} style={noSelectStyle}>
            <View style={styles.header}>
              <View style={styles.headerRow}>
                <View>
                  <Text style={[styles.title, { color: theme.text }]}>StudyPet</Text>
                  <Text style={[styles.subtitle, { color: theme.subtext }]}>Evidence-Based Learning</Text>
                </View>
                <View style={styles.headerRight}>
                  {/* Coin Display */}
                  <TouchableOpacity
                    style={[styles.coinDisplay, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => {
                      if (showPetFeatures) {
                        setScreen('pet');
                      } else {
                        showAlert('Pet Features Hidden', 'Enable pet features in Settings to view your pet.');
                      }
                    }}
                  >
                    <Ionicons name="wallet-outline" size={18} color="#FFD700" />
                    <Text style={[styles.coinText, { color: theme.text }]}>{formatCoins(coinData?.balance || 0)}</Text>
                  </TouchableOpacity>
                </View>
              </View>
              {/* User Account Bar */}
              <View style={[styles.accountBar, { backgroundColor: theme.card, borderColor: theme.border, borderWidth: 1 }]}>
                <View style={styles.accountInfo}>
                  <Ionicons name="person-circle-outline" size={20} color="#4CAF50" />
                  <Text style={[styles.accountEmail, { color: theme.subtext }]} numberOfLines={1}>
                    {user?.displayName || user?.email || 'User'}
                  </Text>
                  <Ionicons name="cloud-done-outline" size={16} color="#4CAF50" style={styles.syncIcon} />
                </View>
                <TouchableOpacity
                  style={[styles.settingsButton, { backgroundColor: theme.surfaceAlt }]}
                  onPress={() => setScreen('settings')}
                >
                  <Ionicons name="settings-outline" size={22} color={theme.subtext} />
                </TouchableOpacity>
              </View>
            </View>

            {(isLocalHydrating || isContentHydrating) && (
              <View style={[styles.startupBanner, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}>
                <View style={styles.startupBannerRow}>
                  <Ionicons name="time-outline" size={18} color={theme.text} />
                  <Text style={[styles.startupBannerTitle, { color: theme.text }]}>
                    Loading data in background
                  </Text>
                </View>
                <Text style={[styles.startupBannerText, { color: theme.subtext }]}>
                  {isLocalHydrating && isContentHydrating
                    ? 'Restoring saved progress and fetching new content.'
                    : isLocalHydrating
                      ? 'Restoring saved progress from this device.'
                      : 'Fetching latest questions, readings, and flashcards.'}
                </Text>
              </View>
            )}

            {/* Stats Card */}
            <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.statsTitle, { color: theme.progressTitle }]}>Your Progress</Text>
              <View style={styles.statsRow}>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: theme.text }]}>{overallStats.reviewed}</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Reviewed</Text>
                </View>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: theme.text }]}>{overallStats.retention}%</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Retention</Text>
                </View>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: theme.text }]}>{overallStats.mature}</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Mastered</Text>
                </View>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: theme.text }]}>{activeQuestions.length}</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Total</Text>
                </View>
              </View>
            </View>

            {/* Flashcard Stats Card */}
            {activeFlashcards.length > 0 && (
              <TouchableOpacity
                style={[styles.statsCard, { backgroundColor: theme.card }]}
                onPress={() => {
                  if (flashcardStats.dueToday > 0) {
                    startFlashcardSession();
                  } else {
                    showAlert('All Caught Up!', "You're all caught up. Great work!");
                  }
                }}
              >
                <Text style={[styles.statsTitle, { color: theme.flashcardsTitle }]}>Flashcards</Text>
                <View style={styles.statsRow}>
                  <View style={styles.statItem}>
                    <Text style={[styles.statNumber, { color: '#E91E63' }]}>{flashcardStats.dueToday}</Text>
                    <Text style={[styles.statLabel, { color: theme.subtext }]}>Due Today</Text>
                  </View>
                  <View style={styles.statItem}>
                    <Text style={[styles.statNumber, { color: theme.text }]}>{flashcardStats.learning}</Text>
                    <Text style={[styles.statLabel, { color: theme.subtext }]}>Learning</Text>
                  </View>
                  <View style={styles.statItem}>
                    <Text style={[styles.statNumber, { color: theme.text }]}>{flashcardStats.learned}</Text>
                    <Text style={[styles.statLabel, { color: theme.subtext }]}>Mature</Text>
                  </View>
                  <View style={styles.statItem}>
                    <Text style={[styles.statNumber, { color: '#4CAF50' }]}>{flashcardStats.unlocked}</Text>
                    <Text style={[styles.statLabel, { color: theme.subtext }]}>Unlocked</Text>
                  </View>
                </View>
                {flashcardStats.suspended > 0 && (
                  <Text style={[styles.suspendedNote, { color: theme.subtext }]}>
                    {flashcardStats.suspended} card{flashcardStats.suspended !== 1 ? 's' : ''} suspended
                  </Text>
                )}
              </TouchableOpacity>
            )}

            {showPetFeatures && (
              <TouchableOpacity
                style={[styles.statsCard, styles.petWidgetCard, { backgroundColor: theme.card }]}
                onPress={() => setScreen('pet')}
              >
                <View style={styles.petWidgetContent}>
                  {petData?.pets?.length > 0 ? (
                    <>
                      {(() => {
                        const activePet = petData.pets.find(p => p.id === selectedPetId) || petData.pets[0];
                        const displayInfo = getPetDisplayInfo(activePet);
                        return (
                          <>
                            <View style={styles.petWidgetLeft}>
                              <PetSprite
                                speciesId={activePet.speciesId}
                                stage={activePet.stage}
                                size={46}
                                moodColor={displayInfo.mood.color}
                                themeOverride={theme}
                                petId={activePet.id}
                                eggGroup={activePet.eggGroup}
                              />
                              <View style={[styles.petMoodDot, { backgroundColor: displayInfo.mood.color }]} />
                            </View>
                            <View style={styles.petWidgetInfo}>
                              <Text style={[styles.petWidgetName, { color: theme.text }]}>{displayInfo.name}</Text>
                              <Text style={[styles.petWidgetStage, { color: theme.subtext }]}>{displayInfo.stageName} {displayInfo.speciesName}</Text>
                              <View style={styles.petXPBar}>
                                <View style={[styles.petXPFill, { width: `${displayInfo.xpProgress.percentage}%` }]} />
                              </View>
                            </View>
                            <Ionicons name="chevron-forward" size={24} color={theme.subtext} />
                          </>
                        );
                      })()}
                    </>
                  ) : (
                    <>
                      <View style={styles.petWidgetLeft}>
                        <PetSprite
                          speciesId={PET_SPECIES.mystery.id}
                          stage={PET_STAGES.EGG}
                          size={46}
                          themeOverride={theme}
                          style={{ marginRight: 2 }}
                          petId="preview_egg"
                        />
                      </View>
                      <View style={styles.petWidgetInfo}>
                        <Text style={[styles.petWidgetName, { color: theme.text }]}>Get Your Free Pet!</Text>
                        <Text style={[styles.petWidgetStage, { color: theme.subtext }]}>Tap to claim your first egg</Text>
                      </View>
                      <Ionicons name="gift-outline" size={24} color="#4CAF50" />
                    </>
                  )}
                </View>
              </TouchableOpacity>
            )}

            {showPetFeatures && (
              <TouchableOpacity
                style={[styles.statsCard, { backgroundColor: theme.card }]}
                onPress={() => setScreen('battle')}
              >
                <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
                  <View>
                    <Text style={[styles.statsTitle, { color: '#7C4DFF' }]}>Battle Arena</Text>
                    <Text style={[styles.statLabel, { color: theme.subtext }]}>
                      PvE mode with cooldown + progression rewards
                    </Text>
                  </View>
                  <Ionicons name="shield-outline" size={30} color="#7C4DFF" />
                </View>
              </TouchableOpacity>
            )}

            {assignedExams.length > 0 && (
              <>
                <View style={[styles.sectionHeader, { marginTop: 24 }]}>
                  <View style={[styles.sectionHeaderIcon, { backgroundColor: 'rgba(124, 77, 255, 0.15)' }]}>
                    <Ionicons name="clipboard-outline" size={20} color="#7C4DFF" />
                  </View>
                  <Text style={[styles.sectionTitle, { color: theme.text }]}>Assigned Exams</Text>
                </View>
                <Text style={[styles.sectionSubtitle, { color: theme.subtext }]}>Assignments from instructors or chiefs</Text>

                {assignedExams.map(assignment => {
                  const dueLabel = formatAssignmentDate(assignment.dueDate);
                  const status = assignment.status || 'assigned';
                  const statusColor = status === 'completed' ? '#4CAF50' : status === 'started' ? '#FF9800' : '#7C4DFF';
                  return (
                    <View key={assignment.id} style={[styles.assignedExamCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
                      <View style={styles.assignedExamInfo}>
                        <Text style={[styles.assignedExamTitle, { color: theme.text }]} numberOfLines={1}>
                          {assignment.title || 'Assigned Exam'}
                        </Text>
                        <Text style={[styles.assignedExamMeta, { color: theme.subtext }]}>
                          {dueLabel ? `Due ${dueLabel}` : 'No due date'}
                        </Text>
                        {assignment.score?.total ? (
                          <Text style={[styles.assignedExamMeta, { color: theme.subtext }]}>
                            Score {assignment.score.correct}/{assignment.score.total} ({assignment.score.percentage || 0}%)
                          </Text>
                        ) : null}
                      </View>
                      <View style={styles.assignedExamActions}>
                        <View style={[styles.assignedExamStatus, { backgroundColor: statusColor + '20' }]}>
                          <Text style={[styles.assignedExamStatusText, { color: statusColor }]}>{status}</Text>
                        </View>
                        <TouchableOpacity
                          style={[styles.assignedExamButton, { backgroundColor: theme.surfaceAlt }]}
                          onPress={() => startAssignedExam(assignment)}
                        >
                          <Text style={[styles.assignedExamButtonText, { color: theme.text }]}>
                            {status === 'completed' ? 'Review' : status === 'started' ? 'Resume' : 'Start'}
                          </Text>
                        </TouchableOpacity>
                      </View>
                    </View>
                  );
                })}

              </>
            )}

            {/* ========== PRACTICE TESTS SECTION ========== */}
            <View style={styles.sectionHeader}>
              <View style={styles.sectionHeaderIcon}>
                <Ionicons name="document-text-outline" size={20} color="#4CAF50" />
              </View>
              <Text style={[styles.sectionTitle, { color: theme.text }]}>Practice Tests</Text>
            </View>
            <Text style={[styles.sectionSubtitle, { color: theme.subtext }]}>Question-based practice sessions</Text>

            {sortedSavedSessions.length > 0 && (
              <View style={[styles.savedSessionsCard, { backgroundColor: theme.card }]}>
                <View style={styles.savedSessionsHeader}>
                  <Text style={[styles.savedSessionsTitle, { color: theme.text }]}>Saved Sessions</Text>
                  <Text style={[styles.savedSessionsCount, { color: theme.subtext }]}>{sortedSavedSessions.length}/{MAX_SAVED_SESSIONS}</Text>
                </View>
                {sortedSavedSessions.slice(0, 5).map(session => (
                  <View key={session.id} style={[styles.savedSessionRow, { borderColor: theme.border }]}>
                    <View style={styles.savedSessionInfo}>
                      <Text style={[styles.savedSessionName, { color: theme.text }]} numberOfLines={1}>
                        {session.modeName || 'Practice Session'}
                      </Text>
                      <Text style={[styles.savedSessionMeta, { color: theme.subtext }]}>
                        {session.currentIndex + 1} / {session.questionIds?.length || 0}  {new Date(session.updatedAt || Date.now()).toLocaleDateString()}
                      </Text>
                      {(session.categories?.length || session.focusTags?.length || session.focusFilter) ? (
                        <Text style={[styles.savedSessionTags, { color: theme.subtext }]} numberOfLines={1}>
                          {session.categories?.length ? `Cats: ${session.categories.join(', ')}` : ''}{session.categories?.length && (session.focusTags?.length || session.focusFilter) ? '  ' : ''}{session.focusTags?.length ? `Focus: ${session.focusTags.join(', ')}` : ''}{session.focusTags?.length && session.focusFilter ? '  ' : ''}{session.focusFilter && session.focusFilter !== 'all' ? `Filter: ${session.focusFilter}` : ''}
                        </Text>
                      ) : null}
                    </View>
                    <View style={styles.savedSessionActions}>
                      <TouchableOpacity
                        style={[styles.savedSessionButton, { backgroundColor: theme.surfaceAlt }]}
                        onPress={() => resumeSavedSession(session)}
                      >
                        <Text style={[styles.savedSessionButtonText, { color: theme.text }]}>Resume</Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.savedSessionButton, { backgroundColor: 'rgba(244,67,54,0.15)' }]}
                        onPress={() => removeSavedSession(session.id)}
                      >
                        <Text style={[styles.savedSessionButtonText, { color: '#F44336' }]}>Delete</Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                ))}
                {sortedSavedSessions.length > 5 && (
                  <Text style={[styles.savedSessionsMore, { color: theme.subtext }]}>
                    +{sortedSavedSessions.length - 5} more saved session{sortedSavedSessions.length - 5 !== 1 ? 's' : ''}
                  </Text>
                )}
              </View>
            )}

            <TouchableOpacity
              style={[styles.modeCard, { backgroundColor: theme.card }]}
              onPress={() => setShowCustomTestModal(true)}
            >
              <View style={[styles.modeIcon, { backgroundColor: 'rgba(255, 183, 77, 0.2)' }]}>
                <Ionicons name="options-outline" size={28} color="#FFB74D" />
              </View>
              <View style={styles.modeContent}>
                <Text style={[styles.modeName, { color: theme.text }]}>Custom Test</Text>
                <Text style={[styles.modeDescription, { color: theme.subtext }]}>
                  Build a test from tags or subtopics
                </Text>
              </View>
              <Ionicons name="chevron-forward" size={24} color={theme.subtext} />
            </TouchableOpacity>

            {Object.values(PRACTICE_TEST_MODES).map(mode => (
              <TouchableOpacity
                key={mode.id}
                style={[styles.modeCard, { backgroundColor: theme.card }]}
                onPress={() => {
                  if (mode.id === 'category') {
                    setScreen('categories');
                  } else {
                    startSession(mode);
                  }
                }}
              >
                <View style={[styles.modeIcon, { backgroundColor: mode.color + '20' }]}>
                  <Ionicons name={mode.icon} size={28} color={mode.color} />
                </View>
                <View style={styles.modeContent}>
                  <Text style={[styles.modeName, { color: theme.text }]}>{mode.name}</Text>
                  <Text style={[styles.modeDescription, { color: theme.subtext }]}>{mode.description}</Text>
                </View>
                <Ionicons name="chevron-forward" size={24} color={theme.subtext} />
              </TouchableOpacity>
            ))}

            {/* ========== REVIEW SECTION ========== */}
            <View style={[styles.sectionHeader, { marginTop: 24 }]}>
              <View style={[styles.sectionHeaderIcon, { backgroundColor: 'rgba(233, 30, 99, 0.15)' }]}>
                <Ionicons name="repeat-outline" size={20} color="#E91E63" />
              </View>
              <Text style={[styles.sectionTitle, { color: theme.text }]}>Review & Memorize</Text>
            </View>
            <Text style={[styles.sectionSubtitle, { color: theme.subtext }]}>Spaced repetition for long-term retention</Text>

              {Object.values(REVIEW_MODES).map(mode => {
                // Show flashcard count badge
                const showBadge = mode.id === 'flashcards' && activeFlashcards.length > 0;
                const dueCount = showBadge ? flashcardStats.dueToday : 0;
                // Show spaced review badge
                const showSpacedBadge = mode.id === 'spaced';
                const spacedDue = showSpacedBadge ? spacedDueCount : 0;

              return (
                <TouchableOpacity
                  key={mode.id}
                  style={[styles.modeCard, { backgroundColor: theme.card }]}
                  onPress={() => startSession(mode)}
                >
                  <View style={[styles.modeIcon, { backgroundColor: mode.color + '20' }]}>
                    <Ionicons name={mode.icon} size={28} color={mode.color} />
                  </View>
                  <View style={styles.modeContent}>
                    <View style={styles.modeNameRow}>
                      <Text style={[styles.modeName, { color: theme.text }]}>{mode.name}</Text>
                      {showBadge && dueCount > 0 && (
                        <View style={styles.dueBadge}>
                          <Text style={styles.dueBadgeText}>{dueCount} due</Text>
                        </View>
                      )}
                      {showSpacedBadge && spacedDue > 0 && (
                        <View style={[styles.dueBadge, { backgroundColor: '#00BCD4' }]}>
                          <Text style={styles.dueBadgeText}>{spacedDue} due</Text>
                        </View>
                      )}
                    </View>
                    <Text style={[styles.modeDescription, { color: theme.subtext }]}>{mode.description}</Text>
                  </View>
                  <Ionicons name="chevron-forward" size={24} color={theme.subtext} />
                </TouchableOpacity>
              );
            })}

            {/* ========== STUDY TOPICS SECTION ========== */}
            <View style={[styles.sectionHeader, { marginTop: 24 }]}>
              <View style={[styles.sectionHeaderIcon, { backgroundColor: 'rgba(0, 188, 212, 0.15)' }]}>
                <Ionicons name="book-outline" size={20} color="#00BCD4" />
              </View>
              <Text style={[styles.sectionTitle, { color: theme.text }]}>Study Topics</Text>
            </View>
            <Text style={[styles.sectionSubtitle, { color: theme.subtext }]}>Reading materials and study notes</Text>

            {/* Suggested Reading based on weak areas */}
            {suggestedForYouHome.length > 0 && (
              <View style={[styles.suggestedReadingCard, { backgroundColor: theme.surfaceAlt }]}>
                <View style={styles.suggestedReadingHeader}>
                  <Ionicons name="bulb-outline" size={18} color="#FF9800" />
                  <Text style={styles.suggestedReadingTitle}>Recommended for You</Text>
                </View>
                {suggestedForYouHome.map((resource, idx) => (
                  <TouchableOpacity
                    key={resource.id || idx}
                    style={[styles.suggestedReadingItem, { borderTopColor: theme.border }]}
                    onPress={() => viewResource(resource)}
                  >
                    <View style={[styles.suggestedReadingIcon, { backgroundColor: theme.surfaceAlt }]}>
                      <Ionicons
                        name={resource.type === RESOURCE_TYPES.CUSTOM_NOTE ? 'document-text' :
                              resource.type === RESOURCE_TYPES.PUBMED ? 'link' : 'book'}
                        size={18}
                        color="#00BCD4"
                      />
                    </View>
                    <View style={styles.suggestedReadingContent}>
                      <Text style={[styles.suggestedReadingItemTitle, { color: theme.text }]} numberOfLines={2}>
                        {resource.title}
                      </Text>
                      {resource.readingTime && (
                        <Text style={[styles.suggestedReadingMeta, { color: theme.subtext }]}>{resource.readingTime} min read</Text>
                      )}
                    </View>
                    <Ionicons name="chevron-forward" size={16} color={theme.subtext} />
                  </TouchableOpacity>
                ))}
              </View>
            )}

            {/* Browse All Topics */}
            <TouchableOpacity
              style={[styles.browseTopicsCard, { backgroundColor: theme.card }]}
              onPress={() => setScreen('topics')}
            >
              <View style={[styles.browseTopicsIcon, { backgroundColor: theme.surfaceAlt }]}>
                <Ionicons name="library-outline" size={28} color="#00BCD4" />
              </View>
              <View style={styles.browseTopicsContent}>
                <Text style={[styles.browseTopicsTitle, { color: theme.text }]}>Browse All Topics</Text>
                <Text style={[styles.browseTopicsDesc, { color: theme.subtext }]}>
                  {activeResources.length} study materials available
                </Text>
              </View>
              <Ionicons name="chevron-forward" size={24} color={theme.subtext} />
            </TouchableOpacity>

            {/* Content Status removed */}

            {isManager && (
              <>
                <View style={[styles.sectionHeader, { marginTop: 24 }]}>
                  <View style={[styles.sectionHeaderIcon, { backgroundColor: 'rgba(124, 77, 255, 0.15)' }]}>
                    <Ionicons name="send-outline" size={20} color="#7C4DFF" />
                  </View>
                  <Text style={[styles.sectionTitle, { color: theme.text }]}>Manager Tools</Text>
                </View>
                <Text style={[styles.sectionSubtitle, { color: theme.subtext }]}>Assignments and oversight</Text>

                <TouchableOpacity
                  style={[styles.modeCard, { backgroundColor: theme.card }]}
                  onPress={() => setShowAssignExamModal(true)}
                >
                  <View style={[styles.modeIcon, { backgroundColor: 'rgba(124, 77, 255, 0.2)' }]}>
                    <Ionicons name="send-outline" size={28} color="#7C4DFF" />
                  </View>
                  <View style={styles.modeContent}>
                    <Text style={[styles.modeName, { color: theme.text }]}>Assign Exam</Text>
                    <Text style={[styles.modeDescription, { color: theme.subtext }]}>
                      Send a test to a user by email
                    </Text>
                  </View>
                  <Ionicons name="chevron-forward" size={24} color={theme.subtext} />
                </TouchableOpacity>
              </>
            )}
          </ScrollView>
        </LinearGradient>

        {/* Add Card Modal */}
        {showAddCardModal && (
          <Pressable
            style={styles.modalOverlay}
            onPress={() => {
              setShowAddCardModal(false);
              setNewCardText('');
            }}
          >
            <KeyboardAvoidingView
              behavior={Platform.OS === 'ios' ? 'padding' : undefined}
              style={styles.modalKeyboardAvoiding}
            >
              <Pressable style={[styles.modalContent, styles.modalScrollableContent]} onPress={() => {}}>
                <ScrollView contentContainerStyle={styles.modalScrollContent} keyboardShouldPersistTaps="handled">
                  <Text style={styles.modalTitle}>Create Cloze Card</Text>
                  <Text style={styles.modalSubtitle}>
                    Use {'{{c::answer}}'} to mark the hidden part
                  </Text>
                  <TextInput
                    style={styles.modalInput}
                    multiline
                    placeholder="The {{c::internal nasal valve}} is formed by the junction of the upper lateral cartilage and septum."
                    placeholderTextColor="#666"
                    value={newCardText}
                    onChangeText={setNewCardText}
                  />
                  <View style={styles.modalButtons}>
                    <TouchableOpacity
                      style={styles.modalButtonCancel}
                      onPress={() => {
                        setShowAddCardModal(false);
                        setNewCardText('');
                      }}
                    >
                      <Text style={styles.modalButtonCancelText}>Cancel</Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={styles.modalButtonSave}
                      onPress={addManualFlashcard}
                    >
                      <Text style={styles.modalButtonSaveText}>Create Card</Text>
                    </TouchableOpacity>
                  </View>
                </ScrollView>
              </Pressable>
            </KeyboardAvoidingView>
          </Pressable>
        )}

        {/* Mode Selection Modal (Test vs Tutor) */}
        {showModeSelection && pendingModeSession && (
          <Pressable
            style={styles.modalOverlay}
            onPress={() => {
              setShowModeSelection(false);
              setPendingModeSession(null);
            }}
          >
            <Pressable
              style={[styles.modalContent, { backgroundColor: theme.card, borderColor: theme.border }]}
              onPress={() => {}}
            >
              <Text style={[styles.modalTitle, { color: theme.text }]}>Select Mode</Text>
              <Text style={[styles.modalSubtitle, { color: theme.subtext }]}>
                Choose how you want to practice
              </Text>

              {/* Question Count Selector (for Quick Test only) */}
              {pendingModeSession.id === 'timed' && (
                <View style={[styles.questionCountSection, { backgroundColor: theme.surfaceAlt }]}>
                  <Text style={[styles.questionCountLabel, { color: theme.text }]}>Number of Questions</Text>
                  <View style={styles.questionCountOptions}>
                    {[10, 25, 50, 100].map((count) => (
                      <TouchableOpacity
                        key={count}
                        style={[
                          styles.questionCountButton,
                          quickTestQuestionCount === count && styles.questionCountButtonActive
                        ]}
                        onPress={() => setQuickTestQuestionCount(count)}
                      >
                        <Text style={[
                          styles.questionCountText,
                          { color: theme.subtext },
                          quickTestQuestionCount === count && styles.questionCountTextActive
                        ]}>
                          {count}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                </View>
              )}

              <Text style={[styles.formLabel, { color: theme.subtext }]}>Question Focus</Text>
              <View style={[styles.focusRow, { marginLeft: 0 }]}>
                {[
                  { id: 'all', label: 'All' },
                  { id: 'unseen', label: 'Unseen' },
                  { id: 'missed', label: 'Missed' },
                  { id: 'danger', label: 'Danger' },
                ].map(option => {
                  const selected = focusFilter === option.id;
                  return (
                    <TouchableOpacity
                      key={option.id}
                      style={[
                        styles.focusPill,
                        { borderColor: theme.border },
                        selected && styles.focusPillActive
                      ]}
                      onPress={() => setFocusFilter(option.id)}
                    >
                      <Text style={[
                        styles.focusText,
                        { color: selected ? theme.text : theme.subtext }
                      ]}>
                        {option.label}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </View>

              {/* Tutor Mode - Always Untimed */}
              <TouchableOpacity
                style={[styles.modeSelectionOption, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}
                onPress={() => confirmModeAndStart('tutor', false)}
              >
                <View style={[styles.modeSelectionIcon, { backgroundColor: 'rgba(76, 175, 80, 0.15)' }]}>
                  <Ionicons name="school-outline" size={28} color="#4CAF50" />
                </View>
                <View style={styles.modeSelectionInfo}>
                  <Text style={[styles.modeSelectionTitle, { color: theme.text }]}>Tutor Mode</Text>
                  <Text style={[styles.modeSelectionDesc, { color: theme.subtext }]}>
                    See explanation after each question. Untimed. Great for learning.
                  </Text>
                </View>
              </TouchableOpacity>

              {/* Test Mode - Timed */}
              <TouchableOpacity
                style={[styles.modeSelectionOption, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}
                onPress={() => confirmModeAndStart('test', true)}
              >
                <View style={[styles.modeSelectionIcon, { backgroundColor: 'rgba(156, 39, 176, 0.15)' }]}>
                  <Ionicons name="timer-outline" size={28} color="#9C27B0" />
                </View>
                <View style={styles.modeSelectionInfo}>
                  <Text style={[styles.modeSelectionTitle, { color: theme.text }]}>Test Mode (Timed)</Text>
                  <Text style={[styles.modeSelectionDesc, { color: theme.subtext }]}>
                    Exam simulation with timer. Review answers at the end.
                  </Text>
                </View>
              </TouchableOpacity>

              {/* Test Mode - Untimed */}
              <TouchableOpacity
                style={[styles.modeSelectionOption, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}
                onPress={() => confirmModeAndStart('test', false)}
              >
                <View style={[styles.modeSelectionIcon, { backgroundColor: 'rgba(255, 152, 0, 0.15)' }]}>
                  <Ionicons name="document-text-outline" size={28} color="#FF9800" />
                </View>
                <View style={styles.modeSelectionInfo}>
                  <Text style={[styles.modeSelectionTitle, { color: theme.text }]}>Test Mode (Untimed)</Text>
                  <Text style={[styles.modeSelectionDesc, { color: theme.subtext }]}>
                    No timer. Review all answers at the end.
                  </Text>
                </View>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButtonCancel, { borderColor: theme.border }]}
                onPress={() => {
                  setShowModeSelection(false);
                  setPendingModeSession(null);
                }}
              >
                <Text style={[styles.modalButtonCancelText, { color: theme.subtext }]}>Cancel</Text>
              </TouchableOpacity>
            </Pressable>
          </Pressable>
        )}
      </SafeAreaView>
    );
  };

  // Render category selection
  const renderCategories = () => (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
      <StatusBar style={theme.statusBar} />
      <LinearGradient colors={theme.bg} style={styles.gradient}>
        <View style={styles.navHeader}>
          <TouchableOpacity onPress={() => setScreen('home')}>
            <Ionicons name="arrow-back" size={28} color={theme.text} />
          </TouchableOpacity>
          <Text style={[styles.navTitle, { color: theme.text }]}>Select Category</Text>
          <View style={{ width: 28 }} />
        </View>

        <ScrollView contentContainerStyle={styles.scrollContent}>
          <Text style={[styles.formLabel, { color: theme.subtext }]}>Question Focus</Text>
          <View style={[styles.focusRow, { marginLeft: 0 }]}>
            {[
              { id: 'all', label: 'All' },
              { id: 'unseen', label: 'Unseen' },
              { id: 'missed', label: 'Missed' },
              { id: 'danger', label: 'Danger' },
            ].map(option => {
              const selected = focusFilter === option.id;
              return (
                <TouchableOpacity
                  key={option.id}
                  style={[
                    styles.focusPill,
                    { borderColor: theme.border },
                    selected && styles.focusPillActive
                  ]}
                  onPress={() => setFocusFilter(option.id)}
                >
                  <Text style={[
                    styles.focusText,
                    { color: selected ? theme.text : theme.subtext }
                  ]}>
                    {option.label}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>
            {Object.entries(activeCategoryMap).map(([key, category]) => {
            const questionCount = questionCountByCategory[key] || 0;
            const hasQuestions = questionCount > 0;

            return (
              <TouchableOpacity
                key={key}
                style={[
                  styles.categoryCard,
                  { backgroundColor: theme.card },
                  !hasQuestions && styles.categoryCardDisabled
                ]}
                onPress={() => hasQuestions && startSession(PRACTICE_MODES.CATEGORY, key)}
                disabled={!hasQuestions}
              >
                <View style={styles.categoryHeader}>
                  <Text style={[styles.categoryName, { color: theme.text }]}>{category.name}</Text>
                  <Text style={[styles.categoryCount, !hasQuestions && { color: '#666' }]}>
                    {questionCount} questions
                  </Text>
                </View>
                <View style={styles.subcategoryWrap}>
                  {category.subcategories.slice(0, 4).map((sub, idx) => (
                    <Text
                      key={idx}
                      style={[
                        styles.subcategoryTag,
                        { backgroundColor: theme.surfaceAlt, color: theme.subtext }
                      ]}
                    >
                      {sub}
                    </Text>
                  ))}
                  {category.subcategories.length > 4 && (
                    <Text style={[styles.subcategoryMore, { color: theme.subtext }]}>+{category.subcategories.length - 4}</Text>
                  )}
                </View>
                {!hasQuestions && (
                  <Text style={styles.comingSoonBadge}>Coming Soon</Text>
                )}
              </TouchableOpacity>
            );
          })}
        </ScrollView>
      </LinearGradient>
    </SafeAreaView>
  );

  // Render question screen
  const renderQuestion = () => {
    const question = questions[currentIndex];
    if (!question) return null;

    const wasIncorrect = selectedAnswer !== null && !shuffledOptions[selectedAnswer]?.isCorrect;
    const missingFlashcardForCurrent = wasIncorrect
      ? getMissingFlashcardQuestions([question.id], activeFlashcards, activeQuestions)
      : [];
    const immediateFeedbackText = learningSettings.immediateFeedback ? getImmediateFeedbackText(question) : null;
    const showConfidencePrompt = learningSettings.confidenceRatings
      && pendingConfidenceMeta?.questionId === question.id;

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          {/* Header */}
          <View style={styles.questionHeader}>
            <TouchableOpacity onPress={() => setShowEndSessionModal(true)}>
              <Ionicons name="close" size={28} color={theme.text} />
            </TouchableOpacity>

            <View style={styles.progressContainer}>
              <Text style={[styles.progressText, { color: theme.text }]}>
                {currentIndex + 1} / {questions.length}
              </Text>
              {timeRemaining !== null && (
                <Text style={[styles.timerText, timeRemaining < 120 && { color: '#f44336' }]}>
                  {formatTime(timeRemaining)}
                </Text>
              )}
            </View>

            <View style={styles.questionHeaderRight}>
              {userRole === 'admin' && (
                <TouchableOpacity
                  style={styles.questionHeaderIconButton}
                  onPress={() => openAdminEdit('question', question)}
                  accessibilityLabel="Edit question"
                >
                  <Ionicons name="pencil-outline" size={18} color="#4f8cff" />
                </TouchableOpacity>
              )}
              <TouchableOpacity
                style={styles.questionHeaderIconButton}
                onPress={() => openReportModal('question', question.id)}
                accessibilityLabel="Report question"
              >
                <Ionicons name="flag-outline" size={18} color={theme.subtext} />
              </TouchableOpacity>
              <View style={styles.scoreContainer}>
                <Text style={styles.scoreCorrect}>{sessionStats.correct}</Text>
                <Text style={[styles.scoreDivider, { color: theme.subtext }]}>|</Text>
                <Text style={styles.scoreIncorrect}>{sessionStats.incorrect}</Text>
              </View>
            </View>
          </View>

          {/* Progress Bar */}
          <View style={[styles.progressBar, { backgroundColor: theme.progressTrack }]}>
            <View
              style={[
                styles.progressFill,
                { width: `${((currentIndex + 1) / questions.length) * 100}%` }
              ]}
            />
          </View>

          <ScrollView style={[styles.questionContent, noSelectStyle]}>
            {/* Category Badge */}
            <View style={styles.categoryBadgeRow}>
              <View style={[styles.categoryBadge, { backgroundColor: theme.badgeBg }]}>
                <Text style={[styles.categoryBadgeText, { color: theme.badgeText }]}>
                  {getCategoryLabelForQuestion(question)}
                </Text>
              </View>
              {question.subcategory && (
                <View style={[styles.categoryBadge, { backgroundColor: theme.badgeBg }]}>
                  <Text style={[styles.categoryBadgeText, { color: theme.badgeText }]}>{question.subcategory}</Text>
                </View>
              )}
              {question.difficulty && (
                <View style={[styles.categoryBadge, {
                  backgroundColor: question.difficulty === 'basic' ? '#4CAF50' :
                                  question.difficulty === 'intermediate' ? '#FF9800' : '#f44336'
                }]}>
                  <Text style={[styles.categoryBadgeText, { color: theme.badgeText }]}>{question.difficulty}</Text>
                </View>
              )}
            </View>

            {/* Question Stem */}
            <Text style={[styles.questionStem, { color: theme.text }]}>{question.stem}</Text>

            {/* Lead-in */}
            <View style={[styles.leadInBox, { backgroundColor: theme.surfaceAlt, borderLeftColor: theme.badgeBg }]}>
              <Text style={[styles.questionLeadIn, { color: theme.textSecondary }]}>{question.leadIn}</Text>
            </View>

            {/* Options */}
            <View style={styles.optionsContainer}>
              {shuffledOptions.map((option, idx) => {
                const isSelected = selectedAnswer === idx;
                const showResult = selectedAnswer !== null;
                const isCorrect = option.isCorrect;

                let optionStyle = [styles.option, { backgroundColor: theme.optionBg, borderColor: theme.optionBorder }];
                let letterStyle = [styles.optionLetter, { backgroundColor: theme.optionLetterBg }];

                if (showResult) {
                  if (isCorrect) {
                    optionStyle.push(styles.optionCorrect);
                    letterStyle.push(styles.letterCorrect);
                  } else if (isSelected && !isCorrect) {
                    optionStyle.push(styles.optionIncorrect);
                    letterStyle.push(styles.letterIncorrect);
                  }
                } else if (isSelected) {
                  optionStyle.push(styles.optionSelected);
                }

                return (
                  <View key={idx}>
                    <TouchableOpacity
                      style={optionStyle}
                      onPress={() => handleAnswer(idx)}
                      disabled={selectedAnswer !== null}
                    >
                      <View style={letterStyle}>
                        <Text style={[styles.letterText, { color: theme.optionLetterText }]}>
                          {String.fromCharCode(65 + idx)}
                        </Text>
                      </View>
                      <Text style={[styles.optionText, { color: theme.text }]}>{option.text}</Text>
                      {showResult && isCorrect && (
                        <Ionicons name="checkmark-circle" size={24} color="#4CAF50" />
                      )}
                      {showResult && isSelected && !isCorrect && (
                        <Ionicons name="close-circle" size={24} color="#f44336" />
                      )}
                    </TouchableOpacity>
                    {showExplanation && option.explanation ? (
                      <Text style={[styles.optionExplanationText, { color: theme.textSecondary }]}>
                        {option.explanation}
                      </Text>
                    ) : null}
                  </View>
                );
              })}
            </View>

            {/* Explanation (shown after answering - retrieval practice feedback) */}
            {showExplanation && (
              <View style={[styles.explanationCard, { backgroundColor: theme.surface }]}>
                {immediateFeedbackText && (
                  <View style={[styles.immediateFeedbackBox, { backgroundColor: theme.surfaceAlt }]}>
                    <Text style={[styles.immediateFeedbackLabel, { color: theme.text }]}>Quick Takeaway</Text>
                    <Text style={[styles.immediateFeedbackText, { color: theme.textSecondary }]}>
                      {immediateFeedbackText}
                    </Text>
                  </View>
                )}

                {question.keyPoint && question.keyPoint !== immediateFeedbackText && (
                <View style={styles.keyPointBox}>
                  <Text style={[styles.explanationLabel, { color: theme.text }]}>Key Learning Point</Text>
                  <Text style={styles.keyPointText}>{question.keyPoint}</Text>
                </View>
                )}

                <View style={styles.explanationBox}>
                  <Text style={[styles.explanationLabel, { color: theme.text }]}>Explanation</Text>
                  <MarkdownContent content={question.explanation || 'No explanation available.'} styles={styles} theme={theme} />
                </View>

                {question.references && question.references.length > 0 && (
                  <View style={styles.referencesBox}>
                    <Text style={[styles.explanationLabel, { color: theme.text }]}>References</Text>
                    {question.references.map((ref, idx) => (
                      <Text key={idx} style={[styles.referenceText, { color: theme.mutedText }]}> {ref}</Text>
                    ))}
                  </View>
                )}

                {showConfidencePrompt && (
                  <View style={styles.confidenceRow}>
                    <Text style={[styles.confidenceLabel, { color: theme.text }]}>
                      How confident were you?
                    </Text>
                    <View style={styles.confidenceButtons}>
                      <TouchableOpacity
                        style={[styles.confidenceButton, styles.confidenceLow]}
                        onPress={() => handleConfidenceRating('low')}
                      >
                        <Text style={styles.confidenceButtonText}>Low</Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.confidenceButton, styles.confidenceMedium]}
                        onPress={() => handleConfidenceRating('medium')}
                      >
                        <Text style={styles.confidenceButtonText}>Medium</Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.confidenceButton, styles.confidenceHigh]}
                        onPress={() => handleConfidenceRating('high')}
                      >
                        <Text style={styles.confidenceButtonText}>High</Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                )}

                {/* Add to Flashcards button (for incorrect answers) */}
                {wasIncorrect && (
                  <TouchableOpacity
                    style={styles.addToFlashcardsButton}
                    onPress={() => addFlashcardsFromQuestion(question)}
                  >
                    <Ionicons name="albums-outline" size={20} color="#E91E63" />
                    <Text style={styles.addToFlashcardsText}>Add to Flashcards</Text>
                  </TouchableOpacity>
                )}

                {wasIncorrect && missingFlashcardForCurrent.length > 0 && (
                  <View style={[styles.immediateFeedbackBox, { backgroundColor: theme.surfaceAlt }]}>
                    <Text style={[styles.immediateFeedbackLabel, { color: theme.text }]}>Missing Flashcards</Text>
                    {missingFlashcardForCurrent.map((q, idx) => (
                      <Text key={q.id || idx} style={[styles.immediateFeedbackText, { color: theme.textSecondary }]}>
                        {q.id}  {q.stem || q.leadIn || 'No stem available'}
                      </Text>
                    ))}
                  </View>
                )}

                {/* Question Marking Options */}
                <View style={styles.ratingSection}>
                  <Text style={[styles.ratingTitle, { color: theme.text }]}>Mark this question</Text>
                  <Text style={[styles.ratingSubtitle, { color: theme.subtext }]}>
                    Build your custom review set of challenging topics
                  </Text>
                  <View style={styles.questionMarkButtons}>
                    <TouchableOpacity
                      style={[
                        styles.questionMarkButton,
                        cardData[question.id]?.markedDifficult && styles.questionMarkButtonActive
                      ]}
                      onPress={() => markQuestionForReview(question.id, 'difficult')}
                    >
                      <Ionicons
                        name={cardData[question.id]?.markedDifficult ? 'star' : 'star-outline'}
                        size={20}
                        color={cardData[question.id]?.markedDifficult ? '#FF9800' : '#888'}
                      />
                      <Text style={[
                        styles.questionMarkText,
                        { color: theme.textSecondary },
                        cardData[question.id]?.markedDifficult && { color: '#FF9800' }
                      ]}>
                        Mark Difficult
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[
                        styles.questionMarkButton,
                        cardData[question.id]?.needsReview && styles.questionMarkButtonReview
                      ]}
                      onPress={() => markQuestionForReview(question.id, 'review')}
                    >
                      <Ionicons
                        name={cardData[question.id]?.needsReview ? 'bookmark' : 'bookmark-outline'}
                        size={20}
                        color={cardData[question.id]?.needsReview ? '#F44336' : '#888'}
                      />
                      <Text style={[
                        styles.questionMarkText,
                        { color: theme.textSecondary },
                        cardData[question.id]?.needsReview && { color: '#F44336' }
                      ]}>
                        Needs Review
                      </Text>
                    </TouchableOpacity>
                  </View>

                </View>

                {/* Debug Info - Question ID */}
                <View style={styles.debugInfo}>
                  <Text style={[styles.debugText, { color: theme.mutedText }]}>ID: {question.id}</Text>
                  {question.category && <Text style={[styles.debugText, { color: theme.mutedText }]}>Category: {question.category}</Text>}
                  {question.subcategory && <Text style={[styles.debugText, { color: theme.mutedText }]}>Subcategory: {question.subcategory}</Text>}
                </View>
              </View>
            )}

            {/* Navigation Buttons */}
            <View style={{ marginTop: 16 }}>
              <View style={styles.questionNavButtons}>
                <TouchableOpacity
                  style={[styles.questionNavButton, styles.prevQuestionButton, currentIndex === 0 && styles.questionNavButtonDisabled]}
                  onPress={previousQuestion}
                  disabled={currentIndex === 0}
                >
                  <Ionicons name="arrow-back" size={20} color={currentIndex === 0 ? theme.subtext : theme.text} />
                  <Text style={[styles.questionNavButtonText, { color: theme.text }, currentIndex === 0 && { color: theme.subtext }]}>Previous</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.questionNavButton, styles.nextQuestionButton]}
                  onPress={nextQuestion}
                >
                  <Text style={[styles.questionNavButtonText, { color: theme.text }]}>
                    {currentIndex < questions.length - 1 ? 'Next' : 'Finish'}
                  </Text>
                  <Ionicons name="arrow-forward" size={20} color={theme.text} />
                </TouchableOpacity>
              </View>

              {/* Report Issue */}
              <TouchableOpacity
                style={[styles.reportIssueButton, { marginTop: 16 }]}
                onPress={() => openReportModal('question', question.id)}
              >
                <Ionicons name="flag-outline" size={16} color={theme.subtext} />
                <Text style={[styles.reportIssueText, { color: theme.subtext }]}>Report an issue with this question</Text>
              </TouchableOpacity>
            </View>

            <View style={{ height: 40 }} />
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Render flashcard screen
  const renderFlashcard = () => {
    if (dueFlashcards.length === 0) return null;

    const currentCard = dueFlashcards[currentFlashcardIndex];
    const rendered = renderClozeCard(currentCard, flashcardRevealed);
    const intervals = flashcardRevealed ? predictNextIntervals(currentCard, srsSettings) : null;
    const relatedResource = currentCard.relatedReading
      ? activeResources.find(r => r.id === currentCard.relatedReading)
      : (Array.isArray(currentCard.relatedResourceIds)
        ? activeResources.find(r => currentCard.relatedResourceIds.includes(r.id))
        : null);

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          {/* Header */}
          <View style={styles.questionHeader}>
            <TouchableOpacity onPress={() => {
              setFlashcardRevealed(false);
              setCurrentFlashcardIndex(0);
              setScreen('home');
            }}>
              <Ionicons name="close" size={28} color={theme.text} />
            </TouchableOpacity>

            <View style={styles.progressContainer}>
              <Text style={[styles.progressText, { color: theme.text }]}>
                {currentFlashcardIndex + 1} / {dueFlashcards.length}
              </Text>
              <Text style={[styles.flashcardModeText, { color: theme.subtext }]}>Flashcards</Text>
            </View>

            <View style={{ width: 28 }} />
          </View>

          {/* Progress Bar */}
          <View style={[styles.progressBar, { backgroundColor: theme.progressTrack }]}>
            <View
              style={[
                styles.progressFill,
                {
                  width: `${((currentFlashcardIndex + 1) / dueFlashcards.length) * 100}%`,
                  backgroundColor: '#E91E63'
                }
              ]}
            />
          </View>

          <ScrollView style={[styles.questionContent, noSelectStyle]} contentContainerStyle={styles.flashcardContent}>
            {currentCard.leech?.active && (
              <View style={[styles.leechNotice, { backgroundColor: 'rgba(244, 67, 54, 0.12)', borderColor: 'rgba(244, 67, 54, 0.4)' }]}>
                <Text style={[styles.leechNoticeText, { color: theme.text }]}>
                  This card is in remediation. Review the linked reading and try again.
                </Text>
                {relatedResource && (
                  <TouchableOpacity
                    style={[styles.leechNoticeButton, { backgroundColor: '#FF9800' }]}
                    onPress={() => viewResource(relatedResource, 'flashcard')}
                  >
                    <Text style={styles.leechNoticeButtonText}>Open related reading</Text>
                  </TouchableOpacity>
                )}
                {relatedResource && relatedResource.questionIds?.length > 0 && (
                  <TouchableOpacity
                    style={[styles.leechNoticeButton, { backgroundColor: '#03A9F4', marginTop: 8 }]}
                    onPress={() => startPracticeFromReading(relatedResource)}
                  >
                    <Text style={styles.leechNoticeButtonText}>Practice related questions</Text>
                  </TouchableOpacity>
                )}
                <TouchableOpacity
                  style={[styles.leechNoticeButton, { marginTop: 8 }]}
                  onPress={() => handleUnsuspendLeech(currentCard)}
                >
                  <Text style={styles.leechNoticeButtonText}>Unsuspend after remediation</Text>
                </TouchableOpacity>
              </View>
            )}
            {/* Meta chips */}
            <View style={styles.flashcardMetaRow}>
              {currentCard.category ? (
                <View style={[styles.flashcardChip, styles.flashcardChipPrimary]}>
                  <Text style={styles.flashcardChipText}>{currentCard.category}</Text>
                </View>
              ) : null}
              {currentCard.subcategory ? (
                <View style={styles.flashcardChip}>
                  <Text style={styles.flashcardChipText}>{currentCard.subcategory}</Text>
                </View>
              ) : null}
              {currentCard.difficulty ? (
                <View style={styles.flashcardChip}>
                  <Text style={styles.flashcardChipText}>{currentCard.difficulty}</Text>
                </View>
              ) : null}
            </View>

            {/* Tags */}
            <View style={styles.flashcardTagRow}>
              {(currentCard.tags || [])
                .filter(tag => tag && tag !== currentCard.category && tag !== currentCard.subcategory)
                .slice(0, 3)
                .map((tag, idx) => (
                  <View key={idx} style={styles.flashcardTagChip}>
                    <Text style={styles.flashcardTagText}>{tag}</Text>
                  </View>
                ))}
            </View>

            {/* Cloze Card */}
            <View style={[styles.flashcardBox, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.flashcardPrompt, { color: theme.subtext }]}>
                {flashcardRevealed ? 'Answer' : 'Recall'}
              </Text>
              <Text style={[styles.clozeText, { color: theme.text }]}>{rendered.displayText}</Text>

              {flashcardRevealed && currentCard.extraInfo && (
                <View style={styles.extraInfoBox}>
                  <Text style={[styles.extraInfoText, { color: theme.subtext }]}>{currentCard.extraInfo}</Text>
                </View>
              )}

              {flashcardRevealed && currentCard.notes && (
                <View style={styles.extraInfoBox}>
                  <Text style={[styles.extraInfoText, { color: theme.subtext }]}>{currentCard.notes}</Text>
                </View>
              )}
            </View>

            {/* Show/Rate Buttons */}
            {!flashcardRevealed ? (
              <TouchableOpacity
                style={styles.showAnswerButton}
                onPress={() => setFlashcardRevealed(true)}
              >
                <Text style={styles.showAnswerText}>Show Answer</Text>
              </TouchableOpacity>
            ) : (
              <View style={styles.flashcardRatingSection}>
                <Text style={[styles.ratingTitle, { color: theme.text }]}>How well did you know this?</Text>
                <View style={styles.flashcardRatingButtons}>
                  <TouchableOpacity
                    style={[styles.flashcardRatingButton, styles.ratingAgain]}
                    onPress={() => handleFlashcardRating('again')}
                  >
                    <Text style={styles.ratingButtonText}>Again</Text>
                    <Text style={[styles.ratingInterval, { color: theme.subtext }]}>{intervals?.again}</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.flashcardRatingButton, styles.ratingHard]}
                    onPress={() => handleFlashcardRating('hard')}
                  >
                    <Text style={styles.ratingButtonText}>Hard</Text>
                    <Text style={[styles.ratingInterval, { color: theme.subtext }]}>{intervals?.hard}</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.flashcardRatingButton, styles.ratingGood]}
                    onPress={() => handleFlashcardRating('good')}
                  >
                    <Text style={styles.ratingButtonText}>Good</Text>
                    <Text style={[styles.ratingInterval, { color: theme.subtext }]}>{intervals?.good}</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.flashcardRatingButton, styles.ratingEasyFlash]}
                    onPress={() => handleFlashcardRating('easy')}
                  >
                    <Text style={styles.ratingButtonText}>Easy</Text>
                    <Text style={[styles.ratingInterval, { color: theme.subtext }]}>{intervals?.easy}</Text>
                  </TouchableOpacity>
                </View>

                {/* Card Options Row */}
                <View style={styles.cardOptionsRow}>
                  <TouchableOpacity
                    style={styles.cardOptionButton}
                    onPress={() => openCardSettings(currentCard)}
                  >
                    <Ionicons name="settings-outline" size={18} color={theme.subtext} />
                    <Text style={[styles.cardOptionText, { color: theme.subtext }]}>Card Settings</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.reportIssueButton}
                    onPress={() => openReportModal('flashcard', currentCard.id)}
                  >
                    <Ionicons name="flag-outline" size={16} color={theme.subtext} />
                    <Text style={[styles.reportIssueText, { color: theme.subtext }]}>Report Issue</Text>
                  </TouchableOpacity>

                  {userRole === 'admin' && (
                    <TouchableOpacity
                      style={styles.cardOptionButton}
                      onPress={() => openAdminEdit('flashcard', currentCard)}
                    >
                      <Ionicons name="pencil-outline" size={16} color="#4f8cff" />
                      <Text style={[styles.cardOptionText, { color: '#4f8cff' }]}>Edit Card</Text>
                    </TouchableOpacity>
                  )}
                </View>
              </View>
            )}
          </ScrollView>
        </LinearGradient>

        {/* Card Settings Modal */}
        {showCardSettingsModal && cardSettingsTarget && (
          <Pressable style={styles.modalOverlay} onPress={() => setShowCardSettingsModal(false)}>
            <KeyboardAvoidingView
              behavior={Platform.OS === 'ios' ? 'padding' : undefined}
              style={styles.modalKeyboardAvoiding}
            >
              <Pressable style={[styles.modalContent, styles.modalScrollableContent]} onPress={() => {}}>
                <ScrollView contentContainerStyle={styles.modalScrollContent} keyboardShouldPersistTaps="handled">
                  <Text style={styles.modalTitle}>Card Settings</Text>
                  <Text style={styles.modalSubtitle}>
                    {cardSettingsTarget.suspended ? ' This card is suspended' : 'Configure this flashcard'}
                  </Text>

                  {/* Suspend Button */}
                  <TouchableOpacity
                    style={[
                      styles.cardSettingOption,
                      cardSettingsTarget.suspended && styles.cardSettingOptionActive
                    ]}
                    onPress={handleSuspendCard}
                  >
                    <View style={styles.cardSettingIconBox}>
                      <Ionicons
                        name={cardSettingsTarget.suspended ? 'play-circle-outline' : 'pause-circle-outline'}
                        size={24}
                        color={cardSettingsTarget.suspended ? '#4CAF50' : '#FF9800'}
                      />
                    </View>
                    <View style={styles.cardSettingInfo}>
                      <Text style={styles.cardSettingTitle}>
                        {cardSettingsTarget.suspended ? 'Unsuspend Card' : 'Suspend Card'}
                      </Text>
                      <Text style={styles.cardSettingDesc}>
                        {cardSettingsTarget.suspended
                          ? 'Card will appear in reviews again'
                          : 'Card won\'t appear until unsuspended'}
                      </Text>
                    </View>
                  </TouchableOpacity>

                  {/* Custom Interval Section */}
                  <View style={styles.customIntervalSection}>
                    <Text style={styles.customIntervalLabel}>Set Custom Interval (days)</Text>
                    <View style={styles.customIntervalRow}>
                      <TextInput
                        style={styles.customIntervalInput}
                        placeholder="e.g. 30"
                        placeholderTextColor="#666"
                        keyboardType="number-pad"
                        value={customIntervalInput}
                        onChangeText={setCustomIntervalInput}
                      />
                      <TouchableOpacity
                        style={styles.customIntervalButton}
                        onPress={handleSetCustomInterval}
                      >
                        <Text style={styles.customIntervalButtonText}>Set</Text>
                      </TouchableOpacity>
                    </View>
                    {cardSettingsTarget.customInterval && (
                      <TouchableOpacity
                        style={styles.clearIntervalButton}
                        onPress={handleClearCustomInterval}
                      >
                        <Text style={styles.clearIntervalText}>
                          Clear custom interval (currently: {cardSettingsTarget.customInterval} days)
                        </Text>
                      </TouchableOpacity>
                    )}
                  </View>

                  {/* Cancel Button */}
                  <TouchableOpacity
                    style={styles.modalButtonCancel}
                    onPress={() => setShowCardSettingsModal(false)}
                  >
                    <Text style={styles.modalButtonCancelText}>Close</Text>
                  </TouchableOpacity>
                </ScrollView>
              </Pressable>
            </KeyboardAvoidingView>
          </Pressable>
        )}
      </SafeAreaView>
    );
  };

  // Render flashcard results
  const renderFlashcardResults = () => {
    const stats = flashcardStats;

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <ScrollView contentContainerStyle={styles.resultsContent}>
            <View style={styles.resultsHeader}>
              <Ionicons name="checkmark-circle" size={80} color="#E91E63" />
              <Text style={[styles.resultsTitle, { color: theme.text }]}>Session Complete!</Text>
              <Text style={[styles.flashcardResultsSubtitle, { color: theme.subtext }]}>
                You reviewed {dueFlashcards.length} flashcard{dueFlashcards.length !== 1 ? 's' : ''}
              </Text>
            </View>

            <View style={[styles.reminderCard, { backgroundColor: theme.surface }]}>
              <Text style={[styles.reminderTitle, { color: theme.text }]}>Spaced Repetition</Text>
              <Text style={[styles.reminderText, { color: theme.subtext }]}>
                Cards you rated "Again" will appear sooner, while "Easy" cards
                will have longer intervals. This optimizes your learning by
                focusing on what you need to practice most.
              </Text>
            </View>

            <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.statsTitle, { color: theme.text }]}>Flashcard Stats</Text>
              <View style={styles.statsRow}>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: '#E91E63' }]}>{stats.dueToday}</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Still Due</Text>
                </View>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: theme.text }]}>{stats.learning}</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Learning</Text>
                </View>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: theme.text }]}>{stats.learned}</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Mature</Text>
                </View>
              </View>
            </View>

            <TouchableOpacity
              style={styles.primaryButton}
              onPress={() => setScreen('home')}
            >
              <Text style={styles.primaryButtonText}>Return Home</Text>
            </TouchableOpacity>

            {stats.dueToday > 0 && (
              <TouchableOpacity
                style={[styles.secondaryButton, { borderColor: '#E91E63' }]}
                onPress={() => startFlashcardSession()}
              >
                <Text style={[styles.secondaryButtonText, { color: '#E91E63' }]}>
                  Continue ({stats.dueToday} remaining)
                </Text>
              </TouchableOpacity>
            )}
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Render results screen
  const renderResults = () => {
    const percentage = sessionStats.total > 0
      ? Math.round((sessionStats.correct / sessionStats.total) * 100)
      : 0;

    let feedbackMessage = '';
    let feedbackColor = '#4CAF50';
    if (percentage >= 80) {
      feedbackMessage = 'Excellent work!';
    } else if (percentage >= 60) {
      feedbackMessage = 'Good progress!';
      feedbackColor = '#FF9800';
    } else {
      feedbackMessage = 'Keep practicing!';
      feedbackColor = '#2196F3';
    }

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <ScrollView contentContainerStyle={styles.resultsContent}>
            <View style={styles.resultsHeader}>
              <Text style={[styles.resultsTitle, { color: theme.text }]}>Session Complete!</Text>

              <View style={[styles.scoreCircle, { borderColor: feedbackColor, backgroundColor: theme.card }]}>
                <Text style={[styles.scorePercentage, { color: feedbackColor }]}>{percentage}%</Text>
                <Text style={[styles.scoreLabel, { color: theme.subtext }]}>
                  {sessionStats.correct} / {sessionStats.total}
                </Text>
              </View>

              <Text style={[styles.resultsFeedback, { color: feedbackColor }]}>
                {feedbackMessage}
              </Text>
            </View>

            {/* Test Mode Review - Show all questions and answers */}
            {testAnswers.length > 0 && (
              <View style={styles.testReviewSection}>
                <Text style={[styles.testReviewTitle, { color: theme.text }]}>Review Your Answers</Text>
                <Text style={[styles.testReviewSubtitle, { color: theme.subtext }]}>
                  Tap a question to see the full explanation
                </Text>

                {/* Filter Buttons */}
                <View style={styles.reviewFilterRow}>
                  <TouchableOpacity
                    style={[
                      styles.reviewFilterButton,
                      { backgroundColor: theme.surfaceAlt },
                      reviewFilter === 'all' && styles.reviewFilterButtonActive
                    ]}
                    onPress={() => setReviewFilter('all')}
                  >
                    <Text style={[
                      styles.reviewFilterText,
                      { color: theme.textSecondary },
                      reviewFilter === 'all' && styles.reviewFilterTextActive
                    ]}>
                      All ({reviewCounts.all})
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[
                      styles.reviewFilterButton,
                      { backgroundColor: theme.surfaceAlt },
                      reviewFilter === 'correct' && styles.reviewFilterButtonActiveCorrect
                    ]}
                    onPress={() => setReviewFilter('correct')}
                  >
                    <Text style={[
                      styles.reviewFilterText,
                      { color: theme.textSecondary },
                      reviewFilter === 'correct' && styles.reviewFilterTextActive
                    ]}>
                      Correct ({reviewCounts.correct})
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[
                      styles.reviewFilterButton,
                      { backgroundColor: theme.surfaceAlt },
                      reviewFilter === 'incorrect' && styles.reviewFilterButtonActiveIncorrect
                    ]}
                    onPress={() => setReviewFilter('incorrect')}
                  >
                    <Text style={[
                      styles.reviewFilterText,
                      { color: theme.textSecondary },
                      reviewFilter === 'incorrect' && styles.reviewFilterTextActive
                    ]}>
                      Incorrect ({reviewCounts.incorrect})
                    </Text>
                  </TouchableOpacity>
                </View>

                {/* Filtered Question List */}
                {filteredReviewAnswers.map((answer) => (
                  <ResultsReviewItem
                    key={answer.originalIndex}
                    item={answer}
                    theme={theme}
                    onSelect={handleSelectReview}
                  />
                ))}
              </View>
            )}

            {/* Reminder for Tutor Mode */}
            {testMode !== 'test' && (
              <View style={[styles.reminderCard, { backgroundColor: theme.surface }]}>
                <Text style={[styles.reminderTitle, { color: theme.text }]}>Keep Practicing</Text>
                <Text style={[styles.reminderText, { color: theme.subtext }]}>
                  Questions you marked as "Difficult" or "Needs Review" will appear in Target Weak Areas mode.
                  Incorrect answers are automatically added for review.
                </Text>
              </View>
            )}

            {/* Suggested Reading based on missed questions in this session */}
            {sessionReadingResults.length > 0 && missedIdsForResults.length > 0 && (
              <View style={[styles.resultsSuggestedReading, { backgroundColor: theme.card }]}>
                <View style={styles.resultsSuggestedHeader}>
                  <Ionicons name="book-outline" size={20} color="#00BCD4" />
                  <Text style={[styles.resultsSuggestedTitle, { color: theme.text }]}>Suggested Reading</Text>
                </View>
                <Text style={[styles.resultsSuggestedSubtitle, { color: theme.subtext }]}>
                  Based on questions you missed
                </Text>
                {sessionReadingResults.map((resource, idx) => (
                  <TouchableOpacity
                    key={resource.id || idx}
                    style={[styles.resultsSuggestedItem, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => viewResource(resource)}
                  >
                    <View style={[styles.resultsSuggestedIcon, { backgroundColor: theme.surfaceAlt }]}>
                      <Ionicons
                        name={resource.type === RESOURCE_TYPES.CUSTOM_NOTE ? 'document-text' : 'link'}
                        size={18}
                        color="#00BCD4"
                      />
                    </View>
                    <View style={styles.resultsSuggestedContent}>
                      <Text style={[styles.resultsSuggestedItemTitle, { color: theme.text }]} numberOfLines={2}>
                        {resource.title}
                      </Text>
                      <Text style={[styles.resultsSuggestedMeta, { color: theme.subtext }]}>
                        Covers {resource.relevantQuestions?.length || 0} question{(resource.relevantQuestions?.length || 0) !== 1 ? 's' : ''} you missed
                      </Text>
                    </View>
                    <Ionicons name="chevron-forward" size={16} color={theme.subtext} />
                  </TouchableOpacity>
                ))}
              </View>
            )}

            {missingFlashcardQuestionsForResults.length > 0 && (
              <View style={[styles.resultsSuggestedReading, { backgroundColor: theme.card }]}>
                <View style={styles.resultsSuggestedHeader}>
                  <Ionicons name="albums-outline" size={20} color="#E91E63" />
                  <Text style={[styles.resultsSuggestedTitle, { color: theme.text }]}>Missing Flashcards</Text>
                </View>
                <Text style={[styles.resultsSuggestedSubtitle, { color: theme.subtext }]}>
                  These missed or difficult questions have no linked flashcards yet
                </Text>
                {missingFlashcardQuestionsForResults.map((q, idx) => (
                  <View
                    key={q.id || idx}
                    style={[styles.resultsSuggestedItem, { backgroundColor: theme.surfaceAlt }]}
                  >
                    <View style={[styles.resultsSuggestedIcon, { backgroundColor: theme.surfaceAlt }]}>
                      <Ionicons name="help-circle-outline" size={18} color="#E91E63" />
                    </View>
                    <View style={styles.resultsSuggestedContent}>
                      <Text style={[styles.resultsSuggestedItemTitle, { color: theme.text }]} numberOfLines={2}>
                        {q.id}  {q.stem || q.leadIn || 'No stem available'}
                      </Text>
                    </View>
                  </View>
                ))}
              </View>
            )}

            {missedOrDifficultIdsForResults.length > 0 && (
              <TouchableOpacity
                style={styles.secondaryButton}
                onPress={() => unlockFlashcardsForQuestionIds(missedOrDifficultIdsForResults, 'for missed/difficult questions')}
              >
                <Text style={styles.secondaryButtonText}>Unlock Flashcards for Missed/Difficult</Text>
              </TouchableOpacity>
            )}

            {learningSettings.microTestsEnabled && missedIdsForResults.length > 0 && (
              <TouchableOpacity
                style={styles.secondaryButton}
                onPress={startMicroTestFromMisses}
              >
                <Text style={styles.secondaryButtonText}>
                  Start {Math.max(3, Math.min(10, learningSettings.microTestSize || 5))}-Question Booster
                </Text>
              </TouchableOpacity>
            )}

            <TouchableOpacity
              style={styles.primaryButton}
              onPress={() => setScreen('home')}
            >
              <Text style={styles.primaryButtonText}>Return Home</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.secondaryButton}
              onPress={() => {
                if (currentMode) {
                  startSession(currentMode, selectedCategory);
                }
              }}
            >
              <Text style={styles.secondaryButtonText}>Practice Again</Text>
            </TouchableOpacity>
          </ScrollView>

          {/* Detailed Question Review Modal */}
          {selectedReviewIndex !== null && testAnswers[selectedReviewIndex] && (
            <Pressable
              style={[styles.reviewModalOverlay, { backgroundColor: theme.modalOverlay }]}
              onPress={() => setSelectedReviewIndex(null)}
            >
              <Pressable style={[styles.reviewModalContent, { backgroundColor: theme.card }]} onPress={() => {}}>
                <View style={[styles.reviewModalHeader, { borderBottomColor: theme.border }]}>
                  <Text style={[styles.reviewModalTitle, { color: theme.text }]}>
                    Question {selectedReviewIndex + 1} of {testAnswers.length}
                  </Text>
                  <TouchableOpacity onPress={() => setSelectedReviewIndex(null)}>
                    <Ionicons name="close" size={28} color={theme.text} />
                  </TouchableOpacity>
                </View>

                <ScrollView style={styles.reviewModalScroll}>
                  {/* Question Status */}
                  <View style={[
                    styles.reviewModalStatus,
                    { backgroundColor: testAnswers[selectedReviewIndex].isCorrect ? 'rgba(76, 175, 80, 0.15)' : 'rgba(244, 67, 54, 0.15)' }
                  ]}>
                    <Ionicons
                      name={testAnswers[selectedReviewIndex].isCorrect ? 'checkmark-circle' : 'close-circle'}
                      size={24}
                      color={testAnswers[selectedReviewIndex].isCorrect ? '#4CAF50' : '#F44336'}
                    />
                    <Text style={[
                      styles.reviewModalStatusText,
                      { color: testAnswers[selectedReviewIndex].isCorrect ? '#4CAF50' : '#F44336' }
                    ]}>
                      {testAnswers[selectedReviewIndex].isCorrect ? 'You answered correctly!' : 'Incorrect answer'}
                    </Text>
                  </View>

                  {/* Question Stem */}
                  <Text style={[styles.reviewModalQuestion, { color: theme.text }]}>
                    {testAnswers[selectedReviewIndex].question.stem || testAnswers[selectedReviewIndex].question.leadIn}
                  </Text>

                  {/* Answer Options */}
                  <View style={styles.reviewModalOptions}>
                    {testAnswers[selectedReviewIndex].question.options.map((option, optIdx) => {
                      const isCorrectAnswer = optIdx === testAnswers[selectedReviewIndex].question.correctIndex;
                      const wasSelected = optIdx === testAnswers[selectedReviewIndex].selectedIndex;
                      return (
                        <View
                          key={optIdx}
                          style={[
                            styles.reviewModalOption,
                            { backgroundColor: theme.surfaceAlt },
                            isCorrectAnswer && styles.reviewModalOptionCorrect,
                            wasSelected && !isCorrectAnswer && styles.reviewModalOptionWrong,
                          ]}
                        >
                          <Text style={[styles.reviewModalOptionLetter, { color: theme.subtext }]}>
                            {String.fromCharCode(65 + optIdx)}.
                          </Text>
                          <Text style={[
                            styles.reviewModalOptionText,
                            { color: theme.textSecondary },
                            isCorrectAnswer && { color: '#4CAF50', fontWeight: '600' },
                            wasSelected && !isCorrectAnswer && { color: '#F44336' },
                          ]}>
                            {option}
                          </Text>
                          {isCorrectAnswer && (
                            <Ionicons name="checkmark-circle" size={20} color="#4CAF50" />
                          )}
                          {wasSelected && !isCorrectAnswer && (
                            <Ionicons name="close-circle" size={20} color="#F44336" />
                          )}
                        </View>
                      );
                    })}
                  </View>

                  {/* Explanation */}
                  <View style={[styles.reviewModalExplanation, { backgroundColor: theme.surfaceAlt, borderLeftColor: theme.accent }]}>
                    <Text style={[styles.reviewModalExplanationTitle, { color: theme.accent }]}>Explanation</Text>
                    <MarkdownContent
                      content={testAnswers[selectedReviewIndex].question.explanation || 'No explanation available.'}
                      styles={styles}
                      theme={theme}
                    />
                    {testAnswers[selectedReviewIndex].question.keyPoint && (
                      <View style={[styles.reviewModalKeyPoint, { backgroundColor: theme.accentSoft }]}>
                        <Text style={[styles.reviewModalKeyPointTitle, { color: '#4CAF50' }]}>Key Point</Text>
                        <Text style={[styles.reviewModalKeyPointText, { color: theme.textSecondary }]}>
                          {testAnswers[selectedReviewIndex].question.keyPoint}
                        </Text>
                      </View>
                    )}
                  </View>

                  {!testAnswers[selectedReviewIndex].isCorrect && (
                    <TouchableOpacity
                      style={styles.addToFlashcardsButton}
                      onPress={() => addFlashcardsFromQuestion(testAnswers[selectedReviewIndex].question)}
                    >
                      <Ionicons name="albums-outline" size={20} color="#E91E63" />
                      <Text style={styles.addToFlashcardsText}>Add to Flashcards</Text>
                    </TouchableOpacity>
                  )}
                </ScrollView>

                {/* Navigation Buttons */}
                <View style={[styles.reviewModalNav, { borderTopColor: theme.border }]}>
                  <TouchableOpacity
                    style={[styles.reviewModalNavButton, selectedReviewIndex === 0 && styles.reviewModalNavButtonDisabled]}
                    onPress={() => setSelectedReviewIndex(Math.max(0, selectedReviewIndex - 1))}
                    disabled={selectedReviewIndex === 0}
                  >
                    <Ionicons name="chevron-back" size={24} color={selectedReviewIndex === 0 ? theme.subtext : theme.text} />
                    <Text style={[styles.reviewModalNavText, { color: theme.text }, selectedReviewIndex === 0 && { color: theme.subtext }]}>Previous</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.reviewModalNavButton, selectedReviewIndex === testAnswers.length - 1 && styles.reviewModalNavButtonDisabled]}
                    onPress={() => setSelectedReviewIndex(Math.min(testAnswers.length - 1, selectedReviewIndex + 1))}
                    disabled={selectedReviewIndex === testAnswers.length - 1}
                  >
                    <Text style={[styles.reviewModalNavText, { color: theme.text }, selectedReviewIndex === testAnswers.length - 1 && { color: theme.subtext }]}>Next</Text>
                    <Ionicons name="chevron-forward" size={24} color={selectedReviewIndex === testAnswers.length - 1 ? theme.subtext : theme.text} />
                  </TouchableOpacity>
                </View>
              </Pressable>
            </Pressable>
          )}
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Render weakness analysis screen
  const renderWeaknessAnalysis = () => {
    const analysis = dashboardAnalysis;
    const suggestedResources = dashboardSuggestedReading;
    const hasTrendData = dashboardTrend.some((point) => point.attempts > 0);
    const maxAttemptTrend = Math.max(1, ...dashboardTrend.map((point) => point.attempts || 0));
    const getAccuracyColor = (accuracy) => (
      accuracy >= 70 ? '#4CAF50' : accuracy >= 50 ? '#FF9800' : '#F44336'
    );

    const renderTrendBars = ({ keyName, color, valueFormatter, denominator }) => (
      <View style={styles.dashboardTrendBars}>
        {dashboardTrend.map((point) => {
          const rawValue = Number(point[keyName]) || 0;
          const fillRatio = denominator > 0 ? Math.min(1, rawValue / denominator) : 0;
          const barHeight = Math.max(6, Math.round(fillRatio * 74));

          return (
            <View key={`${keyName}_${point.key}`} style={styles.dashboardTrendColumn}>
              <Text style={[styles.dashboardTrendValue, { color: theme.textSecondary }]}>
                {valueFormatter(rawValue)}
              </Text>
              <View style={[styles.dashboardTrendTrack, { backgroundColor: theme.surfaceAlt }]}>
                <View style={[styles.dashboardTrendFill, { height: barHeight, backgroundColor: color }]} />
              </View>
              <Text style={[styles.dashboardTrendLabel, { color: theme.subtext }]}>
                {point.shortLabel}
              </Text>
            </View>
          );
        })}
      </View>
    );

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <View style={styles.navHeader}>
            <TouchableOpacity onPress={() => setScreen('home')}>
              <Ionicons name="arrow-back" size={28} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.navTitle, { color: theme.text }]}>Performance Dashboard</Text>
            <View style={{ width: 28 }} />
          </View>

          <ScrollView contentContainerStyle={styles.scrollContent}>
            <View style={[styles.dashboardAssumptionCard, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}>
              <Ionicons name="information-circle-outline" size={18} color={theme.text} />
              <Text style={[styles.dashboardAssumptionText, { color: theme.subtext }]}>
                Assumption: KPI and trend values are computed from local question attempts and last-7-day session history.
              </Text>
            </View>

            <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.statsTitle, { color: theme.text }]}>Headline KPIs</Text>
              <View style={styles.dashboardKpiGrid}>
                <View style={[styles.dashboardKpiTile, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}>
                  <Text style={[styles.dashboardKpiLabel, { color: theme.subtext }]}>Accuracy</Text>
                  <Text style={[styles.dashboardKpiValue, { color: getAccuracyColor(dashboardKpis.accuracy) }]}>
                    {dashboardKpis.accuracy}%
                  </Text>
                </View>
                <View style={[styles.dashboardKpiTile, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}>
                  <Text style={[styles.dashboardKpiLabel, { color: theme.subtext }]}>Attempts</Text>
                  <Text style={[styles.dashboardKpiValue, { color: theme.text }]}>{dashboardKpis.attempts}</Text>
                </View>
                <View style={[styles.dashboardKpiTile, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}>
                  <Text style={[styles.dashboardKpiLabel, { color: theme.subtext }]}>Due Flashcards</Text>
                  <Text style={[styles.dashboardKpiValue, { color: '#E91E63' }]}>{dashboardKpis.dueFlashcards}</Text>
                </View>
                <View style={[styles.dashboardKpiTile, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}>
                  <Text style={[styles.dashboardKpiLabel, { color: theme.subtext }]}>Study Streak</Text>
                  <Text style={[styles.dashboardKpiValue, { color: theme.text }]}>{dashboardKpis.streak}d</Text>
                </View>
              </View>
            </View>

            <Text style={[styles.sectionTitle, { color: theme.text }]}>Trends</Text>
            <Text style={[styles.sectionSubtitle, { color: theme.subtext }]}>Last 7 days of completed sessions</Text>

            <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.statsTitle, { color: theme.text }]}>Accuracy Trend</Text>
              {renderTrendBars({
                keyName: 'accuracy',
                color: '#4CAF50',
                valueFormatter: (value) => `${value}%`,
                denominator: 100,
              })}
            </View>

            <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.statsTitle, { color: theme.text }]}>Study Volume Trend</Text>
              {renderTrendBars({
                keyName: 'attempts',
                color: '#03A9F4',
                valueFormatter: (value) => `${value}`,
                denominator: maxAttemptTrend,
              })}
              {!hasTrendData && (
                <Text style={[styles.dashboardFootnote, { color: theme.subtext }]}>
                  No completed sessions in the last 7 days yet.
                </Text>
              )}
            </View>

            <Text style={[styles.sectionTitle, { color: theme.text }]}>Breakdown Table</Text>
            <Text style={[styles.sectionSubtitle, { color: theme.subtext }]}>Category-level performance snapshot</Text>

            <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
              <View style={[styles.dashboardTable, { borderColor: theme.border }]}>
                <View style={[styles.dashboardTableHeader, { backgroundColor: theme.surfaceAlt, borderBottomColor: theme.border }]}>
                  <Text style={[styles.dashboardTableHeaderText, styles.dashboardTableTopicCell, { color: theme.subtext }]}>
                    Topic
                  </Text>
                  <Text style={[styles.dashboardTableHeaderText, styles.dashboardTableMetricCell, { color: theme.subtext }]}>
                    Acc
                  </Text>
                  <Text style={[styles.dashboardTableHeaderText, styles.dashboardTableMetricCell, { color: theme.subtext }]}>
                    Att
                  </Text>
                  <Text style={[styles.dashboardTableHeaderText, styles.dashboardTableMetricCell, { color: theme.subtext }]}>
                    Qs
                  </Text>
                </View>

                {dashboardBreakdownRows.map((row, idx) => {
                  const rowAccuracy = typeof row.accuracy === 'number' ? row.accuracy : null;
                  return (
                    <View key={`${row.category || row.label}_${idx}`} style={[styles.dashboardTableRow, { borderTopColor: theme.border }]}>
                      <Text
                        style={[styles.dashboardTableTopicText, styles.dashboardTableTopicCell, { color: theme.text }]}
                        numberOfLines={1}
                      >
                        {row.label}
                      </Text>
                      <Text
                        style={[
                          styles.dashboardTableMetricText,
                          styles.dashboardTableMetricCell,
                          { color: rowAccuracy === null ? theme.subtext : getAccuracyColor(rowAccuracy) },
                        ]}
                      >
                        {rowAccuracy === null ? '' : `${rowAccuracy}%`}
                      </Text>
                      <Text style={[styles.dashboardTableMetricText, styles.dashboardTableMetricCell, { color: theme.textSecondary }]}>
                        {row.attempts || 0}
                      </Text>
                      <Text style={[styles.dashboardTableMetricText, styles.dashboardTableMetricCell, { color: theme.textSecondary }]}>
                        {row.questionCount || 0}
                      </Text>
                    </View>
                  );
                })}
              </View>
              <Text style={[styles.dashboardFootnote, { color: theme.subtext }]}>
                Wiring point: swap fallback rows with server-side category aggregates when available.
              </Text>
            </View>

            {analysis.weakSubcategories.length > 0 && (
              <>
                <Text style={[styles.sectionTitle, { color: theme.text }]}>Action Queue</Text>
                <Text style={[styles.sectionSubtitle, { color: theme.subtext }]}>Top subtopics to practice next</Text>

                {analysis.weakSubcategories.slice(0, 4).map((sub, idx) => (
                  <View key={idx} style={[styles.weakAreaCard, { backgroundColor: theme.card }]}>
                    <View style={styles.weakAreaHeader}>
                      <View>
                        <Text style={[styles.weakAreaTitle, { color: theme.text }]}>{sub.subcategory}</Text>
                        <Text style={[styles.weakAreaCategory, { color: theme.subtext }]}>
                          {activeCategoryMap[sub.category]?.name || sub.category}
                        </Text>
                      </View>
                      <View style={[styles.accuracyBadge, { backgroundColor: `${getAccuracyColor(sub.accuracy)}30` }]}>
                        <Text style={[styles.accuracyText, { color: getAccuracyColor(sub.accuracy) }]}>
                          {sub.accuracy}%
                        </Text>
                      </View>
                    </View>
                    <View style={styles.weakAreaStats}>
                      <Text style={[styles.weakAreaStatText, { color: theme.subtext }]}>
                        {sub.correct}/{sub.attempts} correct  {sub.questionCount} questions studied
                      </Text>
                    </View>
                    <TouchableOpacity
                      style={styles.practiceWeakButton}
                      onPress={() => {
                        const subcatQuestions = activeQuestions.filter((q) => q.subcategory === sub.subcategory);
                        if (subcatQuestions.length > 0) {
                          const nextQuestions = shuffleArray(subcatQuestions).slice(0, 15);
                          setQuestions(nextQuestions);
                          setCurrentMode(PRACTICE_MODES.WEAK_AREAS);
                          setCurrentIndex(0);
                          setSelectedAnswer(null);
                          setShowExplanation(false);
                          setSessionStats({ correct: 0, incorrect: 0, total: 0 });
                          setShuffledOptions(prepareQuestion(nextQuestions[0]));
                          setScreen('question');
                        }
                      }}
                    >
                      <Text style={styles.practiceWeakButtonText}>Practice This Topic</Text>
                    </TouchableOpacity>
                  </View>
                ))}
              </>
            )}

            {suggestedResources.length > 0 && (
              <>
                <Text style={[styles.sectionTitle, { marginTop: 24, color: theme.text }]}>Suggested Reading</Text>
                <Text style={[styles.sectionSubtitle, { color: theme.subtext }]}>Based on missed-question coverage</Text>

                {suggestedResources.map((resource, idx) => (
                  <TouchableOpacity
                    key={resource.id || idx}
                    style={[styles.resourceCard, { backgroundColor: theme.card }]}
                    onPress={() => viewResource(resource)}
                  >
                    <View style={[styles.resourceIcon, { backgroundColor: theme.surfaceAlt }]}>
                      <Ionicons
                        name={resource.type === RESOURCE_TYPES.CUSTOM_NOTE ? 'document-text' :
                          resource.type === RESOURCE_TYPES.PUBMED ? 'link' : 'book'}
                        size={24}
                        color="#00BCD4"
                      />
                    </View>
                    <View style={styles.resourceContent}>
                      <Text style={[styles.resourceTitle, { color: theme.text }]} numberOfLines={2}>
                        {resource.title}
                      </Text>
                      <View style={styles.resourceMeta}>
                        {resource.type === RESOURCE_TYPES.PUBMED && resource.year && (
                          <Text style={[styles.resourceMetaText, { color: theme.subtext }]}>{resource.year}</Text>
                        )}
                        {resource.readingTime && (
                          <Text style={[styles.resourceMetaText, { color: theme.subtext }]}>{resource.readingTime} min read</Text>
                        )}
                        <View style={[styles.priorityBadge, {
                          backgroundColor: resource.priority === 'essential' ? '#f4433630' :
                            resource.priority === 'suggested' ? '#FF980030' : '#4CAF5030',
                        }]}>
                          <Text style={[styles.priorityText, {
                            color: resource.priority === 'essential' ? '#f44336' :
                              resource.priority === 'suggested' ? '#FF9800' : '#4CAF50',
                          }]}>
                            {resource.priority}
                          </Text>
                        </View>
                      </View>
                      <Text style={[styles.resourceRelevance, { color: theme.subtext }]}>
                        Covers {resource.relevantQuestions?.length || 0} question{(resource.relevantQuestions?.length || 0) !== 1 ? 's' : ''} you missed
                      </Text>
                    </View>
                    <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                  </TouchableOpacity>
                ))}
              </>
            )}

            {analysis.totalAttempts < 10 && (
              <View style={[styles.noDataCard, { backgroundColor: theme.card }]}>
                <Ionicons name="information-circle" size={40} color={theme.subtext} />
                <Text style={[styles.noDataTitle, { color: theme.text }]}>Keep Practicing!</Text>
                <Text style={[styles.noDataText, { color: theme.subtext }]}>
                  Complete more questions to turn placeholders into stable trend and breakdown metrics.
                </Text>
              </View>
            )}
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Render topics browser screen
  const renderTopics = () => {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <View style={styles.navHeader}>
            <TouchableOpacity onPress={() => setScreen('home')}>
              <Ionicons name="arrow-back" size={28} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.navTitle, { color: theme.text }]}>Study Topics</Text>
            <View style={{ width: 28 }} />
          </View>

          <ScrollView contentContainerStyle={styles.scrollContent}>
            {/* Stats */}
            <View style={[styles.topicsStatsCard, { backgroundColor: theme.card }]}>
              <View style={styles.topicsStatItem}>
                <Text style={[styles.topicsStatNumber, { color: '#00BCD4' }]}>{activeResources.length}</Text>
                <Text style={[styles.topicsStatLabel, { color: theme.subtext }]}>Total Topics</Text>
              </View>
              <View style={styles.topicsStatItem}>
                <Text style={[styles.topicsStatNumber, { color: '#00BCD4' }]}>
                  {Object.keys(readTopics).filter(id => readTopics[id]?.completed).length}
                </Text>
                <Text style={[styles.topicsStatLabel, { color: theme.subtext }]}>Completed</Text>
              </View>
              <View style={styles.topicsStatItem}>
                <Text style={[styles.topicsStatNumber, { color: '#00BCD4' }]}>{categorizedResourceKeys.length}</Text>
                <Text style={[styles.topicsStatLabel, { color: theme.subtext }]}>Categories</Text>
              </View>
            </View>

            {/* Topics by Category */}
            {categorizedResourceKeys.map(category => (
              <View key={category} style={styles.topicCategory}>
                <View style={styles.topicCategoryHeader}>
                  <Text style={[styles.topicCategoryTitle, { color: theme.text }]}>
                    {category.replace(/_/g, ' ')}
                  </Text>
                  <Text style={[styles.topicCategoryCount, { color: theme.subtext }]}>
                    {categorizedResources[category].length} topics
                  </Text>
                </View>

                {categorizedResources[category].map((resource, idx) => {
                  const isRead = readTopics[resource.id]?.completed;
                  return (
                    <TopicListItem
                      key={resource.id || idx}
                      resource={resource}
                      isRead={isRead}
                      theme={theme}
                      onSelect={handleViewResource}
                    />
                  );
                })}
              </View>
            ))}

            {activeResources.length === 0 && (
              <View style={styles.noTopicsCard}>
                <Ionicons name="book-outline" size={48} color={theme.subtext} />
                <Text style={[styles.noTopicsTitle, { color: theme.text }]}>Topics Coming Soon</Text>
                <Text style={[styles.noTopicsText, { color: theme.subtext }]}>
                  Study materials and reading content are being added. Check back soon!
                </Text>
              </View>
            )}
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Render resource view screen
  const renderResourceView = () => {
    if (!selectedResource) return null;

    const isPubMed = selectedResource.type === RESOURCE_TYPES.PUBMED;
    const isCustomNote = selectedResource.type === RESOURCE_TYPES.CUSTOM_NOTE;
    const isRead = readTopics[selectedResource.id]?.completed;

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <View style={styles.navHeader}>
            <TouchableOpacity onPress={() => {
              // Go back to where we came from
              const returnScreen = selectedReadingTopic || 'weakness';
              setSelectedReadingTopic(null);
              setScreen(returnScreen);
            }}>
              <Ionicons name="arrow-back" size={28} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.navTitle, { color: theme.text }]} numberOfLines={1}>
              {isCustomNote ? 'Study Topic' : 'Article'}
            </Text>
            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
              {userRole === 'admin' && (
                <TouchableOpacity onPress={() => openAdminEdit('reading', selectedResource)}>
                  <Ionicons name="pencil-outline" size={22} color="#4f8cff" />
                </TouchableOpacity>
              )}
              {isCustomNote && (
                <TouchableOpacity onPress={() => markTopicAsRead(selectedResource, !isRead)}>
                  <Ionicons
                    name={isRead ? 'checkmark-circle' : 'checkmark-circle-outline'}
                    size={28}
                    color={isRead ? '#4CAF50' : theme.subtext}
                  />
                </TouchableOpacity>
              )}
              {!isCustomNote && userRole !== 'admin' && <View style={{ width: 28 }} />}
            </View>
          </View>

          <ScrollView contentContainerStyle={[styles.scrollContent, { paddingHorizontal: 28 }]}>
            {/* Resource Header */}
            <View style={styles.resourceHeader}>
              <Text style={[styles.resourceViewTitle, { color: theme.text }]}>{selectedResource.title}</Text>

              <View style={styles.readingInfoRow}>
                {selectedResource.readingTime && (
                  <View style={[styles.readingInfoPill, { backgroundColor: theme.surfaceAlt }]}>
                    <Text style={[styles.readingInfoText, { color: theme.textSecondary }]}>
                      {selectedResource.readingTime} min read
                    </Text>
                  </View>
                )}
                {selectedResource.wordCount && (
                  <View style={[styles.readingInfoPill, { backgroundColor: theme.surfaceAlt }]}>
                    <Text style={[styles.readingInfoText, { color: theme.textSecondary }]}>
                      {selectedResource.wordCount} words
                    </Text>
                  </View>
                )}
                {selectedResource.readingTime && (
                  <View style={[styles.readingInfoPill, { backgroundColor: theme.surfaceAlt }]}>
                    <Text style={[styles.readingInfoText, { color: theme.textSecondary }]}>
                      {selectedResource.readingTime <= 6 ? 'Short' : selectedResource.readingTime <= 12 ? 'Medium' : 'Long'}
                    </Text>
                  </View>
                )}
              </View>

              <View style={[styles.readingProgressBar, { backgroundColor: theme.surfaceAlt }]}>
                <View
                  style={[
                    styles.readingProgressFill,
                    { width: `${Math.round(readingScrollProgress * 100)}%`, backgroundColor: theme.accent },
                  ]}
                />
              </View>

              {isPubMed && (
                <View style={styles.citationBox}>
                  {selectedResource.authors?.length > 0 && (
                    <Text style={[styles.citationAuthors, { color: theme.textSecondary }]}>
                      {selectedResource.authors.length > 3
                        ? `${selectedResource.authors[0]} et al.`
                        : selectedResource.authors.join(', ')}
                    </Text>
                  )}
                  {selectedResource.journal && (
                    <Text style={[styles.citationJournal, { color: theme.subtext }]}>
                      {selectedResource.journal} {selectedResource.year ? `(${selectedResource.year})` : ''}
                    </Text>
                  )}
                </View>
              )}

              {/* Tags */}
              <View style={styles.resourceTags}>
                {selectedResource.tags?.slice(0, 4).map((tag, idx) => (
                  <View key={idx} style={[styles.resourceTag, { backgroundColor: theme.surfaceAlt }]}>
                    <Text style={[styles.resourceTagText, { color: '#00BCD4' }]}>{tag}</Text>
                  </View>
                ))}
              </View>
            </View>

            {/* Content or Abstract */}
            {selectedResource.content && (
              <>
                {readingHeadings.length > 0 && (
                  <View style={[styles.tocCard, { backgroundColor: theme.surface, borderColor: theme.border }]}>
                    <TouchableOpacity
                      style={styles.tocHeaderRow}
                      onPress={() => setTocExpanded(prev => !prev)}
                    >
                      <View style={styles.tocHeaderLeft}>
                        <View style={[styles.tocBadge, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}>
                          <Ionicons name="list" size={14} color={theme.text} />
                          <Text style={[styles.tocBadgeText, { color: theme.text }]}>Contents</Text>
                        </View>
                        <Text style={[styles.tocTitle, { color: theme.text }]}>Table of Contents</Text>
                      </View>
                      <Ionicons
                        name={tocExpanded ? 'chevron-up' : 'chevron-down'}
                        size={20}
                        color={theme.subtext}
                      />
                    </TouchableOpacity>
                    {tocExpanded && readingHeadings.map((heading, idx) => (
                      <TouchableOpacity
                        key={`${heading.title}-${idx}`}
                        onPress={() => {
                          const y = readingHeadingPositionsRef.current?.[heading.anchor];
                          if (typeof y === 'number') {
                            readingScrollRef.current?.scrollTo({ y: Math.max(0, y - 12), animated: true });
                          }
                        }}
                        style={[styles.tocItem, { paddingLeft: heading.level === 3 ? 18 : heading.level === 2 ? 8 : 0 }]}
                      >
                        <Text style={[styles.tocItemText, { color: theme.textSecondary }]}>
                          {heading.title}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}
              <View style={[styles.readingContent, { backgroundColor: theme.readingBg || theme.cardSolid, borderColor: theme.border }]}>
                <MarkdownContent
                  content={selectedResource.content}
                  styles={styles}
                  theme={theme}
                  onHeadings={setReadingHeadings}
                  onHeadingLayout={(anchor, y) => {
                    if (readingHeadingPositionsRef.current[anchor] === y) return;
                    readingHeadingPositionsRef.current[anchor] = y;
                  }}
                />
              </View>
              </>
            )}

            {isPubMed && selectedResource.abstract && (
              <View style={[styles.abstractBox, { backgroundColor: theme.cardSolid, borderColor: theme.border }]}>
                <Text style={[styles.abstractLabel, { color: '#00BCD4' }]}>Abstract</Text>
                <Text style={[styles.abstractText, { color: theme.textSecondary }]}>{selectedResource.abstract}</Text>
              </View>
            )}

            {/* PubMed Link */}
            {isPubMed && selectedResource.url && (
              <TouchableOpacity
                style={[styles.pubmedLinkButton, { backgroundColor: theme.surfaceAlt, borderColor: '#00BCD4' }]}
                onPress={() => {
                  showAlert(
                    'Open PubMed',
                    `This will open: ${selectedResource.url}`,
                    [
                      { text: 'Cancel', style: 'cancel' },
                      {
                        text: 'Open',
                        onPress: () => {
                          // In a real app, use Linking.openURL
                          showAlert('Link', selectedResource.url);
                        }
                      }
                    ]
                  );
                }}
              >
                <Ionicons name="open-outline" size={20} color="#00BCD4" />
                <Text style={[styles.pubmedLinkText, { color: '#00BCD4' }]}>View on PubMed</Text>
              </TouchableOpacity>
            )}

            {/* Related Questions */}
            {selectedResource.questionIds?.length > 0 && (
              <View style={[styles.relatedSection, { backgroundColor: theme.surface }]}>
                <Text style={[styles.relatedTitle, { color: theme.text }]}>Related Questions</Text>
                <Text style={[styles.relatedText, { color: theme.subtext }]}>
                  This resource covers {selectedResource.questionIds.length} question{selectedResource.questionIds.length !== 1 ? 's' : ''} in the question bank.
                </Text>
                <TouchableOpacity
                  style={styles.practiceRelatedButton}
                  onPress={() => {
                    const relatedQuestions = activeQuestions.filter(q =>
                      selectedResource.questionIds.includes(q.id)
                    );
                    if (relatedQuestions.length > 0) {
                      setQuestions(shuffleArray(relatedQuestions));
                      setCurrentMode(PRACTICE_MODES.CATEGORY);
                      setCurrentIndex(0);
                      setSelectedAnswer(null);
                      setShowExplanation(false);
                      setSessionStats({ correct: 0, incorrect: 0, total: 0 });
                      setShuffledOptions(prepareQuestion(relatedQuestions[0]));
                      setScreen('question');
                    }
                  }}
                >
                  <Text style={styles.practiceRelatedButtonText}>Practice Related Questions</Text>
                </TouchableOpacity>
              </View>
            )}

            <TouchableOpacity
              style={styles.secondaryButton}
              onPress={() => unlockFlashcardsForReading(selectedResource)}
            >
              <Text style={styles.secondaryButtonText}>Unlock Flashcards for this Reading</Text>
            </TouchableOpacity>
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  const renderFlashcardTools = () => {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <View style={styles.navHeader}>
            <TouchableOpacity onPress={() => setScreen('settings')}>
              <Ionicons name="arrow-back" size={28} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.navTitle, { color: theme.text }]}>Flashcard Tools</Text>
            <View style={{ width: 28 }} />
          </View>

          <ScrollView contentContainerStyle={styles.scrollContent}>
            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Unlock by Category</Text>
              <Text style={[styles.settingsSectionSubtitle, { color: theme.subtext }]}>
                Unlock existing flashcards linked to a category
              </Text>
              <View style={styles.categoryList}>
                {Object.keys(activeCategoryMap).map(key => {
                  const label = activeCategoryMap[key].name;
                  return (
                    <TouchableOpacity
                      key={key}
                      style={[styles.categoryItem, { borderColor: theme.border }]}
                      onPress={() => unlockFlashcardsForCategory(key)}
                    >
                      <Text style={[styles.categoryItemText, { color: theme.text }]}>
                        {label}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </View>
            </View>

            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Unlock by Tag</Text>
              <Text style={[styles.settingsSectionSubtitle, { color: theme.subtext }]}>
                Enter a tag to unlock matching flashcards
              </Text>
              <View style={styles.customIntervalRow}>
                <TextInput
                  style={styles.customIntervalInput}
                  placeholder="e.g. anatomy"
                  placeholderTextColor="#666"
                  value={flashcardToolsTag}
                  onChangeText={setFlashcardToolsTag}
                  autoCapitalize="none"
                />
                <TouchableOpacity
                  style={styles.customIntervalButton}
                  onPress={() => unlockFlashcardsForTag(flashcardToolsTag)}
                >
                  <Text style={styles.customIntervalButtonText}>Unlock</Text>
                </TouchableOpacity>
              </View>
            </View>

            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Unlock from Progress</Text>
              <Text style={[styles.settingsSectionSubtitle, { color: theme.subtext }]}>
                Unlock flashcards related to missed or difficult questions
              </Text>
              <TouchableOpacity
                style={styles.secondaryButton}
                onPress={() => unlockFlashcardsForQuestionIds(missedOrDifficultIdsOverall, 'for missed/difficult questions')}
              >
                <Text style={styles.secondaryButtonText}>Unlock Missed/Difficult</Text>
              </TouchableOpacity>
            </View>

            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Leech Protection</Text>
              <Text style={[styles.settingsSectionSubtitle, { color: theme.subtext }]}>
                Auto-suspend cards after repeated lapses
              </Text>
              <View style={styles.settingsItem}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(244, 67, 54, 0.15)' }]}>
                    <Ionicons name="warning-outline" size={20} color="#F44336" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Leech threshold</Text>
                </View>
                <View style={styles.microTestSizeControls}>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setSrsSettings(prev => ({
                      ...prev,
                      leechThreshold: Math.max(3, (prev.leechThreshold || 8) - 1)
                    }))}
                  >
                    <Ionicons name="remove" size={16} color={theme.text} />
                  </TouchableOpacity>
                  <Text style={[styles.microTestSizeValue, { color: theme.text }]}>
                    {Math.max(3, Math.min(12, srsSettings.leechThreshold || 8))}
                  </Text>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setSrsSettings(prev => ({
                      ...prev,
                      leechThreshold: Math.min(12, (prev.leechThreshold || 8) + 1)
                    }))}
                  >
                    <Ionicons name="add" size={16} color={theme.text} />
                  </TouchableOpacity>
                </View>
              </View>

              <View style={styles.settingsItem}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 152, 0, 0.15)' }]}>
                    <Ionicons name="calendar-outline" size={20} color="#FF9800" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Leech window (days)</Text>
                </View>
                <View style={styles.microTestSizeControls}>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setSrsSettings(prev => ({
                      ...prev,
                      leechWindowDays: Math.max(7, (prev.leechWindowDays || 30) - 1)
                    }))}
                  >
                    <Ionicons name="remove" size={16} color={theme.text} />
                  </TouchableOpacity>
                  <Text style={[styles.microTestSizeValue, { color: theme.text }]}>
                    {Math.max(7, Math.min(60, srsSettings.leechWindowDays || 30))}
                  </Text>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setSrsSettings(prev => ({
                      ...prev,
                      leechWindowDays: Math.min(60, (prev.leechWindowDays || 30) + 1)
                    }))}
                  >
                    <Ionicons name="add" size={16} color={theme.text} />
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  const renderReviewLogsDebug = () => {
    const logs = Array.isArray(reviewLogs) ? reviewLogs.slice(0, 200) : [];
    const payload = JSON.stringify(logs, null, 2);
    const handleCopy = () => {
      if (Platform.OS === 'web' && navigator?.clipboard?.writeText) {
        navigator.clipboard.writeText(payload).then(() => {
          showAlert('Copied', 'Review logs JSON copied to clipboard.');
        }).catch(() => {
          showAlert('Copy Failed', 'Could not copy logs. Please select and copy manually.');
        });
      } else {
        showAlert('Export', 'Review logs are shown below. Select and copy them.');
      }
    };

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <View style={styles.navHeader}>
            <TouchableOpacity onPress={() => setScreen('settings')}>
              <Ionicons name="arrow-back" size={28} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.navTitle, { color: theme.text }]}>Review Logs (Debug)</Text>
            <View style={{ width: 28 }} />
          </View>

          <ScrollView contentContainerStyle={styles.scrollContent}>
            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Last {logs.length} Logs</Text>
              <Text style={[styles.settingsSectionSubtitle, { color: theme.subtext }]}>
                Export JSON for analysis (alpha testers only)
              </Text>
              <TouchableOpacity style={styles.secondaryButton} onPress={handleCopy}>
                <Text style={styles.secondaryButtonText}>Copy JSON</Text>
              </TouchableOpacity>
            </View>

            <View style={[styles.reviewLogBox, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.reviewLogText, { color: theme.textSecondary }]} selectable>
                {payload}
              </Text>
            </View>
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // ============ PET SYSTEM FUNCTIONS ============

  // Claim first free egg
  const claimFirstEgg = () => {
    if (petData?.firstEggClaimed) return;

    const newPet = createPet('mystery', 'Egg', 'room_1');
    const updatedPetData = {
      ...petData,
      pets: [...(petData?.pets || []), newPet],
      activePetId: newPet.id,
      firstEggClaimed: true,
    };

    // Initialize pet position in room
    const updatedRoomData = initializePetPosition(roomData, newPet.id, 'room_1');

    setPetData(updatedPetData);
    setRoomData(updatedRoomData);
    setSelectedPetId(newPet.id);
    savePetData(updatedPetData);
    saveRoomData(updatedRoomData);

    showAlert('Congratulations!', 'You received a mystery egg! Watch it grow as you study!');
  };

  // Buy an egg from shop
  const buyEgg = (speciesId) => {
    const species = PET_SPECIES[speciesId];
    if (!species || !canAddPet(petData)) return;

    const tierLabel = species.group ? `Tier ${species.group}` : 'Mystery';
    const updatedCoins = spendCoins(coinData, species.eggPrice, `Mystery Egg (${tierLabel})`);
    if (!updatedCoins) {
      showAlert('Not Enough Coins', `You need ${species.eggPrice} coins to buy this egg.`);
      return;
    }

    const newPet = createPet('mystery', 'Egg', selectedRoom || 'room_1', species.group || null);
    const updatedPetData = {
      ...petData,
      pets: [...petData.pets, newPet],
    };
    const updatedRoomData = initializePetPosition(roomData, newPet.id, selectedRoom || 'room_1');

    setCoinData(updatedCoins);
    setPetData(updatedPetData);
    setRoomData(updatedRoomData);
    saveCoinData(updatedCoins);
    savePetData(updatedPetData);
    saveRoomData(updatedRoomData);

    showAlert('Egg Purchased!', `You got a mystery egg (${tierLabel})!`);
  };

  // Buy a shop item
  const buyItem = (itemId) => {
    const item = getItemById(itemId);
    if (!item) return;

    if (shopData?.ownedItems?.includes(itemId)) {
      showAlert('Already Owned', 'You already own this item!');
      return;
    }

    const updatedCoins = spendCoins(coinData, item.price, item.name);
    if (!updatedCoins) {
      showAlert('Not Enough Coins', `You need ${item.price} coins to buy ${item.name}.`);
      return;
    }

    const updatedShopData = {
      ...shopData,
      ownedItems: [...(shopData?.ownedItems || []), itemId],
    };

    setCoinData(updatedCoins);
    setShopData(updatedShopData);
    saveCoinData(updatedCoins);
    saveShopData(updatedShopData);

    showAlert('Purchased!', `You bought ${item.name}!`);
  };

  // Expand rooms
  const expandHome = () => {
    const nextExpansion = getNextExpansion(roomData);
    if (!nextExpansion) {
      showAlert('Max Rooms', 'You have reached the maximum number of rooms!');
      return;
    }

    const updatedCoins = spendCoins(coinData, nextExpansion.price, nextExpansion.name);
    if (!updatedCoins) {
      showAlert('Not Enough Coins', `You need ${nextExpansion.price} coins for ${nextExpansion.name}.`);
      return;
    }

    const updatedRoomData = addRoom(roomData, nextExpansion.name);
    setCoinData(updatedCoins);
    setRoomData(updatedRoomData);
    saveCoinData(updatedCoins);
    saveRoomData(updatedRoomData);

    showAlert('Room Added!', `${nextExpansion.name} has been built!`);
  };

  // Feed active pet a treat
  const feedActivePet = (treatItemId) => {
    if (!selectedPetId || !petData?.pets?.length) return;

    const treatItem = getItemById(treatItemId);
    if (!treatItem || !shopData?.ownedItems?.includes(treatItemId)) return;

    const petIndex = petData.pets.findIndex(p => p.id === selectedPetId);
    if (petIndex === -1) return;

    // Remove treat from inventory (consumable)
    const updatedShopData = {
      ...shopData,
      ownedItems: shopData.ownedItems.filter((id, idx) =>
        !(id === treatItemId && shopData.ownedItems.indexOf(treatItemId) === idx)
      ),
    };

    // Feed pet
    const fedPet = feedPet(petData.pets[petIndex]);
    const updatedPets = [...petData.pets];
    updatedPets[petIndex] = fedPet;
    const updatedPetData = { ...petData, pets: updatedPets };

    setShopData(updatedShopData);
    setPetData(updatedPetData);
    saveShopData(updatedShopData);
    savePetData(updatedPetData);
    setPetInteractionTick(Date.now());
  };

  const openRenamePet = () => {
    if (!selectedPetId || !petData?.pets?.length) return;
    const activePet = petData.pets.find(p => p.id === selectedPetId);
    if (!activePet) return;
    setRenameText(activePet.name || '');
    setShowRenameModal(true);
  };

  const handleRenamePet = () => {
    if (!selectedPetId || !petData?.pets?.length) return;
    const name = (renameText || '').trim();
    if (!name) {
      showAlert('Name Required', 'Please enter a pet name.');
      return;
    }
    const petIndex = petData.pets.findIndex(p => p.id === selectedPetId);
    if (petIndex === -1) return;
    const renamed = renamePet(petData.pets[petIndex], name);
    const updatedPets = [...petData.pets];
    updatedPets[petIndex] = renamed;
    const updatedPetData = { ...petData, pets: updatedPets };
    setPetData(updatedPetData);
    savePetData(updatedPetData);
    if (user?.uid) {
      updateUserDataInCloud(user.uid, { petData: updatedPetData }).catch(err => {
        console.error('[CloudSync] Error syncing pet rename:', err);
        recordCloudError(err);
      });
    }
    setShowRenameModal(false);
    setPetInteractionTick(Date.now());
  };

  const handlePetEvolution = (pet, newStage, previousSpeciesId) => {
    if (newStage === PET_STAGES.HATCHLING) {
      // Egg hatching - show the hatch modal
      setHatchingEgg({
        petId: pet.id,
        speciesId: pet.speciesId,
        previousSpeciesId: previousSpeciesId,
        name: pet.name,
      });
      setNewPetName(pet.name);
      setShowEggHatchModal(true);
    } else {
      showAlert(
        'Evolution!',
        `${pet.name} evolved into a ${STAGE_NAMES[newStage]}!`,
        [{ text: 'Awesome!' }]
      );
    }
  };

  const handleHatchConfirm = () => {
    if (!hatchingEgg || !petData?.pets?.length) {
      setShowEggHatchModal(false);
      setHatchingEgg(null);
      return;
    }
    const name = (newPetName || '').trim();
    if (!name) {
      showAlert('Name Required', 'Please give your new pet a name!');
      return;
    }
    const petIndex = petData.pets.findIndex(p => p.id === hatchingEgg.petId);
    if (petIndex === -1) {
      setShowEggHatchModal(false);
      setHatchingEgg(null);
      return;
    }
    const renamed = renamePet(petData.pets[petIndex], name);
    const updatedPets = [...petData.pets];
    updatedPets[petIndex] = renamed;
    const updatedPetData = {
      ...petData,
      pets: updatedPets,
      totalPetsHatched: (petData.totalPetsHatched || 0) + 1,
    };
    const hatchGameResult = applyGameMetrics([
      { metric: 'pets_hatched', delta: 1 },
    ]);
    setPetData(updatedPetData);
    savePetData(updatedPetData);
    if (hatchGameResult.rewardCoins > 0 && hatchGameResult.coinData) {
      setShowCoinEarnedToast({
        amount: hatchGameResult.rewardCoins,
        source: 'Pet milestone reward',
      });
      setTimeout(() => setShowCoinEarnedToast(null), 2500);
    }
    if (user?.uid) {
      updateUserDataInCloud(user.uid, { petData: updatedPetData }).catch(err => {
        console.error('[CloudSync] Error syncing pet hatch:', err);
        recordCloudError(err);
      });
    }
    setPetInteractionTick(Date.now());
    setShowEggHatchModal(false);
    setHatchingEgg(null);
  };

  const buildBattlePerformance = () => {
    const recentSessions = (sessionHistory || []).slice(0, 5);
    const aggregate = recentSessions.reduce((acc, session) => {
      acc.total += session?.total || 0;
      acc.correct += session?.correct || 0;
      return acc;
    }, { total: 0, correct: 0 });

    const streak = coinData?.loginStreak || 0;
    const total = aggregate.total || 0;
    const accuracy = total > 0 ? (aggregate.correct / total) : 0;
    return {
      questionsAnswered: total,
      accuracy,
      studyStreak: streak,
    };
  };

  const startPetBattle = () => {
    const currentProgress = ensureGameProgress(gameProgress);
    if (currentProgress.battleModeEnabled === false) {
      showAlert('Battle Mode Disabled', 'Battle mode is currently disabled for this profile.');
      return;
    }

    if (!petData?.pets?.length || !selectedPetId) {
      showAlert('No Active Pet', 'Claim or select a pet before starting a battle.');
      return;
    }

    const activePet = petData.pets.find(p => p.id === selectedPetId);
    if (!activePet) {
      showAlert('No Active Pet', 'Please select a pet first.');
      return;
    }

    const performance = buildBattlePerformance();
    const battleOutcome = runPracticeBattle({
      battleData: currentProgress.battleData || createInitialBattleData(),
      pet: activePet,
      performance,
      now: Date.now(),
    });

    if (!battleOutcome.success) {
      if (battleOutcome.eligibility?.reason === 'cooldown') {
        const remainingMinutes = Math.max(1, Math.ceil((battleOutcome.eligibility.remainingMs || 0) / 60000));
        showAlert('Battle Cooldown', `Your next battle unlocks in about ${remainingMinutes} minute(s).`);
      } else if (battleOutcome.eligibility?.reason === 'study_gate') {
        showAlert(
          'Study Gate',
          `Complete at least ${battleOutcome.eligibility.required} recent questions to unlock battle mode.`
        );
      } else {
        showAlert('Battle Unavailable', 'You cannot start a battle right now.');
      }
      return;
    }

    const { result, battleData } = battleOutcome;
    setLastBattleResult(result);
    const nextProgress = setBattleDataOnProgress(currentProgress, battleData);
    setGameProgress(nextProgress);
    saveGameProgress(nextProgress);

    let nextCoins = coinData;
    if (coinData && result.rewards.coins > 0) {
      nextCoins = awardCoins(coinData, result.rewards.coins, 'battle_reward');
      setCoinData(nextCoins);
      saveCoinData(nextCoins);
    }

    if (petData && selectedPetId) {
      const petIndex = petData.pets.findIndex(p => p.id === selectedPetId);
      if (petIndex !== -1) {
        const previousSpeciesId = petData.pets[petIndex].speciesId;
        const { pet: updatedPet, evolved, newStage } = addExperience(petData.pets[petIndex], result.rewards.xp || 0);
        const moodBoost = result.outcome === 'win'
          ? HAPPINESS_BOOSTS.SESSION_COMPLETE
          : Math.max(2, Math.floor(HAPPINESS_BOOSTS.SESSION_COMPLETE / 2));
        const happyPet = updateHappiness(updatedPet, moodBoost);
        const updatedPets = [...petData.pets];
        updatedPets[petIndex] = happyPet;
        const updatedPetData = { ...petData, pets: updatedPets };
        setPetData(updatedPetData);
        savePetData(updatedPetData);
        if (evolved) {
          setTimeout(() => handlePetEvolution(happyPet, newStage, previousSpeciesId), 500);
        }
      }
    }

    queueCloudUpdate({
      gameProgress: nextProgress,
      ...(nextCoins ? { coinData: nextCoins } : {}),
    }, { deferHeavy: true });

    if (PROGRESS_SERVER_FIRST && user?.uid) {
      recordBattleResult(user.uid, {
        battleId: result.id,
        outcome: result.outcome,
        playerPower: result.playerPower,
        enemyPower: result.enemyPower,
        rewards: result.rewards,
        performance: result.performance,
      });
    }

    setShowCoinEarnedToast({
      amount: result.rewards.coins || 0,
      source: result.outcome === 'win' ? 'Battle won!' : 'Battle complete',
    });
    setTimeout(() => setShowCoinEarnedToast(null), 2000);
  };

  const handleReleasePet = () => {
    if (!selectedPetId || !petData?.pets?.length) return;
    const targetPet = petData.pets.find(p => p.id === selectedPetId);
    if (!targetPet) return;
    showAlert(
      'Say Goodbye',
      `Release ${targetPet.name}? This cannot be undone.`,
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Release',
          style: 'destructive',
          onPress: () => {
            const remaining = petData.pets.filter(p => p.id !== selectedPetId);
            const nextActive = remaining[0]?.id || null;
            const updatedPetData = {
              ...petData,
              pets: remaining,
              activePetId: nextActive,
            };
            setPetData(updatedPetData);
            setSelectedPetId(nextActive);
            if (nextActive && remaining[0]?.roomId) {
              setSelectedRoom(remaining[0].roomId);
            }
            savePetData(updatedPetData);
            if (user?.uid) {
              updateUserDataInCloud(user.uid, { petData: updatedPetData }).catch(err => {
                console.error('[CloudSync] Error syncing pet release:', err);
                recordCloudError(err);
              });
            }
          },
        },
      ]
    );
  };

  const handleDevEvolvePet = () => {
    if (!selectedPetId || !petData?.pets?.length) return;
    const petIndex = petData.pets.findIndex(p => p.id === selectedPetId);
    if (petIndex === -1) return;
    let updatedPet = petData.pets[petIndex];
    let guard = 0;
    while (updatedPet.stage < PET_STAGES.ADULT && guard < 5) {
      const nextThreshold = STAGE_THRESHOLDS[updatedPet.stage + 1] || (updatedPet.experience + 100);
      const gain = Math.max(1, nextThreshold - (updatedPet.experience || 0) + 1);
      updatedPet = addExperience(updatedPet, gain).pet;
      guard += 1;
    }
    const updatedPets = [...petData.pets];
    updatedPets[petIndex] = updatedPet;
    const updatedPetData = { ...petData, pets: updatedPets };
    setPetData(updatedPetData);
    savePetData(updatedPetData);
    if (user?.uid) {
      updateUserDataInCloud(user.uid, { petData: updatedPetData }).catch(err => {
        console.error('[CloudSync] Error syncing pet evolve:', err);
        recordCloudError(err);
      });
    }
    setPetInteractionTick(Date.now());
  };

  const DraggableFurniture = ({ item, placement, roomSize, isEditing }) => {
    const pan = useRef(new Animated.ValueXY()).current;
    const panResponder = useRef(
      PanResponder.create({
        onStartShouldSetPanResponder: () => isEditing,
        onMoveShouldSetPanResponder: () => isEditing,
        onPanResponderMove: Animated.event([null, { dx: pan.x, dy: pan.y }], { useNativeDriver: false }),
        onPanResponderRelease: (_, gesture) => {
          if (!roomSize) {
            pan.setValue({ x: 0, y: 0 });
            return;
          }
          const nextX = Math.max(0, Math.min(100, placement.x + (gesture.dx / roomSize.width) * 100));
          const nextY = Math.max(0, Math.min(100, placement.y + (gesture.dy / roomSize.height) * 100));
          const updated = moveFurniture(roomData, selectedRoom || 'room_1', placement.instanceId, nextX, nextY);
          setRoomData(updated);
          saveRoomData(updated);
          pan.setValue({ x: 0, y: 0 });
        },
      })
    ).current;

    useEffect(() => {
      pan.setValue({ x: 0, y: 0 });
    }, [placement.x, placement.y, pan]);

    return (
      <Animated.View
        style={[
          styles.placedFurniture,
          { left: `${placement.x}%`, top: `${placement.y}%` },
          isEditing && { zIndex: 2 },
          { transform: pan.getTranslateTransform() },
        ]}
        {...(isEditing ? panResponder.panHandlers : {})}
      >
        <Pressable
          onLongPress={() => {
            if (!isEditing) return;
            showAlert(
              'Remove Furniture',
              `Remove ${item.name}?`,
              [
                { text: 'Cancel', style: 'cancel' },
                {
                  text: 'Remove',
                  style: 'destructive',
                  onPress: () => {
                    const updated = removeFurniture(roomData, selectedRoom || 'room_1', placement.instanceId);
                    setRoomData(updated);
                    saveRoomData(updated);
                  }
                }
              ]
            );
          }}
        >
          <Text style={styles.furnitureEmoji}>{item.emoji}</Text>
        </Pressable>
      </Animated.View>
    );
  };

  // Render Pet Screen
  const renderPetScreen = () => {
    const showPetFeatures = learningSettings.showPetFeatures !== false;
    if (!showPetFeatures) {
      return (
        <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
          <StatusBar style={theme.statusBar} />
          <LinearGradient colors={theme.bg} style={styles.gradient}>
            <View style={styles.loadingContainer}>
              <Ionicons name="paw-outline" size={56} color={theme.subtext} />
              <Text style={[styles.loadingText, { color: theme.text }]}>Pet features are hidden</Text>
              <Text style={[styles.bannedText, { color: theme.subtext }]}>
                Turn on pet features in Settings to access your pets and shop.
              </Text>
              <TouchableOpacity style={styles.bannedButton} onPress={() => setScreen('settings')}>
                <Text style={styles.bannedButtonText}>Go to Settings</Text>
              </TouchableOpacity>
            </View>
          </LinearGradient>
        </SafeAreaView>
      );
    }
    const activePet = petData?.pets?.find(p => p.id === selectedPetId);
    const displayInfo = activePet ? getPetDisplayInfo(activePet) : null;
    const currentRoom = getRoomById(roomData, selectedRoom || 'room_1');
    const petScreenBgItem = getItemById(currentRoom?.backgroundId);
    const petScreenBgColors = petScreenBgItem?.colors;
    const driftPrimary = roomFloat.interpolate({ inputRange: [0, 1], outputRange: [-10, 10] });
    const driftSecondary = roomFloatAlt.interpolate({ inputRange: [0, 1], outputRange: [8, -8] });
    const blobScale = roomFloat.interpolate({ inputRange: [0, 1], outputRange: [1, 1.08] });

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          {/* Header */}
          <View style={styles.petHeader}>
            <TouchableOpacity onPress={() => setScreen('home')} style={styles.backButton}>
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.petHeaderTitle, { color: theme.text }]}>My Pets</Text>
            <View style={styles.coinDisplay}>
              <Ionicons name="wallet" size={18} color="#FFD700" />
              <Text style={styles.coinText}>{formatCoins(coinData?.balance || 0)}</Text>
            </View>
          </View>

          <ScrollView contentContainerStyle={styles.scrollContent}>
            {/* Room View */}
            <View style={styles.roomContainer}>
              <LinearGradient
                colors={petScreenBgColors || (isDark ? ['#2a2a4e', '#2a2a4e'] : ['#e8e8e8', '#e8e8e8'])}
                style={[styles.roomView]}
              >
                <View style={styles.roomBackdrop}>
                  <Animated.View
                    style={[
                      styles.roomBlob,
                      {
                        backgroundColor: theme.accentSoft,
                        transform: [{ translateX: driftPrimary }, { translateY: driftSecondary }, { scale: blobScale }],
                      },
                    ]}
                  />
                  <Animated.View
                    style={[
                      styles.roomBlobSecondary,
                      {
                        backgroundColor: theme.badgeBg,
                        transform: [{ translateX: driftSecondary }, { translateY: driftPrimary }],
                      },
                    ]}
                  />
                  <View style={[styles.roomFloor, { backgroundColor: isDark ? 'rgba(0,0,0,0.25)' : 'rgba(0,0,0,0.1)' }]} />
                </View>
                {/* Pet Display */}
                {activePet ? (
                  <View style={styles.petDisplay}>
                    <PetSprite
                      speciesId={activePet.speciesId}
                      stage={activePet.stage}
                      size={140}
                      moodColor={displayInfo.mood.color}
                      themeOverride={theme}
                      interactionKey={petInteractionTick}
                      petId={activePet.id}
                      eggGroup={activePet.eggGroup}
                      style={{ marginBottom: 8 }}
                    />
                    <View style={[styles.petMoodBubble, { backgroundColor: displayInfo.mood.color }]}>
                      <Text style={styles.petMoodEmoji}>{displayInfo.mood.emoji}</Text>
                    </View>
                  </View>
                ) : (
                  <View style={styles.petDisplay}>
                    <Text style={styles.petBigEmoji}></Text>
                    <Text style={[styles.emptyRoomText, { color: theme.subtext }]}>No pet here yet!</Text>
                  </View>
                )}

                {/* Room Furniture Preview */}
                {currentRoom?.furniture?.slice(0, 3).map((f, idx) => {
                  const item = getItemById(f.itemId);
                  return item ? (
                    <View key={f.instanceId} style={[styles.miniFurniture, { left: 20 + idx * 30, bottom: 10 }]}>
                      <Text>{item.emoji}</Text>
                    </View>
                  ) : null;
                })}
              </LinearGradient>

              {/* Room Selector */}
              <ScrollView horizontal style={styles.roomSelector} showsHorizontalScrollIndicator={false}>
                {roomData?.rooms?.map(room => (
                  <TouchableOpacity
                    key={room.id}
                    style={[
                      styles.roomTab,
                      { backgroundColor: theme.card },
                      selectedRoom === room.id && styles.roomTabActive
                    ]}
                    onPress={() => setSelectedRoom(room.id)}
                  >
                    <Text style={[styles.roomTabText, { color: theme.text }]}>{room.name}</Text>
                  </TouchableOpacity>
                ))}
                {canExpandRooms(roomData) && (
                  <TouchableOpacity style={styles.roomTabAdd} onPress={expandHome}>
                    <Ionicons name="add" size={20} color="#4CAF50" />
                    <Text style={styles.roomTabAddText}>
                      {getNextExpansion(roomData)?.price || 0}
                    </Text>
                  </TouchableOpacity>
                )}
              </ScrollView>
            </View>

            {/* Pet Info Card */}
            {activePet && displayInfo && (
              <View style={[styles.petInfoCard, { backgroundColor: theme.card }]}>
                <View style={styles.petInfoHeader}>
                  <Text style={[styles.petInfoName, { color: theme.text }]}>{displayInfo.name}</Text>
                  <Text style={[styles.petInfoStage, { color: theme.subtext }]}>{displayInfo.stageName} {displayInfo.speciesName}</Text>
                </View>

                {/* XP Bar */}
                <View style={styles.petStatRow}>
                  <Text style={[styles.petStatLabel, { color: theme.subtext }]}>XP</Text>
                  <View style={[styles.petProgressBar, { backgroundColor: theme.border }]}>
                    <View style={[styles.petProgressFill, { width: `${displayInfo.xpProgress.percentage}%`, backgroundColor: '#4CAF50' }]} />
                  </View>
                  <Text style={[styles.petStatValue, { color: theme.textSecondary }]}>
                    {displayInfo.xpProgress.current}/{displayInfo.xpProgress.required}
                  </Text>
                </View>

                {/* Happiness Bar */}
                <View style={styles.petStatRow}>
                  <Text style={[styles.petStatLabel, { color: theme.subtext }]}>Mood</Text>
                  <View style={[styles.petProgressBar, { backgroundColor: theme.border }]}>
                    <View style={[styles.petProgressFill, { width: `${activePet.happiness}%`, backgroundColor: displayInfo.mood.color }]} />
                  </View>
                  <Text style={[styles.petStatValue, { color: theme.textSecondary }]}>{displayInfo.mood.mood}</Text>
                </View>
              </View>
            )}

            {/* Pet Selector */}
            {petData?.pets?.length > 0 && (
              <View style={styles.petSelectorContainer}>
                <Text style={[styles.sectionLabel, { color: theme.text }]}>Your Pets ({petData.pets.length}/{MAX_PETS})</Text>
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                  {petData.pets.map(pet => {
                    const info = getPetDisplayInfo(pet);
                    return (
                      <TouchableOpacity
                        key={pet.id}
                        style={[
                          styles.petSelectorItem,
                          { backgroundColor: theme.card },
                          selectedPetId === pet.id && styles.petSelectorItemActive
                        ]}
                        onPress={() => {
                          setSelectedPetId(pet.id);
                          setSelectedRoom(pet.roomId);
                          const updatedPetData = { ...petData, activePetId: pet.id };
                          setPetData(updatedPetData);
                          savePetData(updatedPetData);
                        }}
                      >
                        <PetSprite
                          speciesId={pet.speciesId}
                          stage={pet.stage}
                          size={44}
                          moodColor={info.mood.color}
                          themeOverride={theme}
                          petId={pet.id}
                          eggGroup={pet.eggGroup}
                          style={{ marginBottom: 4 }}
                        />
                        <Text style={[styles.petSelectorName, { color: theme.text }]}>{pet.name}</Text>
                      </TouchableOpacity>
                    );
                  })}
                </ScrollView>
              </View>
            )}

            {/* First Egg Claim */}
            {!petData?.firstEggClaimed && (
              <TouchableOpacity style={[styles.claimEggButton, { backgroundColor: theme.card }]} onPress={claimFirstEgg}>
                  <PetSprite
                    speciesId={PET_SPECIES.mystery.id}
                    stage={PET_STAGES.EGG}
                    size={54}
                    themeOverride={theme}
                    petId="preview_claim"
                    style={{ marginRight: 12 }}
                  />
                <View>
                  <Text style={[styles.claimEggTitle, { color: theme.text }]}>Claim Your Free Pet!</Text>
                    <Text style={[styles.claimEggSubtitle, { color: theme.subtext }]}>Get a mystery egg to start your journey</Text>
                </View>
                <Ionicons name="gift" size={24} color="#4CAF50" />
              </TouchableOpacity>
            )}

            {/* Action Buttons */}
            <View style={styles.petActions}>
              <TouchableOpacity
                style={[styles.petActionButton, { backgroundColor: theme.card }]}
                onPress={() => setScreen('pet-shop')}
              >
                <Ionicons name="cart-outline" size={28} color={theme.text} />
                <Text style={[styles.petActionText, { color: theme.text }]}>Shop</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.petActionButton, { backgroundColor: theme.card }]}
                onPress={() => {
                  setIsDecorating(true);
                  setScreen('room-decorator');
                }}
              >
                <Ionicons name="brush-outline" size={28} color={theme.text} />
                <Text style={[styles.petActionText, { color: theme.text }]}>Decorate</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.petActionButton, { backgroundColor: theme.card }]}
                onPress={() => setScreen('battle')}
              >
                <Ionicons name="shield-outline" size={28} color={theme.text} />
                <Text style={[styles.petActionText, { color: theme.text }]}>Battle</Text>
              </TouchableOpacity>

              {activePet && (
                <TouchableOpacity
                  style={[styles.petActionButton, { backgroundColor: theme.card }]}
                  onPress={() => {
                    const updatedPet = interactWithPet(activePet);
                    const updatedPets = petData.pets.map(p =>
                      p.id === activePet.id ? updatedPet : p
                    );
                    const updatedPetData = { ...petData, pets: updatedPets };
                    setPetData(updatedPetData);
                    savePetData(updatedPetData);
                    setPetInteractionTick(Date.now());
                  }}
                >
                  <Ionicons name="heart-outline" size={28} color={theme.text} />
                  <Text style={[styles.petActionText, { color: theme.text }]}>Pet</Text>
                </TouchableOpacity>
              )}

              {activePet && (
                <TouchableOpacity
                  style={[styles.petActionButton, { backgroundColor: theme.card }]}
                  onPress={openRenamePet}
                >
                  <Ionicons name="create-outline" size={28} color={theme.text} />
                  <Text style={[styles.petActionText, { color: theme.text }]}>Rename</Text>
                </TouchableOpacity>
              )}

              {activePet && (
                <TouchableOpacity
                  style={[styles.petActionButton, { backgroundColor: theme.card }]}
                  onPress={handleReleasePet}
                >
                  <Ionicons name="exit-outline" size={28} color="#FF6B6B" />
                  <Text style={[styles.petActionText, { color: theme.text }]}>Goodbye</Text>
                </TouchableOpacity>
              )}
            </View>

            <Modal transparent visible={showRenameModal} animationType="fade" onRequestClose={() => setShowRenameModal(false)}>
              <Pressable style={styles.modalOverlay} onPress={() => setShowRenameModal(false)}>
                <KeyboardAvoidingView
                  behavior={Platform.OS === 'ios' ? 'padding' : undefined}
                  style={styles.modalKeyboardAvoiding}
                >
                  <Pressable style={[styles.modalContent, { backgroundColor: theme.card, borderColor: theme.border }]} onPress={() => {}}>
                    <Text style={[styles.modalTitle, { color: theme.text }]}>Rename Pet</Text>
                    <Text style={[styles.modalSubtitle, { color: theme.subtext }]}>Pick a new name (max 20 chars)</Text>
                    <TextInput
                      style={[styles.modalInput, { backgroundColor: theme.inputBg, color: theme.text, minHeight: 48 }]}
                      value={renameText}
                      onChangeText={setRenameText}
                      placeholder="Pet name"
                      placeholderTextColor={theme.subtext}
                      maxLength={20}
                    />
                    <View style={styles.modalButtons}>
                      <TouchableOpacity style={[styles.modalButtonCancel, { borderColor: theme.border }]} onPress={() => setShowRenameModal(false)}>
                        <Text style={[styles.modalButtonCancelText, { color: theme.subtext }]}>Cancel</Text>
                      </TouchableOpacity>
                      <TouchableOpacity style={styles.modalButtonSave} onPress={handleRenamePet}>
                        <Text style={styles.modalButtonSaveText}>Save</Text>
                      </TouchableOpacity>
                    </View>
                  </Pressable>
                </KeyboardAvoidingView>
              </Pressable>
            </Modal>
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Render Battle Arena
  const renderBattleArena = () => {
    const showPetFeatures = learningSettings.showPetFeatures !== false;
    if (!showPetFeatures) {
      return (
        <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
          <StatusBar style={theme.statusBar} />
          <LinearGradient colors={theme.bg} style={styles.gradient}>
            <View style={styles.loadingContainer}>
              <Ionicons name="shield-outline" size={56} color={theme.subtext} />
              <Text style={[styles.loadingText, { color: theme.text }]}>Battle mode hidden</Text>
              <Text style={[styles.bannedText, { color: theme.subtext }]}>
                Enable pet features in Settings to access battles.
              </Text>
              <TouchableOpacity style={styles.bannedButton} onPress={() => setScreen('settings')}>
                <Text style={styles.bannedButtonText}>Go to Settings</Text>
              </TouchableOpacity>
            </View>
          </LinearGradient>
        </SafeAreaView>
      );
    }

    const activePet = petData?.pets?.find(p => p.id === selectedPetId) || petData?.pets?.[0] || null;
    const progress = ensureGameProgress(gameProgress);
    const battleData = progress.battleData || createInitialBattleData();
    const cooldown = getBattleCooldown(battleData, Date.now());
    const canBattle = cooldown.ready;
    const cooldownMins = Math.max(1, Math.ceil((cooldown.remainingMs || 0) / 60000));

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <ScrollView contentContainerStyle={styles.scrollContent} style={noSelectStyle}>
            <View style={styles.header}>
              <Text style={[styles.title, { color: theme.text }]}>Battle Arena</Text>
              <Text style={[styles.subtitle, { color: theme.subtext }]}>PvE study battles with deterministic rewards</Text>
            </View>

            <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.statsTitle, { color: theme.progressTitle }]}>Battle Stats</Text>
              <View style={styles.statsRow}>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: theme.text }]}>{battleData.totalBattles || 0}</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Battles</Text>
                </View>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: '#4CAF50' }]}>{battleData.wins || 0}</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Wins</Text>
                </View>
                <View style={styles.statItem}>
                  <Text style={[styles.statNumber, { color: '#FF6B6B' }]}>{battleData.losses || 0}</Text>
                  <Text style={[styles.statLabel, { color: theme.subtext }]}>Losses</Text>
                </View>
              </View>

              <View style={{ marginTop: 14 }}>
                <Text style={[styles.statLabel, { color: theme.subtext, marginBottom: 8 }]}>
                  {canBattle
                    ? 'Ready to battle now'
                    : `Battle cooldown active: ~${cooldownMins} minute(s) remaining`}
                </Text>
                <TouchableOpacity
                  style={[
                    styles.primaryButton,
                    !canBattle && { opacity: 0.55 },
                  ]}
                  onPress={startPetBattle}
                  disabled={!canBattle}
                >
                  <Text style={styles.primaryButtonText}>Start Battle</Text>
                </TouchableOpacity>
              </View>
            </View>

            <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.statsTitle, { color: theme.flashcardsTitle }]}>Active Pet</Text>
              {activePet ? (
                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                  <PetSprite
                    speciesId={activePet.speciesId}
                    stage={activePet.stage}
                    size={58}
                    moodColor={getPetDisplayInfo(activePet).mood.color}
                    themeOverride={theme}
                    petId={activePet.id}
                    eggGroup={activePet.eggGroup}
                  />
                  <View style={{ marginLeft: 12, flex: 1 }}>
                    <Text style={[styles.petWidgetName, { color: theme.text }]}>{activePet.name}</Text>
                    <Text style={[styles.petWidgetStage, { color: theme.subtext }]}>
                      {STAGE_NAMES[activePet.stage] || 'Pet'}  Happiness {Math.round(activePet.happiness || 0)}%
                    </Text>
                  </View>
                </View>
              ) : (
                <Text style={[styles.statLabel, { color: theme.subtext }]}>
                  Claim your first egg in the Pet screen to unlock battle mode.
                </Text>
              )}
            </View>

            {lastBattleResult && (
              <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
                <Text style={[styles.statsTitle, { color: lastBattleResult.outcome === 'win' ? '#4CAF50' : '#FF6B6B' }]}>
                  Last Battle: {lastBattleResult.outcome === 'win' ? 'Victory' : 'Defeat'}
                </Text>
                <Text style={[styles.statLabel, { color: theme.subtext }]}>
                  You {lastBattleResult.playerPower} vs {lastBattleResult.enemyName} {lastBattleResult.enemyPower}
                </Text>
                <Text style={[styles.statLabel, { color: theme.subtext, marginTop: 6 }]}>
                  Rewards: +{lastBattleResult.rewards?.coins || 0} coins, +{lastBattleResult.rewards?.xp || 0} pet XP
                </Text>
              </View>
            )}

            <View style={[styles.statsCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.statsTitle, { color: theme.progressTitle }]}>Recent Battles</Text>
              {(battleData.history || []).length === 0 ? (
                <Text style={[styles.statLabel, { color: theme.subtext }]}>No battles yet.</Text>
              ) : (
                (battleData.history || []).slice(0, 8).map((battle) => (
                  <View
                    key={battle.id}
                    style={{
                      paddingVertical: 8,
                      borderBottomWidth: 1,
                      borderBottomColor: theme.border,
                    }}
                  >
                    <Text style={[styles.statLabel, { color: theme.text }]}>
                      {battle.outcome === 'win' ? 'Win' : 'Loss'}  {battle.enemyName}
                    </Text>
                    <Text style={[styles.statLabel, { color: theme.subtext }]}>
                      +{battle.rewards?.coins || 0} coins, +{battle.rewards?.xp || 0} XP
                    </Text>
                  </View>
                ))
              )}
            </View>

            <TouchableOpacity onPress={() => setScreen('pet')} style={styles.backButton}>
              <Ionicons name="arrow-back" size={20} color={theme.text} />
              <Text style={[styles.backButtonText, { color: theme.text }]}>Back to Pets</Text>
            </TouchableOpacity>
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Render Pet Shop
  const renderPetShop = () => {
    const showPetFeatures = learningSettings.showPetFeatures !== false;
    if (!showPetFeatures) {
      return (
        <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
          <StatusBar style={theme.statusBar} />
          <LinearGradient colors={theme.bg} style={styles.gradient}>
            <View style={styles.loadingContainer}>
              <Ionicons name="cart-outline" size={56} color={theme.subtext} />
              <Text style={[styles.loadingText, { color: theme.text }]}>Pet shop hidden</Text>
              <Text style={[styles.bannedText, { color: theme.subtext }]}>
                Enable pet features in Settings to access the shop.
              </Text>
              <TouchableOpacity style={styles.bannedButton} onPress={() => setScreen('settings')}>
                <Text style={styles.bannedButtonText}>Go to Settings</Text>
              </TouchableOpacity>
            </View>
          </LinearGradient>
        </SafeAreaView>
      );
    }
    const categories = [
      { id: ITEM_CATEGORIES.EGGS, name: 'Eggs', icon: '' },
      { id: ITEM_CATEGORIES.CLOTHING, name: 'Clothing', icon: '' },
      { id: ITEM_CATEGORIES.ACCESSORIES, name: 'Accessories', icon: '' },
      { id: ITEM_CATEGORIES.FURNITURE, name: 'Furniture', icon: '' },
      { id: ITEM_CATEGORIES.BACKGROUNDS, name: 'Backgrounds', icon: '' },
      { id: ITEM_CATEGORIES.TREATS, name: 'Treats', icon: '' },
      { id: ITEM_CATEGORIES.ROOMS, name: 'Rooms', icon: '' },
    ];

    const currentItems = shopCategory === ITEM_CATEGORIES.ROOMS
      ? ROOM_EXPANSIONS.slice(roomData?.unlockedRoomCount || 1)
      : shopCategory === ITEM_CATEGORIES.EGGS
        ? Object.values(PET_SPECIES).filter(s => s.eggPrice > 0)
        : getItemsByCategory(shopCategory);

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          {/* Header */}
          <View style={styles.petHeader}>
            <TouchableOpacity onPress={() => setScreen('pet')} style={styles.backButton}>
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.petHeaderTitle, { color: theme.text }]}>Shop</Text>
            <View style={styles.coinDisplay}>
              <Ionicons name="wallet" size={18} color="#FFD700" />
              <Text style={styles.coinText}>{formatCoins(coinData?.balance || 0)}</Text>
            </View>
          </View>

          {/* Category Tabs */}
          <ScrollView horizontal style={styles.shopCategoryTabs} showsHorizontalScrollIndicator={false}>
            {categories.map(cat => (
              <TouchableOpacity
                key={cat.id}
                style={[
                  styles.shopCategoryTab,
                  { backgroundColor: theme.card },
                  shopCategory === cat.id && styles.shopCategoryTabActive
                ]}
                onPress={() => setShopCategory(cat.id)}
              >
                <Text style={styles.shopCategoryIcon}>{cat.icon}</Text>
                <Text style={[
                  styles.shopCategoryName,
                  { color: theme.subtext },
                  shopCategory === cat.id && styles.shopCategoryNameActive
                ]}>{cat.name}</Text>
              </TouchableOpacity>
            ))}
          </ScrollView>

          {/* Items Grid */}
          <ScrollView contentContainerStyle={styles.shopGrid}>
            {shopCategory === ITEM_CATEGORIES.ROOMS ? (
              // Room expansions
              currentItems.map((expansion, idx) => (
                <TouchableOpacity
                  key={expansion.roomNumber}
                  style={[styles.shopItem, { backgroundColor: theme.card }]}
                  onPress={expandHome}
                  disabled={idx > 0}
                >
                  <Text style={styles.shopItemEmoji}></Text>
                  <Text style={[styles.shopItemName, { color: theme.text }]}>{expansion.name}</Text>
                  <Text style={[styles.shopItemPrice, { color: theme.textSecondary }]}>
                    <Ionicons name="wallet" size={12} color="#FFD700" /> {expansion.price}
                  </Text>
                  {idx > 0 && (
                    <View style={styles.shopItemLocked}>
                      <Ionicons name="lock-closed" size={16} color={theme.subtext} />
                    </View>
                  )}
                </TouchableOpacity>
              ))
            ) : shopCategory === ITEM_CATEGORIES.EGGS ? (
              // Pet eggs
              currentItems.map(species => {
                const canBuy = canAddPet(petData);
                const tierLabel = species.group ? `Tier ${species.group}` : 'Mystery';
                return (
                  <TouchableOpacity
                    key={species.id}
                    style={[styles.shopItem, { backgroundColor: theme.card }, !canBuy && styles.shopItemDisabled]}
                    onPress={() => canBuy && buyEgg(species.id)}
                    disabled={!canBuy}
                  >
                    <Text style={styles.shopItemEmoji}>{PET_SPECIES.mystery.emoji[0]}</Text>
                    <Text style={[styles.shopItemName, { color: theme.text }]}>Mystery Egg</Text>
                    <Text style={[styles.shopItemDesc, { color: theme.subtext }]}>Hatches into a random creature ({tierLabel})</Text>
                    <Text style={[styles.shopItemPrice, { color: theme.textSecondary }]}>
                      <Ionicons name="wallet" size={12} color="#FFD700" /> {species.eggPrice}
                    </Text>
                  </TouchableOpacity>
                );
              })
            ) : (
              // Regular items
              currentItems.map(item => {
                const owned = shopData?.ownedItems?.includes(item.id);
                return (
                  <TouchableOpacity
                    key={item.id}
                    style={[
                      styles.shopItem,
                      { backgroundColor: theme.card },
                      owned && !item.consumable && styles.shopItemDisabled
                    ]}
                    onPress={() => !owned || item.consumable ? buyItem(item.id) : null}
                  >
                    <View style={[styles.shopItemRarity, { backgroundColor: getRarityColor(item.rarity) }]} />
                    <Text style={styles.shopItemEmoji}>{item.emoji}</Text>
                    <Text style={[styles.shopItemName, { color: theme.text }]}>{item.name}</Text>
                    <Text style={[styles.shopItemPrice, { color: theme.textSecondary }]}>
                      <Ionicons name="wallet" size={12} color="#FFD700" /> {item.price}
                    </Text>
                    {owned && !item.consumable && <Text style={styles.shopItemOwned}>Owned</Text>}
                    {item.isMedical && (
                      <View style={styles.medicalBadge}>
                        <Ionicons name="medical" size={12} color="#fff" />
                      </View>
                    )}
                  </TouchableOpacity>
                );
              })
            )}
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Render Room Decorator (simplified version - full drag-drop would need PanResponder)
  const renderRoomDecorator = () => {
    const showPetFeatures = learningSettings.showPetFeatures !== false;
    if (!showPetFeatures) {
      return (
        <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
          <StatusBar style={theme.statusBar} />
          <LinearGradient colors={theme.bg} style={styles.gradient}>
            <View style={styles.loadingContainer}>
              <Ionicons name="brush-outline" size={56} color={theme.subtext} />
              <Text style={[styles.loadingText, { color: theme.text }]}>Room decorator hidden</Text>
              <Text style={[styles.bannedText, { color: theme.subtext }]}>
                Enable pet features in Settings to decorate rooms.
              </Text>
              <TouchableOpacity style={styles.bannedButton} onPress={() => setScreen('settings')}>
                <Text style={styles.bannedButtonText}>Go to Settings</Text>
              </TouchableOpacity>
            </View>
          </LinearGradient>
        </SafeAreaView>
      );
    }
    const currentRoom = getRoomById(roomData, selectedRoom || 'room_1');
    const ownedFurniture = (shopData?.ownedItems || [])
      .map(id => getItemById(id))
      .filter(item => item && [ITEM_CATEGORIES.FURNITURE, ITEM_CATEGORIES.ACCESSORIES].includes(item.category));
    const ownedBackgrounds = (shopData?.ownedItems || [])
      .map(id => getItemById(id))
      .filter(item => item && item.category === ITEM_CATEGORIES.BACKGROUNDS);
    const currentBgItem = getItemById(currentRoom?.backgroundId);
    const roomBgColors = currentBgItem?.colors;

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          {/* Header */}
          <View style={styles.petHeader}>
            <TouchableOpacity onPress={() => setScreen('pet')} style={styles.backButton}>
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.petHeaderTitle, { color: theme.text }]}>Decorate: {currentRoom?.name}</Text>
            <TouchableOpacity onPress={() => setIsDecorating(prev => !prev)}>
              <Ionicons name={isDecorating ? 'checkmark' : 'color-palette'} size={24} color={isDecorating ? '#4CAF50' : theme.text} />
            </TouchableOpacity>
          </View>

          {/* Room View - Large */}
          <LinearGradient
            colors={roomBgColors || (isDark ? ['#2a2a4e', '#1a1a3e'] : ['#e8e8e8', '#d8d8d8'])}
            style={styles.decoratorRoom}
            onLayout={(e) => {
              const { width, height } = e.nativeEvent.layout;
              setRoomLayout({ width, height });
            }}
          >
            {/* Placed Furniture */}
            {currentRoom?.furniture?.map(f => {
              const item = getItemById(f.itemId);
              if (!item) return null;
              return (
                <DraggableFurniture
                  key={f.instanceId}
                  item={item}
                  placement={f}
                  roomSize={roomLayout}
                  isEditing={isDecorating}
                />
              );
            })}

            {/* Tap to place instruction */}
            <Text style={[styles.decoratorHint, { color: theme.subtext }]}>
              {isDecorating ? 'Drag items to reposition. Tap below to place new items.' : 'Tap the palette icon to edit your room.'}
            </Text>
          </LinearGradient>

          {/* Background Selector */}
          {ownedBackgrounds.length > 0 && (
            <View style={[styles.furnitureInventory, { backgroundColor: theme.card }]}>
              <Text style={[styles.inventoryTitle, { color: theme.text }]}>Backgrounds</Text>
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                {ownedBackgrounds.map(bg => {
                  const isActive = currentRoom?.backgroundId === bg.id;
                  return (
                    <TouchableOpacity
                      key={bg.id}
                      style={[
                        styles.inventoryItem,
                        isActive && styles.inventoryItemSelected,
                      ]}
                      onPress={() => {
                        const updated = setRoomBackground(roomData, currentRoom.id, bg.id);
                        setRoomData(updated);
                        saveRoomData(updated);
                      }}
                    >
                      <View style={{
                        width: 36, height: 36, borderRadius: 18,
                        overflow: 'hidden', marginBottom: 4,
                      }}>
                        <LinearGradient colors={bg.colors || ['#ccc', '#eee']} style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
                          <Text style={{ fontSize: 16 }}>{bg.emoji}</Text>
                        </LinearGradient>
                      </View>
                      <Text style={[styles.inventoryName, { color: theme.text }]}>{bg.name}</Text>
                      {isActive && <Ionicons name="checkmark-circle" size={16} color="#4CAF50" />}
                    </TouchableOpacity>
                  );
                })}
              </ScrollView>
            </View>
          )}

          {/* Furniture Inventory */}
          <View style={[styles.furnitureInventory, { backgroundColor: theme.card }]}>
            <Text style={[styles.inventoryTitle, { color: theme.text }]}>Your Furniture</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false}>
              {ownedFurniture.length > 0 ? (
                ownedFurniture.map(item => (
                  <TouchableOpacity
                    key={item.id}
                    style={[
                      styles.inventoryItem,
                      draggedFurniture === item.id && styles.inventoryItemSelected
                    ]}
                    onPress={() => {
                      if (draggedFurniture === item.id) {
                        // Place in center of room
                        const updated = placeFurniture(
                          roomData,
                          currentRoom.id,
                          item.id,
                          30 + Math.random() * 40,
                          40 + Math.random() * 30
                        );
                        setRoomData(updated);
                        saveRoomData(updated);
                        setDraggedFurniture(null);
                      } else {
                        setDraggedFurniture(item.id);
                      }
                    }}
                  >
                    <Text style={styles.inventoryEmoji}>{item.emoji}</Text>
                    <Text style={[styles.inventoryName, { color: theme.text }]}>{item.name}</Text>
                  </TouchableOpacity>
                ))
              ) : (
                <Text style={[styles.noFurnitureText, { color: theme.subtext }]}>
                  No furniture yet! Visit the shop to buy some.
                </Text>
              )}
            </ScrollView>
          </View>

          {/* Room Selector */}
          <View style={styles.decoratorRoomSelector}>
            {roomData?.rooms?.map(room => (
              <TouchableOpacity
                key={room.id}
                style={[
                  styles.roomTab,
                  { backgroundColor: theme.card },
                  selectedRoom === room.id && styles.roomTabActive
                ]}
                onPress={() => setSelectedRoom(room.id)}
              >
                <Text style={[styles.roomTabText, { color: theme.text }]}>{room.name}</Text>
              </TouchableOpacity>
            ))}
          </View>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Show loading screen while auth or data loads
  if (authLoading || isLoading) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <View style={styles.loadingContainer}>
            <Ionicons name="medical-outline" size={64} color="#4CAF50" />
            <Text style={[styles.loadingText, { color: theme.text }]}>Loading your progress...</Text>
          </View>
        </LinearGradient>
      </SafeAreaView>
    );
  }

  if (isBanned) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <View style={styles.bannedContainer}>
            <Ionicons name="ban-outline" size={56} color="#EF5350" />
            <Text style={[styles.bannedTitle, { color: theme.text }]}>Account Restricted</Text>
            <Text style={[styles.bannedText, { color: theme.subtext }]}>
              This account has been disabled. Contact support if you believe this is a mistake.
            </Text>
            {banReason ? (
              <Text style={[styles.bannedReason, { color: theme.subtext }]}>
                Reason: {banReason}
              </Text>
            ) : null}
            <TouchableOpacity style={styles.bannedButton} onPress={logout}>
              <Text style={styles.bannedButtonText}>Sign Out</Text>
            </TouchableOpacity>
          </View>
        </LinearGradient>
      </SafeAreaView>
    );
  }

  if (isApproved === false) {
    const checkApproval = async () => {
      try {
        const profileSnap = await getDoc(doc(db, 'users', user.uid));
        if (profileSnap.exists()) {
          const data = profileSnap.data();
          if (data.approved === true || data.approved === undefined) {
            setIsApproved(true);
          }
        }
      } catch (e) {
        console.error('[Approval] Check failed:', e);
      }
    };
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <View style={styles.bannedContainer}>
            <Ionicons name="hourglass-outline" size={56} color="#FF9800" />
            <Text style={[styles.bannedTitle, { color: theme.text }]}>Awaiting Approval</Text>
            <Text style={[styles.bannedText, { color: theme.subtext }]}>
              Your account is pending approval. You'll be able to access the app once an administrator approves your registration.
            </Text>
            <TouchableOpacity style={[styles.bannedButton, { backgroundColor: '#4f8cff' }]} onPress={checkApproval}>
              <Text style={styles.bannedButtonText}>Check Again</Text>
            </TouchableOpacity>
            <TouchableOpacity style={[styles.bannedButton, { backgroundColor: '#EF5350', marginTop: 10 }]} onPress={logout}>
              <Text style={styles.bannedButtonText}>Sign Out</Text>
            </TouchableOpacity>
          </View>
        </LinearGradient>
      </SafeAreaView>
    );
  }

  // ========== SETTINGS SCREEN ==========
  const renderSettings = () => {
    const stats = overallStats;

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg[0] }]}>
        <StatusBar style={theme.statusBar} />
        <LinearGradient colors={theme.bg} style={styles.gradient}>
          <ScrollView contentContainerStyle={styles.scrollContent}>
            {/* Header */}
            <View style={styles.navHeader}>
              <TouchableOpacity onPress={() => setScreen('home')} style={styles.backButton}>
                <Ionicons name="arrow-back" size={24} color={theme.text} />
              </TouchableOpacity>
              <Text style={[styles.navTitle, { color: theme.text }]}>Settings</Text>
              <View style={{ width: 40 }} />
            </View>

            {/* Account Section */}
            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Account</Text>

              <View style={[styles.settingsUserInfo, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsAvatar}>
                  <Ionicons name="person" size={32} color="#4CAF50" />
                </View>
                <View style={styles.settingsUserDetails}>
                  <Text style={[styles.settingsUserName, { color: theme.text }]}>
                    {user?.displayName || 'User'}
                  </Text>
                  <Text style={[styles.settingsUserEmail, { color: theme.subtext }]}>
                    {user?.email || 'No email'}
                  </Text>
                </View>
                <Ionicons name="checkmark-circle" size={20} color="#4CAF50" />
              </View>

              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={() => {
                  const message = user?.uid
                    ? 'Cloud sync is enabled for this account.'
                    : 'Sign in to enable cloud sync.';
                  showAlert('Sync Status', message);
                }}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(156, 39, 176, 0.15)' }]}>
                    <Ionicons name="cloud-outline" size={20} color="#9C27B0" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Sync Status</Text>
                </View>
                <View style={styles.settingsItemRight}>
                  <Text style={[styles.settingsItemValue, { color: '#4CAF50' }]}>Synced</Text>
                  <Ionicons name="checkmark-circle" size={18} color="#4CAF50" />
                </View>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={async () => {
                  const result = await pullCloudData({ force: true });
                  if (result.success) {
                    showAlert('Cloud Sync', result.skipped ? 'Already up to date.' : 'Synced from cloud.');
                  } else {
                    showAlert('Cloud Sync', result.message || 'Sync failed.');
                  }
                }}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(76, 175, 80, 0.15)' }]}>
                    <Ionicons name="sync-outline" size={20} color="#4CAF50" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Sync Now</Text>
                </View>
                <View style={styles.settingsItemRight}>
                  <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                </View>
              </TouchableOpacity>

              {userRole === 'admin' && (
              <>
              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(0, 188, 212, 0.15)' }]}>
                    <Ionicons name="cloud-done-outline" size={20} color="#00BCD4" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Last Cloud Pull</Text>
                </View>
                <View style={styles.settingsItemRight}>
                  <Text style={[styles.settingsItemValue, { color: theme.subtext }]}>{formatSyncDate(lastCloudPullAt)}</Text>
                </View>
              </View>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(156, 39, 176, 0.15)' }]}>
                    <Ionicons name="cloud-upload-outline" size={20} color="#9C27B0" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Last Cloud Upload</Text>
                </View>
                <View style={styles.settingsItemRight}>
                  <Text style={[styles.settingsItemValue, { color: theme.subtext }]}>{formatSyncDate(lastCloudWriteAt)}</Text>
                </View>
              </View>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 152, 0, 0.15)' }]}>
                    <Ionicons name="layers-outline" size={20} color="#FF9800" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Chunk Sync</Text>
                </View>
                <View style={styles.settingsItemRight}>
                  <Text style={[styles.settingsItemValue, { color: theme.subtext }]}>
                    {cloudChunkMeta
                      ? `fc:${cloudChunkMeta.flashcards || 0} cd:${cloudChunkMeta.cardData || 0} sh:${cloudChunkMeta.sessionHistory || 0} ss:${cloudChunkMeta.savedSessions || 0}`
                      : ''}
                  </Text>
                </View>
              </View>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(76, 175, 80, 0.15)' }]}>
                    <Ionicons name="stats-chart-outline" size={20} color="#4CAF50" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Local Sizes</Text>
                </View>
                <View style={styles.settingsItemRight}>
                  <Text style={[styles.settingsItemValue, { color: theme.subtext }]}>
                    {`fc:${localSyncStats.flashcards} cd:${localSyncStats.cardData} sh:${localSyncStats.sessionHistory} ss:${localSyncStats.savedSessions}`}
                  </Text>
                </View>
              </View>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(244, 67, 54, 0.15)' }]}>
                    <Ionicons name="alert-circle-outline" size={20} color="#F44336" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Last Sync Error</Text>
                </View>
                <View style={styles.settingsItemRight}>
                  <Text style={[styles.settingsItemValue, { color: theme.subtext }]}>
                    {lastCloudError ? `${formatSyncDate(lastCloudErrorAt)}  ${lastCloudError}` : ''}
                  </Text>
                </View>
              </View>

              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={() => {
                  showAlert(
                    'Replace Local With Cloud',
                    'This will overwrite this device with the latest cloud data. Continue?',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      { text: 'Replace', style: 'destructive', onPress: handleReplaceLocalWithCloud },
                    ]
                  );
                }}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(124, 77, 255, 0.15)' }]}>
                    <Ionicons name="cloud-download-outline" size={20} color="#7C4DFF" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Replace Local With Cloud</Text>
                </View>
                <View style={styles.settingsItemRight}>
                  <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                </View>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={() => {
                  if (!user?.uid) {
                    showAlert('Restore', 'Sign in to restore local data.');
                    return;
                  }
                  showAlert(
                    'Restore From This Device',
                    'This will overwrite cloud data with this device\'s local data. Continue?',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      {
                        text: 'Restore',
                        style: 'destructive',
                        onPress: async () => {
                          const result = await saveUserDataToCloud(user.uid, localDataRef.current);
                          if (result?.success) {
                            if (localDataRef.current.flashcards?.length) {
                              await upsertUserFlashcardsBatch(user.uid, localDataRef.current.flashcards);
                            }
                            if (localDataRef.current.srsSettings) {
                              await saveUserSrsSettings(user.uid, localDataRef.current.srsSettings);
                            }
                            setLastCloudWriteAt(Date.now());
                            showAlert('Restore Complete', 'Local data uploaded to cloud.');
                          } else {
                            showAlert('Restore Failed', result?.error || 'Unable to restore.');
                          }
                        },
                      },
                    ]
                  );
                }}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 87, 34, 0.15)' }]}>
                    <Ionicons name="cloud-upload" size={20} color="#FF5722" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Restore From This Device</Text>
                </View>
                <View style={styles.settingsItemRight}>
                  <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                </View>
              </TouchableOpacity>
              </>
              )}
            </View>

            {/* Progress Section */}
            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Progress</Text>

              <View style={styles.settingsStatsGrid}>
                <View style={styles.settingsStatBox}>
                  <Text style={styles.settingsStatNumber}>{stats.reviewed}</Text>
                  <Text style={[styles.settingsStatLabel, { color: theme.subtext }]}>Questions</Text>
                </View>
                <View style={styles.settingsStatBox}>
                  <Text style={styles.settingsStatNumber}>{stats.retention}%</Text>
                  <Text style={[styles.settingsStatLabel, { color: theme.subtext }]}>Retention</Text>
                </View>
                <View style={styles.settingsStatBox}>
                  <Text style={styles.settingsStatNumber}>{activeFlashcards.length}</Text>
                  <Text style={[styles.settingsStatLabel, { color: theme.subtext }]}>Flashcards</Text>
                </View>
                <View style={styles.settingsStatBox}>
                  <Text style={styles.settingsStatNumber}>{coinData?.balance || 0}</Text>
                  <Text style={[styles.settingsStatLabel, { color: theme.subtext }]}>Coins</Text>
                </View>
              </View>

              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={() => setScreen('weakness')}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 152, 0, 0.15)' }]}>
                    <Ionicons name="analytics-outline" size={20} color="#FF9800" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Detailed Analytics</Text>
                </View>
                <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={handleResetProgress}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(76, 175, 80, 0.15)' }]}>
                    <Ionicons name="refresh-outline" size={20} color="#4CAF50" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Reset Progress</Text>
                </View>
                <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
              </TouchableOpacity>
            </View>

            {isDevAccount && (
              <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
                <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Dev Tools</Text>

                <TouchableOpacity
                  style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                  onPress={() => handleDevAddCoins(5000)}
                >
                  <View style={styles.settingsItemLeft}>
                    <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 193, 7, 0.15)' }]}>
                      <Ionicons name="cash-outline" size={20} color="#FFC107" />
                    </View>
                    <Text style={[styles.settingsItemText, { color: theme.text }]}>Add 5,000 Coins</Text>
                  </View>
                  <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                  onPress={() => handleDevSpawnPet()}
                >
                  <View style={styles.settingsItemLeft}>
                    <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(76, 175, 80, 0.15)' }]}>
                      <Ionicons name="paw-outline" size={20} color="#4CAF50" />
                    </View>
                    <Text style={[styles.settingsItemText, { color: theme.text }]}>Spawn Debug Pet</Text>
                  </View>
                  <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                  onPress={() => handleDevEvolvePet()}
                >
                  <View style={styles.settingsItemLeft}>
                    <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(124, 77, 255, 0.15)' }]}>
                      <Ionicons name="trending-up-outline" size={20} color="#7C4DFF" />
                    </View>
                    <Text style={[styles.settingsItemText, { color: theme.text }]}>Evolve Active Pet</Text>
                  </View>
                  <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                  onPress={() => setScreen('review-logs-debug')}
                >
                  <View style={styles.settingsItemLeft}>
                    <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(3, 169, 244, 0.15)' }]}>
                      <Ionicons name="document-text-outline" size={20} color="#03A9F4" />
                    </View>
                    <Text style={[styles.settingsItemText, { color: theme.text }]}>Review Logs (Debug)</Text>
                  </View>
                  <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                  onPress={() => {
                    showAlert(
                      'Clear Pets',
                      'This removes all pets and resets pet unlock state. Coins and rooms stay the same.',
                      [
                        { text: 'Cancel', style: 'cancel' },
                        { text: 'Clear', style: 'destructive', onPress: handleDevClearPets },
                      ]
                    );
                  }}
                >
                  <View style={styles.settingsItemLeft}>
                    <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(244, 67, 54, 0.15)' }]}>
                      <Ionicons name="trash-outline" size={20} color="#F44336" />
                    </View>
                    <Text style={[styles.settingsItemText, { color: theme.text }]}>Clear Pets</Text>
                  </View>
                  <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.settingsItem}
                  onPress={() => {
                    showAlert(
                      'Reset Pet System',
                      'This resets pets, coins, shop items, and rooms. This cannot be undone.',
                      [
                        { text: 'Cancel', style: 'cancel' },
                        { text: 'Reset', style: 'destructive', onPress: handleDevResetPetSystem },
                      ]
                    );
                  }}
                >
                  <View style={styles.settingsItemLeft}>
                    <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 87, 34, 0.15)' }]}>
                      <Ionicons name="refresh-outline" size={20} color="#FF5722" />
                    </View>
                    <Text style={[styles.settingsItemText, { color: theme.text }]}>Reset Pet System</Text>
                  </View>
                  <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
                </TouchableOpacity>
              </View>
            )}

            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Learning</Text>

              {userRole === 'admin' && (
              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(0, 188, 212, 0.15)' }]}>
                    <Ionicons name="compass-outline" size={20} color="#00BCD4" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Practice Context</Text>
                </View>
                <View style={styles.customModeRow}>
                  {Object.values(SPECIALTIES).map(specialty => (
                    <TouchableOpacity
                      key={specialty.id}
                      style={[
                        styles.customModePill,
                        { borderColor: theme.border },
                        activePracticeContext === specialty.id && styles.customModePillActive
                      ]}
                      onPress={() => savePracticeContext(specialty.id)}
                    >
                      <Text style={[
                        styles.customModeText,
                        { color: activePracticeContext === specialty.id ? theme.text : theme.subtext }
                      ]}>
                        {specialty.shortName || specialty.name}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </View>
              )}

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(0, 150, 136, 0.15)' }]}>
                    <Ionicons name="shuffle" size={20} color="#009688" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Interleave topics by default</Text>
                </View>
                <TouchableOpacity
                  style={[styles.settingsToggle, learningSettings.interleavingDefault && styles.settingsToggleActive]}
                  onPress={() => setLearningSettings(prev => ({ ...prev, interleavingDefault: !prev.interleavingDefault }))}
                >
                  <View style={[styles.settingsToggleKnob, learningSettings.interleavingDefault && styles.settingsToggleKnobActive]} />
                </TouchableOpacity>
              </View>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 152, 0, 0.15)' }]}>
                    <Ionicons name="repeat-outline" size={20} color="#FF9800" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Prioritize due questions</Text>
                </View>
                <TouchableOpacity
                  style={[styles.settingsToggle, learningSettings.retrievalPriority && styles.settingsToggleActive]}
                  onPress={() => setLearningSettings(prev => ({ ...prev, retrievalPriority: !prev.retrievalPriority }))}
                >
                  <View style={[styles.settingsToggleKnob, learningSettings.retrievalPriority && styles.settingsToggleKnobActive]} />
                </TouchableOpacity>
              </View>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(156, 39, 176, 0.15)' }]}>
                    <Ionicons name="help-circle-outline" size={20} color="#9C27B0" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Ask confidence after answers</Text>
                </View>
                <TouchableOpacity
                  style={[styles.settingsToggle, learningSettings.confidenceRatings && styles.settingsToggleActive]}
                  onPress={() => setLearningSettings(prev => ({ ...prev, confidenceRatings: !prev.confidenceRatings }))}
                >
                  <View style={[styles.settingsToggleKnob, learningSettings.confidenceRatings && styles.settingsToggleKnobActive]} />
                </TouchableOpacity>
              </View>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(33, 150, 243, 0.15)' }]}>
                    <Ionicons name="flash-outline" size={20} color="#2196F3" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Immediate feedback callout</Text>
                </View>
                <TouchableOpacity
                  style={[styles.settingsToggle, learningSettings.immediateFeedback && styles.settingsToggleActive]}
                  onPress={() => setLearningSettings(prev => ({ ...prev, immediateFeedback: !prev.immediateFeedback }))}
                >
                  <View style={[styles.settingsToggleKnob, learningSettings.immediateFeedback && styles.settingsToggleKnobActive]} />
                </TouchableOpacity>
              </View>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 179, 0, 0.15)' }]}>
                    <Ionicons name="book-outline" size={20} color="#FFB300" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Re-show readings on new misses</Text>
                </View>
                <TouchableOpacity
                  style={[styles.settingsToggle, learningSettings.renewReadingOnMiss && styles.settingsToggleActive]}
                  onPress={() => setLearningSettings(prev => ({ ...prev, renewReadingOnMiss: !prev.renewReadingOnMiss }))}
                >
                  <View style={[styles.settingsToggleKnob, learningSettings.renewReadingOnMiss && styles.settingsToggleKnobActive]} />
                </TouchableOpacity>
              </View>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(76, 175, 80, 0.15)' }]}>
                    <Ionicons name="sparkles-outline" size={20} color="#4CAF50" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Offer micro-tests</Text>
                </View>
                <TouchableOpacity
                  style={[styles.settingsToggle, learningSettings.microTestsEnabled && styles.settingsToggleActive]}
                  onPress={() => setLearningSettings(prev => ({ ...prev, microTestsEnabled: !prev.microTestsEnabled }))}
                >
                  <View style={[styles.settingsToggleKnob, learningSettings.microTestsEnabled && styles.settingsToggleKnobActive]} />
                </TouchableOpacity>
              </View>

              <View style={styles.settingsItem}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(96, 125, 139, 0.15)' }]}>
                    <Ionicons name="list-outline" size={20} color="#607D8B" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Micro-test size</Text>
                </View>
                <View style={styles.microTestSizeControls}>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setLearningSettings(prev => ({
                      ...prev,
                      microTestSize: Math.max(3, (prev.microTestSize || 5) - 1)
                    }))}
                  >
                    <Ionicons name="remove" size={16} color={theme.text} />
                  </TouchableOpacity>
                  <Text style={[styles.microTestSizeValue, { color: theme.text }]}>
                    {Math.max(3, Math.min(10, learningSettings.microTestSize || 5))}
                  </Text>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setLearningSettings(prev => ({
                      ...prev,
                      microTestSize: Math.min(10, (prev.microTestSize || 5) + 1)
                    }))}
                  >
                    <Ionicons name="add" size={16} color={theme.text} />
                  </TouchableOpacity>
                </View>
              </View>
            </View>

            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Personalization</Text>

              <View style={styles.settingsItem}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(76, 175, 80, 0.15)' }]}>
                    <Ionicons name="paw-outline" size={20} color="#4CAF50" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Show pet features</Text>
                </View>
                <TouchableOpacity
                  style={[styles.settingsToggle, learningSettings.showPetFeatures !== false && styles.settingsToggleActive]}
                  onPress={() => setLearningSettings(prev => ({
                    ...prev,
                    showPetFeatures: !(prev.showPetFeatures !== false)
                  }))}
                >
                  <View style={[styles.settingsToggleKnob, learningSettings.showPetFeatures !== false && styles.settingsToggleKnobActive]} />
                </TouchableOpacity>
              </View>
            </View>

            {userRole === 'admin' && (
            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Spaced Repetition</Text>

              <View style={styles.settingsItem}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(3, 169, 244, 0.15)' }]}>
                    <Ionicons name="pulse-outline" size={20} color="#03A9F4" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Use FSRS for flashcards (experimental)</Text>
                </View>
                <TouchableOpacity
                  style={[
                    styles.settingsToggle,
                    srsSettings.flashcardsAlgo === 'fsrs' && styles.settingsToggleActive
                  ]}
                  onPress={() => setSrsSettings(prev => ({
                    ...prev,
                    flashcardsAlgo: prev.flashcardsAlgo === 'fsrs' ? 'sm2' : 'fsrs'
                  }))}
                >
                  <View
                    style={[
                      styles.settingsToggleKnob,
                      srsSettings.flashcardsAlgo === 'fsrs' && styles.settingsToggleKnobActive
                    ]}
                  />
                </TouchableOpacity>
              </View>

              <View style={styles.settingsItem}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(244, 67, 54, 0.15)' }]}>
                    <Ionicons name="warning-outline" size={20} color="#F44336" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Leech threshold</Text>
                </View>
                <View style={styles.microTestSizeControls}>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setSrsSettings(prev => ({
                      ...prev,
                      leechThreshold: Math.max(3, (prev.leechThreshold || 8) - 1)
                    }))}
                  >
                    <Ionicons name="remove" size={16} color={theme.text} />
                  </TouchableOpacity>
                  <Text style={[styles.microTestSizeValue, { color: theme.text }]}>
                    {Math.max(3, Math.min(12, srsSettings.leechThreshold || 8))}
                  </Text>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setSrsSettings(prev => ({
                      ...prev,
                      leechThreshold: Math.min(12, (prev.leechThreshold || 8) + 1)
                    }))}
                  >
                    <Ionicons name="add" size={16} color={theme.text} />
                  </TouchableOpacity>
                </View>
              </View>

              <View style={styles.settingsItem}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 152, 0, 0.15)' }]}>
                    <Ionicons name="calendar-outline" size={20} color="#FF9800" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Leech window (days)</Text>
                </View>
                <View style={styles.microTestSizeControls}>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setSrsSettings(prev => ({
                      ...prev,
                      leechWindowDays: Math.max(7, (prev.leechWindowDays || 30) - 1)
                    }))}
                  >
                    <Ionicons name="remove" size={16} color={theme.text} />
                  </TouchableOpacity>
                  <Text style={[styles.microTestSizeValue, { color: theme.text }]}>
                    {Math.max(7, Math.min(60, srsSettings.leechWindowDays || 30))}
                  </Text>
                  <TouchableOpacity
                    style={[styles.microTestSizeButton, { backgroundColor: theme.surfaceAlt }]}
                    onPress={() => setSrsSettings(prev => ({
                      ...prev,
                      leechWindowDays: Math.min(60, (prev.leechWindowDays || 30) + 1)
                    }))}
                  >
                    <Ionicons name="add" size={16} color={theme.text} />
                  </TouchableOpacity>
                </View>
              </View>
            </View>
            )}

            {/* Appearance Section */}
            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Appearance</Text>

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 193, 7, 0.15)' }]}>
                    <Ionicons name={themeMode === 'system' ? 'color-palette-outline' : (isDark ? 'moon' : 'sunny')} size={20} color="#FFC107" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Use System Theme</Text>
                </View>
                <TouchableOpacity
                  style={[styles.settingsToggle, themeMode === 'system' && styles.settingsToggleActive]}
                  onPress={() => {
                    if (themeMode === 'system') {
                      setThemeMode(isDark ? 'dark' : 'light');
                    } else {
                      setThemeMode('system');
                    }
                  }}
                >
                  <View style={[styles.settingsToggleKnob, themeMode === 'system' && styles.settingsToggleKnobActive]} />
                </TouchableOpacity>
              </View>
              {themeMode !== 'system' && (
                <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                  <View style={styles.settingsItemLeft}>
                    <Ionicons name={isDark ? "moon" : "sunny"} size={20} color="#FFC107" />
                    <Text style={[styles.settingsItemText, { color: theme.text }]}>Dark Mode</Text>
                  </View>
                  <TouchableOpacity
                    style={[styles.settingsToggle, isDark && styles.settingsToggleActive]}
                    onPress={() => setThemeMode(isDark ? 'light' : 'dark')}
                  >
                    <View style={[styles.settingsToggleKnob, isDark && styles.settingsToggleKnobActive]} />
                  </TouchableOpacity>
                </View>
              )}

              <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(244, 67, 54, 0.15)' }]}>
                    <Ionicons name="notifications-outline" size={20} color="#F44336" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Notifications</Text>
                </View>
                <TouchableOpacity
                  style={[styles.settingsToggle, notificationsEnabled && styles.settingsToggleActive]}
                  onPress={() => setNotificationsEnabled(!notificationsEnabled)}
                >
                  <View style={[styles.settingsToggleKnob, notificationsEnabled && styles.settingsToggleKnobActive]} />
                </TouchableOpacity>
              </View>
            </View>

            {/* Support Section */}
            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Support</Text>

              {userRole === 'admin' && (
              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={() => setScreen('flashcard-tools')}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(233, 30, 99, 0.15)' }]}>
                    <Ionicons name="albums-outline" size={20} color="#E91E63" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Flashcard Tools</Text>
                </View>
                <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
              </TouchableOpacity>
              )}

              {userRole === 'admin' && (
              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={exportReports}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(0, 150, 136, 0.15)' }]}>
                    <Ionicons name="download-outline" size={20} color="#009688" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Export Reports</Text>
                </View>
                <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
              </TouchableOpacity>
              )}

              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={() => openExternalLink('mailto:alexandria.l.harris@gmail.com?subject=StudyPet%20Support', 'Email is not available on this device.')}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(233, 30, 99, 0.15)' }]}>
                    <Ionicons name="mail-outline" size={20} color="#E91E63" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Contact Us</Text>
                </View>
                <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
              </TouchableOpacity>

            </View>

            {/* Legal Section */}
            <View style={[styles.settingsSection, { backgroundColor: theme.card, borderColor: theme.border }]}>
              <Text style={[styles.settingsSectionTitle, { color: theme.subtext }]}>Legal</Text>

              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={() => setShowTermsModal(true)}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(96, 125, 139, 0.15)' }]}>
                    <Ionicons name="document-text-outline" size={20} color="#607D8B" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Terms of Service</Text>
                </View>
                <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.settingsItem, { borderBottomColor: theme.border }]}
                onPress={() => showAlert('Privacy Policy', 'Privacy policy is being finalized.')}
              >
                <View style={styles.settingsItemLeft}>
                  <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(96, 125, 139, 0.15)' }]}>
                    <Ionicons name="shield-checkmark-outline" size={20} color="#607D8B" />
                  </View>
                  <Text style={[styles.settingsItemText, { color: theme.text }]}>Privacy Policy</Text>
                </View>
                <Ionicons name="chevron-forward" size={20} color={theme.subtext} />
              </TouchableOpacity>
            </View>

            {/* Sign Out Button */}
            <TouchableOpacity
              style={styles.settingsSignOutButton}
              onPress={() => {
                showAlert(
                  'Sign Out',
                  'Your progress is saved. Sign out?',
                  [
                    { text: 'Cancel', style: 'cancel' },
                    { text: 'Sign Out', style: 'destructive', onPress: logout }
                  ]
                );
              }}
            >
              <Ionicons name="log-out-outline" size={20} color="#F44336" />
              <Text style={styles.settingsSignOutText}>Sign Out</Text>
            </TouchableOpacity>

            {/* App Version */}
            <Text style={[styles.settingsVersion, { color: theme.subtext }]}>
              StudyPet v1.0.0
            </Text>
          </ScrollView>
        </LinearGradient>
      </SafeAreaView>
    );
  };

  // Show auth screen if not logged in
  if (!isAuthenticated) {
    return <AuthScreen />;
  }

  return (
    <View style={styles.appRoot}>
      {screen === 'home' && renderHome()}
      {screen === 'categories' && renderCategories()}
      {screen === 'question' && renderQuestion()}
      {screen === 'flashcard' && renderFlashcard()}
      {screen === 'flashcard-results' && renderFlashcardResults()}
      {screen === 'results' && renderResults()}
      {screen === 'weakness' && renderWeaknessAnalysis()}
      {screen === 'resource' && renderResourceView()}
      {screen === 'pet' && renderPetScreen()}
      {screen === 'battle' && renderBattleArena()}
      {screen === 'pet-shop' && renderPetShop()}
      {screen === 'room-decorator' && renderRoomDecorator()}
      {screen === 'topics' && renderTopics()}
      {screen === 'settings' && renderSettings()}
      {screen === 'flashcard-tools' && renderFlashcardTools()}
      {screen === 'review-logs-debug' && renderReviewLogsDebug()}

      <WatermarkOverlay label={watermarkLabel} styles={styles} theme={theme} />

      {/* Coin Earned Toast */}
      {showCoinEarnedToast && (
        <View style={styles.coinToast}>
          <Ionicons name="wallet" size={20} color="#FFD700" />
          <Text style={styles.coinToastText}>+{showCoinEarnedToast.amount}</Text>
          <Text style={styles.coinToastSource}>{showCoinEarnedToast.source}</Text>
        </View>
      )}

      {/* Egg Hatch Modal */}
      <Modal transparent visible={showEggHatchModal} animationType="fade" onRequestClose={() => {}}>
        <Pressable style={styles.modalOverlay} onPress={() => {}}>
          <KeyboardAvoidingView
            behavior={Platform.OS === 'ios' ? 'padding' : undefined}
            style={styles.modalKeyboardAvoiding}
          >
            <Pressable style={[styles.modalContent, { backgroundColor: theme.card, borderColor: theme.border }]} onPress={() => {}}>
              <Text style={{ fontSize: 48, textAlign: 'center', marginBottom: 8 }}>
                {hatchingEgg?.previousSpeciesId === 'mystery' ? '' : ''}
              </Text>
              <Text style={[styles.modalTitle, { color: theme.text }]}>
                Your Egg Hatched!
              </Text>
              <Text style={[styles.modalSubtitle, { color: theme.subtext }]}>
                {hatchingEgg?.previousSpeciesId === 'mystery'
                  ? `It's a ${PET_SPECIES[hatchingEgg?.speciesId]?.name || 'new creature'}!`
                  : `${PET_SPECIES[hatchingEgg?.speciesId]?.name || 'Your pet'} has hatched!`
                }
              </Text>
              {hatchingEgg && (
                <View style={{ alignItems: 'center', marginVertical: 12 }}>
                  <PetSprite
                    speciesId={hatchingEgg.speciesId}
                    stage={PET_STAGES.HATCHLING}
                    size={100}
                    themeOverride={theme}
                    petId={hatchingEgg.petId}
                  />
                </View>
              )}
              <Text style={[styles.modalSubtitle, { color: theme.subtext, marginBottom: 8 }]}>
                Give your new pet a name:
              </Text>
              <TextInput
                style={[styles.modalInput, { backgroundColor: theme.inputBg, color: theme.text, minHeight: 48 }]}
                value={newPetName}
                onChangeText={setNewPetName}
                placeholder="Pet name"
                placeholderTextColor={theme.subtext}
                maxLength={20}
              />
              <TouchableOpacity style={styles.modalButtonSave} onPress={handleHatchConfirm}>
                <Text style={styles.modalButtonSaveText}>Welcome Home!</Text>
              </TouchableOpacity>
            </Pressable>
          </KeyboardAvoidingView>
        </Pressable>
      </Modal>

      {/* Practice Context Modal */}
      {showPracticeContextModal && (
        <Pressable style={styles.modalOverlay} onPress={() => {}}>
          <Pressable
            style={[styles.modalContent, { backgroundColor: theme.card, borderColor: theme.border }]}
            onPress={() => {}}
          >
            <Text style={[styles.modalTitle, { color: theme.text }]}>Choose Your Practice Context</Text>
            <Text style={[styles.modalSubtitle, { color: theme.subtext }]}>
              This sets your question pool for your account.
            </Text>

            {Object.values(SPECIALTIES).map((specialty, index) => (
              <TouchableOpacity
                key={specialty.id}
                style={[styles.modeSelectionOption, { backgroundColor: theme.surfaceAlt, borderColor: theme.border }]}
                onPress={() => savePracticeContext(specialty.id, { suppressAlert: true })}
              >
                <View style={[styles.modeSelectionIcon, { backgroundColor: `${specialty.color}20` }]}>
                  <Ionicons name={specialty.icon} size={28} color={specialty.color} />
                </View>
                <View style={styles.modeSelectionInfo}>
                  <Text style={[styles.modeSelectionTitle, { color: theme.text }]}>
                    {specialty.shortName || specialty.name}{index === 0 ? ' (Default)' : ''}
                  </Text>
                  <Text style={[styles.modeSelectionDesc, { color: theme.subtext }]}>
                    {specialty.description}
                  </Text>
                </View>
              </TouchableOpacity>
            ))}
          </Pressable>
        </Pressable>
      )}

      {/* Report Issue Modal - Global so it works on any screen */}
      {showReportModal && (
        <Pressable
          style={styles.modalOverlay}
          onPress={() => {
            setShowReportModal(false);
            setReportText('');
          }}
        >
          <KeyboardAvoidingView
            behavior={Platform.OS === 'ios' ? 'padding' : undefined}
            style={styles.modalKeyboardAvoiding}
          >
            <Pressable style={[styles.modalContent, styles.reportModalContent]} onPress={() => {}}>
              <ScrollView
                style={styles.reportModalScrollView}
                contentContainerStyle={styles.reportModalScrollContent}
                keyboardShouldPersistTaps="handled"
              >
                <Text style={styles.modalTitle}>Report an Issue</Text>
                <Text style={styles.modalSubtitle}>
                  {reportType === 'question' ? 'Question' : 'Flashcard'} ID: {reportItemId}
                </Text>

                <View style={styles.reportTypeButtons}>
                  <TouchableOpacity
                    style={[styles.reportTypeButton, reportText.includes('[INCORRECT]') && styles.reportTypeActive]}
                    onPress={() => setReportText('[INCORRECT ANSWER] ')}
                  >
                    <Text style={styles.reportTypeButtonText}>Wrong Answer</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.reportTypeButton, reportText.includes('[TYPO]') && styles.reportTypeActive]}
                    onPress={() => setReportText('[TYPO] ')}
                  >
                    <Text style={styles.reportTypeButtonText}>Typo</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.reportTypeButton, reportText.includes('[UNCLEAR]') && styles.reportTypeActive]}
                    onPress={() => setReportText('[UNCLEAR] ')}
                  >
                    <Text style={styles.reportTypeButtonText}>Unclear</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.reportTypeButton, reportText.includes('[TOO EASY]') && styles.reportTypeActive]}
                    onPress={() => setReportText('[TOO EASY] ')}
                  >
                    <Text style={styles.reportTypeButtonText}>Too Easy</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.reportTypeButton, reportText.includes('[TOO HARD]') && styles.reportTypeActive]}
                    onPress={() => setReportText('[TOO HARD] ')}
                  >
                    <Text style={styles.reportTypeButtonText}>Too Hard</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.reportTypeButton, reportText.includes('[OUTDATED]') && styles.reportTypeActive]}
                    onPress={() => setReportText('[OUTDATED] ')}
                  >
                    <Text style={styles.reportTypeButtonText}>Outdated</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.reportTypeButton, reportText.includes('[AMBIGUOUS]') && styles.reportTypeActive]}
                    onPress={() => setReportText('[AMBIGUOUS] ')}
                  >
                    <Text style={styles.reportTypeButtonText}>Ambiguous</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.reportTypeButton, reportText.includes('[POOR EXPLANATION]') && styles.reportTypeActive]}
                    onPress={() => setReportText('[POOR EXPLANATION] ')}
                  >
                    <Text style={styles.reportTypeButtonText}>Poor Explanation</Text>
                  </TouchableOpacity>
                </View>

                <TextInput
                  style={styles.modalInput}
                  multiline
                  placeholder="Describe the issue in detail..."
                  placeholderTextColor="#666"
                  value={reportText}
                  onChangeText={setReportText}
                />
              </ScrollView>
              <View style={styles.reportModalFooter}>
                <TouchableOpacity
                  style={styles.modalButtonCancel}
                  onPress={() => {
                    setShowReportModal(false);
                    setReportText('');
                  }}
                >
                  <Text style={styles.modalButtonCancelText}>Cancel</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.modalButtonSave, { backgroundColor: '#FF5722' }]}
                  onPress={submitReport}
                >
                  <Text style={styles.modalButtonSaveText}>Submit</Text>
                </TouchableOpacity>
              </View>
            </Pressable>
          </KeyboardAvoidingView>
        </Pressable>
      )}

      <AdminEditModal
        visible={adminEditVisible}
        contentType={adminEditType}
        item={adminEditItem}
        onSave={handleAdminEditSave}
        onClose={() => setAdminEditVisible(false)}
        theme={theme}
      />

      {showEndSessionModal && (
        <Pressable style={styles.modalOverlay} onPress={() => setShowEndSessionModal(false)}>
          <Pressable style={styles.modalContent} onPress={() => {}}>
            <Text style={styles.modalTitle}>End Session?</Text>
            <Text style={styles.modalSubtitle}>Save this session to resume later?</Text>
            <View style={styles.modalActionsRow}>
              <TouchableOpacity style={[styles.modalButtonCancel, styles.modalButtonCompact]} onPress={() => setShowEndSessionModal(false)}>
                <Text style={styles.modalButtonCancelText}>Keep Going</Text>
              </TouchableOpacity>
              <TouchableOpacity style={[styles.modalButtonSecondary, styles.modalButtonCompact]} onPress={handleEndSessionDiscard}>
                <Text style={styles.modalButtonSecondaryText}>Discard</Text>
              </TouchableOpacity>
              <TouchableOpacity style={[styles.modalButtonSave, styles.modalButtonCompact]} onPress={handleEndSessionSave}>
                <Text style={styles.modalButtonSaveText}>Save & Exit</Text>
              </TouchableOpacity>
            </View>
          </Pressable>
        </Pressable>
      )}

      {showCustomTestModal && (
        <Pressable style={styles.modalOverlay} onPress={() => setShowCustomTestModal(false)}>
          <KeyboardAvoidingView
            behavior={Platform.OS === 'ios' ? 'padding' : undefined}
            style={styles.modalKeyboardAvoiding}
          >
            <Pressable style={[styles.modalContent, { backgroundColor: theme.card, borderColor: theme.border }]} onPress={() => {}}>
              <SafeAreaView style={styles.modalSafeArea}>
                <ScrollView contentContainerStyle={styles.modalScrollContent} keyboardShouldPersistTaps="handled">
                <Text style={[styles.modalTitle, { color: theme.text }]}>Custom Test</Text>
                <Text style={[styles.modalSubtitle, { color: theme.subtext }]}>Choose categories and test format</Text>
                {focusFilter !== 'all' && (
                  <Text style={[styles.modalSubtitle, { color: theme.subtext }]}>
                    Global focus: {focusFilter}
                  </Text>
                )}

                <View style={styles.formRow}>
                  <View style={styles.formGroupHalf}>
                    <Text style={[styles.formLabel, { color: theme.subtext }]}>Questions</Text>
                    <TextInput
                      style={[styles.formInput, { backgroundColor: theme.inputBg, color: theme.text }]}
                      keyboardType="number-pad"
                      value={customTestCountText}
                      onChangeText={(text) => {
                        const digits = text.replace(/[^\d]/g, '');
                        setCustomTestCountText(digits);
                      }}
                      onBlur={() => {
                        const parsed = parseInt(customTestCountText, 10);
                        const next = Number.isFinite(parsed) ? Math.max(5, Math.min(200, parsed)) : 25;
                        setCustomTestCount(next);
                        setCustomTestCountText(String(next));
                      }}
                    />
                  </View>
                  <View style={styles.formGroupHalf}>
                    <Text style={[styles.formLabel, { color: theme.subtext }]}>Mode</Text>
                    <View style={styles.customModeRow}>
                      {['tutor', 'timed', 'untimed'].map(mode => (
                        <TouchableOpacity
                          key={mode}
                          style={[
                            styles.customModePill,
                            { borderColor: theme.border },
                            customTestMode === mode && styles.customModePillActive
                          ]}
                          onPress={() => setCustomTestMode(mode)}
                        >
                          <Text style={[
                            styles.customModeText,
                            { color: customTestMode === mode ? theme.text : theme.subtext }
                          ]}>
                            {mode === 'tutor' ? 'Tutor' : mode === 'timed' ? 'Timed' : 'Untimed'}
                          </Text>
                        </TouchableOpacity>
                      ))}
                    </View>
                  </View>
                </View>

                <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                  <View style={styles.settingsItemLeft}>
                    <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(3, 169, 244, 0.15)' }]}>
                      <Ionicons name="calendar-outline" size={20} color="#03A9F4" />
                    </View>
                    <Text style={[styles.settingsItemText, { color: theme.text }]}>Include due reviews first</Text>
                  </View>
                  <TouchableOpacity
                    style={[styles.settingsToggle, customTestIncludeDueFirst && styles.settingsToggleActive]}
                    onPress={() => setCustomTestIncludeDueFirst(prev => !prev)}
                  >
                    <View style={[styles.settingsToggleKnob, customTestIncludeDueFirst && styles.settingsToggleKnobActive]} />
                  </TouchableOpacity>
                </View>

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Categories</Text>
                <View style={styles.customModeRow}>
                  <TouchableOpacity
                    style={[
                      styles.customModePill,
                      { borderColor: theme.border },
                      customTestCategoryMode === 'all' && styles.customModePillActive
                    ]}
                    onPress={() => {
                      setCustomTestCategoryMode('all');
                      setCustomTestCategories([]);
                    }}
                  >
                    <Text style={[
                      styles.customModeText,
                      { color: customTestCategoryMode === 'all' ? theme.text : theme.subtext }
                    ]}>
                      All Categories
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[
                      styles.customModePill,
                      { borderColor: theme.border },
                      customTestCategoryMode === 'choose' && styles.customModePillActive
                    ]}
                    onPress={() => setCustomTestCategoryMode('choose')}
                  >
                    <Text style={[
                      styles.customModeText,
                      { color: customTestCategoryMode === 'choose' ? theme.text : theme.subtext }
                    ]}>
                      Choose Categories
                    </Text>
                  </TouchableOpacity>
                </View>

                {customTestCategoryMode === 'choose' && (
                  <ScrollView style={styles.categoryList}>
                    {Object.keys(activeCategoryMap).map(key => {
                      const label = activeCategoryMap[key].name;
                      const selected = customTestCategories.includes(key);
                      return (
                        <TouchableOpacity
                          key={key}
                          style={[
                            styles.categoryItem,
                            { borderColor: theme.border },
                            selected && styles.categoryItemActive
                          ]}
                          onPress={() => {
                            setCustomTestCategories(prev => (
                              prev.includes(key) ? prev.filter(c => c !== key) : [...prev, key]
                            ));
                          }}
                        >
                          <Text style={[
                            styles.categoryItemText,
                            { color: selected ? theme.text : theme.subtext }
                          ]}>
                            {label}
                          </Text>
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                )}

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Question Focus</Text>
                <View style={[styles.focusRow, { marginLeft: 0 }]}>
                  {[
                    { id: 'all', label: 'All' },
                    { id: 'unseen', label: 'Unseen' },
                    { id: 'missed', label: 'Missed' },
                    { id: 'danger', label: 'Danger' },
                  ].map(option => {
                    const selected = focusFilter === option.id;
                    return (
                      <TouchableOpacity
                        key={option.id}
                        style={[
                          styles.focusPill,
                          { borderColor: theme.border },
                          selected && styles.focusPillActive
                        ]}
                        onPress={() => setFocusFilter(option.id)}
                      >
                        <Text style={[
                          styles.focusText,
                          { color: selected ? theme.text : theme.subtext }
                        ]}>
                          {option.label}
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </View>

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Broad Focus (Optional)</Text>
                <View style={styles.tagPickerContent}>
                  {['anatomy', 'diagnosis', 'treatment', 'surgery', 'pathology'].map(tag => {
                    const selected = customTestFocusTags.includes(tag);
                    return (
                      <TouchableOpacity
                        key={tag}
                        style={[
                          styles.tagPill,
                          { borderColor: theme.border },
                          selected && styles.tagPillActive
                        ]}
                        onPress={() => {
                          setCustomTestFocusTags(prev => (
                            prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]
                          ));
                        }}
                      >
                        <Text style={[styles.tagPillText, { color: selected ? theme.text : theme.subtext }]}>
                          {tag} ({focusTagCounts[tag] || 0})
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </View>

                {customTestPresets.length > 0 && (
                  <>
                    <Text style={[styles.formLabel, { color: theme.subtext }]}>Saved Presets</Text>
                    {customTestPresets.map(preset => (
                      <View key={preset.id} style={styles.presetRow}>
                        <View style={styles.presetInfo}>
                          <Text style={[styles.presetName, { color: theme.text }]} numberOfLines={1}>
                            {preset.name}
                          </Text>
                          <Text style={[styles.presetMeta, { color: theme.subtext }]}>
                            {(preset.categories?.length || 0)} cats  {(preset.focusTags?.length || 0)} focus  {preset.count || 0} Q  {preset.mode || 'tutor'}{preset.includeDueFirst ? '  due' : ''}{preset.focusFilter && preset.focusFilter !== 'all' ? `  ${preset.focusFilter}` : ''}
                          </Text>
                        </View>
                        <View style={styles.presetActions}>
                          <TouchableOpacity
                            style={[styles.presetButton, { backgroundColor: theme.surfaceAlt }]}
                            onPress={() => applyCustomPreset(preset)}
                          >
                            <Text style={[styles.presetButtonText, { color: theme.text }]}>Use</Text>
                          </TouchableOpacity>
                          <TouchableOpacity
                            style={[styles.presetButton, { backgroundColor: 'rgba(244,67,54,0.15)' }]}
                            onPress={() => deleteCustomPreset(preset.id)}
                          >
                            <Text style={[styles.presetButtonText, { color: '#F44336' }]}>Delete</Text>
                          </TouchableOpacity>
                        </View>
                      </View>
                    ))}
                  </>
                )}

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Save Current Preset</Text>
                <TextInput
                  style={[styles.formInput, { backgroundColor: theme.inputBg, color: theme.text }]}
                  placeholder="Preset name..."
                  placeholderTextColor={theme.subtext}
                  value={customPresetName}
                  onChangeText={setCustomPresetName}
                />
                <TouchableOpacity style={styles.presetSaveButton} onPress={saveCustomPreset}>
                  <Text style={styles.presetSaveText}>Save Preset</Text>
                </TouchableOpacity>

                </ScrollView>
                <View style={[styles.modalFooterRow, { borderTopColor: theme.border, backgroundColor: theme.card }]}>
                  <TouchableOpacity style={styles.modalButtonCancel} onPress={() => setShowCustomTestModal(false)}>
                    <Text style={styles.modalButtonCancelText}>Cancel</Text>
                  </TouchableOpacity>
                  <TouchableOpacity style={styles.modalButtonSave} onPress={startCustomTagSession}>
                    <Text style={styles.modalButtonSaveText}>Start Test</Text>
                  </TouchableOpacity>
                </View>
              </SafeAreaView>
            </Pressable>
          </KeyboardAvoidingView>
        </Pressable>
      )}

      {showAssignExamModal && (
        <Pressable style={styles.modalOverlay} onPress={() => setShowAssignExamModal(false)}>
          <KeyboardAvoidingView
            behavior={Platform.OS === 'ios' ? 'padding' : undefined}
            style={styles.modalKeyboardAvoiding}
          >
            <Pressable style={[styles.modalContent, { backgroundColor: theme.card, borderColor: theme.border }]} onPress={() => {}}>
              <SafeAreaView style={styles.modalSafeArea}>
                <ScrollView contentContainerStyle={styles.modalScrollContent} keyboardShouldPersistTaps="handled">
                <Text style={[styles.modalTitle, { color: theme.text }]}>Assign Exam</Text>
                <Text style={[styles.modalSubtitle, { color: theme.subtext }]}>Send a custom exam to a user by email</Text>

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Title</Text>
                <TextInput
                  style={[styles.formInput, { backgroundColor: theme.inputBg, color: theme.text }]}
                  placeholder="Assigned Exam"
                  placeholderTextColor={theme.subtext}
                  value={assignmentTitle}
                  onChangeText={setAssignmentTitle}
                />

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Assignee Email</Text>
                <TextInput
                  style={[styles.formInput, { backgroundColor: theme.inputBg, color: theme.text }]}
                  placeholder="user@example.com"
                  placeholderTextColor={theme.subtext}
                  autoCapitalize="none"
                  keyboardType="email-address"
                  value={assignmentEmail}
                  onChangeText={setAssignmentEmail}
                />

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Mode</Text>
                <View style={styles.customModeRow}>
                  {['tutor', 'timed', 'untimed'].map(mode => (
                    <TouchableOpacity
                      key={mode}
                      style={[
                        styles.customModePill,
                        { borderColor: theme.border },
                        assignmentMode === mode && styles.customModePillActive
                      ]}
                      onPress={() => setAssignmentMode(mode)}
                    >
                      <Text style={[
                        styles.customModeText,
                        { color: assignmentMode === mode ? theme.text : theme.subtext }
                      ]}>
                        {mode === 'tutor' ? 'Tutor' : mode === 'timed' ? 'Timed' : 'Untimed'}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>

                <View style={[styles.settingsItem, { borderBottomColor: theme.border }]}>
                  <View style={styles.settingsItemLeft}>
                    <View style={[styles.settingsIconBox, { backgroundColor: 'rgba(255, 183, 77, 0.15)' }]}>
                      <Ionicons name="calendar-outline" size={20} color="#FFB74D" />
                    </View>
                    <Text style={[styles.settingsItemText, { color: theme.text }]}>Set Due Date</Text>
                  </View>
                  <TouchableOpacity
                    style={[styles.settingsToggle, assignmentDueDateEnabled && styles.settingsToggleActive]}
                    onPress={() => setAssignmentDueDateEnabled(!assignmentDueDateEnabled)}
                  >
                    <View style={[styles.settingsToggleKnob, assignmentDueDateEnabled && styles.settingsToggleKnobActive]} />
                  </TouchableOpacity>
                </View>
                {assignmentDueDateEnabled && (
                  <TextInput
                    style={[styles.formInput, { backgroundColor: theme.inputBg, color: theme.text }]}
                    placeholder="YYYY-MM-DD"
                    placeholderTextColor={theme.subtext}
                    value={assignmentDueDateText}
                    onChangeText={setAssignmentDueDateText}
                  />
                )}

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Question IDs (Optional)</Text>
                <TextInput
                  style={[styles.modalInput, { backgroundColor: theme.inputBg, color: theme.text }]}
                  multiline
                  placeholder="e.g. oto_anatomy_001, oto_anatomy_002"
                  placeholderTextColor={theme.subtext}
                  value={assignmentQuestionIdsText}
                  onChangeText={setAssignmentQuestionIdsText}
                />

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Categories (Optional)</Text>
                <ScrollView style={styles.categoryList}>
                  {Object.keys(activeCategoryMap).map(key => {
                    const label = activeCategoryMap[key].name;
                    const selected = assignmentCategories.includes(key);
                    return (
                      <TouchableOpacity
                        key={key}
                        style={[
                          styles.categoryItem,
                          { borderColor: theme.border },
                          selected && styles.categoryItemActive
                        ]}
                        onPress={() => {
                          setAssignmentCategories(prev => (
                            prev.includes(key) ? prev.filter(c => c !== key) : [...prev, key]
                          ));
                        }}
                      >
                        <Text style={[
                          styles.categoryItemText,
                          { color: selected ? theme.text : theme.subtext }
                        ]}>
                          {label}
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </ScrollView>

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Broad Focus (Optional)</Text>
                <View style={styles.tagPickerContent}>
                  {['anatomy', 'diagnosis', 'treatment', 'surgery', 'pathology'].map(tag => {
                    const selected = assignmentFocusTags.includes(tag);
                    return (
                      <TouchableOpacity
                        key={tag}
                        style={[
                          styles.tagPill,
                          { borderColor: theme.border },
                          selected && styles.tagPillActive
                        ]}
                        onPress={() => {
                          setAssignmentFocusTags(prev => (
                            prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]
                          ));
                        }}
                      >
                        <Text style={[styles.tagPillText, { color: selected ? theme.text : theme.subtext }]}>
                          {tag} ({focusTagCounts[tag] || 0})
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </View>

                <Text style={[styles.formLabel, { color: theme.subtext }]}>Question Count (Optional)</Text>
                <TextInput
                  style={[styles.formInput, { backgroundColor: theme.inputBg, color: theme.text }]}
                  keyboardType="number-pad"
                  placeholder="e.g. 25"
                  placeholderTextColor={theme.subtext}
                  value={assignmentCountText}
                  onChangeText={(text) => setAssignmentCountText(text.replace(/[^\d]/g, ''))}
                />
                </ScrollView>
                <View style={[styles.modalFooterRow, { borderTopColor: theme.border, backgroundColor: theme.card }]}>
                  <TouchableOpacity style={styles.modalButtonCancel} onPress={() => setShowAssignExamModal(false)}>
                    <Text style={styles.modalButtonCancelText}>Cancel</Text>
                  </TouchableOpacity>
                  <TouchableOpacity style={styles.modalButtonSave} onPress={handleCreateAssignment}>
                    <Text style={styles.modalButtonSaveText}>Send Exam</Text>
                  </TouchableOpacity>
                </View>
              </SafeAreaView>
            </Pressable>
          </KeyboardAvoidingView>
        </Pressable>
      )}

      <TermsModal
        visible={showTermsModal}
        title={TERMS_TITLE}
        text={TERMS_OF_SERVICE_TEXT}
        onClose={() => setShowTermsModal(false)}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  appRoot: {
    flex: 1,
    position: 'relative',
  },
  watermarkOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    opacity: 0.06,
  },
  watermarkText: {
    fontSize: 20,
    letterSpacing: 1.2,
    textTransform: 'uppercase',
  },
  watermarkStampTopLeft: {
    position: 'absolute',
    top: 18,
    left: 16,
    transform: [{ rotate: '-12deg' }],
  },
  watermarkStampBottomRight: {
    position: 'absolute',
    bottom: 26,
    right: 16,
    transform: [{ rotate: '8deg' }],
  },
  container: {
    flex: 1,
    backgroundColor: '#1a1a2e',
  },
  gradient: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    color: '#fff',
    fontSize: 18,
    marginTop: 16,
    opacity: 0.8,
  },
  bannedContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  bannedTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginTop: 16,
    marginBottom: 8,
  },
  bannedText: {
    fontSize: 15,
    textAlign: 'center',
    marginBottom: 10,
  },
  bannedReason: {
    fontSize: 13,
    textAlign: 'center',
    opacity: 0.85,
    marginBottom: 18,
  },
  bannedButton: {
    backgroundColor: '#EF5350',
    paddingHorizontal: 18,
    paddingVertical: 10,
    borderRadius: 22,
  },
  bannedButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 14,
  },
  scrollContent: {
    padding: 20,
    paddingBottom: 40,
  },
  header: {
    marginBottom: 24,
    marginTop: 10,
  },
  title: {
    fontSize: 34,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 16,
    color: '#4CAF50',
    fontWeight: '500',
  },

  // Stats Card
  statsCard: {
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 16,
    padding: 20,
    marginBottom: 16,
  },
  statsTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#fff',
    marginBottom: 16,
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  statItem: {
    alignItems: 'center',
  },
  statNumber: {
    fontSize: 26,
    fontWeight: 'bold',
    color: '#4CAF50',
  },
  statLabel: {
    fontSize: 11,
    color: '#888',
    marginTop: 4,
    textTransform: 'uppercase',
  },

  // Info Card
  infoCard: {
    backgroundColor: 'rgba(30, 58, 95, 0.9)',
    borderRadius: 16,
    padding: 16,
    marginBottom: 24,
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#fff',
    marginBottom: 8,
  },
  infoText: {
    fontSize: 14,
    color: '#aaa',
    lineHeight: 20,
  },

  // Section Title
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  sectionHeaderIcon: {
    width: 32,
    height: 32,
    borderRadius: 8,
    backgroundColor: 'rgba(76, 175, 80, 0.15)',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 10,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#fff',
  },
  sectionSubtitle: {
    fontSize: 13,
    color: '#888',
    marginBottom: 12,
    marginLeft: 42,
  },
  focusRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginBottom: 12,
    marginLeft: 42,
  },
  focusPill: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    borderWidth: 1,
  },
  focusPillActive: {
    backgroundColor: 'rgba(255,183,77,0.2)',
    borderColor: '#FFB74D',
  },
  focusText: {
    fontSize: 12,
    fontWeight: '600',
  },

  // Mode Cards
  modeCard: {
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    flexDirection: 'row',
    alignItems: 'center',
  },
  modeIcon: {
    width: 52,
    height: 52,
    borderRadius: 26,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  modeContent: {
    flex: 1,
  },
  modeNameRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  modeName: {
    fontSize: 17,
    fontWeight: '600',
    color: '#fff',
  },
  dueBadge: {
    backgroundColor: '#E91E63',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
    marginLeft: 10,
  },
  dueBadgeText: {
    color: '#fff',
    fontSize: 11,
    fontWeight: '600',
  },
  modeDescription: {
    fontSize: 13,
    color: '#888',
    marginBottom: 4,
  },
  modePrinciple: {
    fontSize: 12,
    fontWeight: '500',
  },
  savedSessionsCard: {
    borderRadius: 14,
    padding: 16,
    marginBottom: 16,
  },
  savedSessionsHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  savedSessionsTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  savedSessionsCount: {
    fontSize: 12,
  },
  savedSessionRow: {
    borderTopWidth: 1,
    paddingTop: 12,
    marginTop: 12,
  },
  savedSessionInfo: {
    flex: 1,
  },
  savedSessionName: {
    fontSize: 14,
    fontWeight: '600',
  },
  savedSessionMeta: {
    fontSize: 12,
    marginTop: 4,
  },
  savedSessionTags: {
    fontSize: 11,
    marginTop: 4,
  },
  savedSessionActions: {
    flexDirection: 'row',
    gap: 8,
    marginTop: 10,
  },
  savedSessionButton: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 10,
  },
  savedSessionButtonText: {
    fontSize: 12,
    fontWeight: '600',
  },
  savedSessionsMore: {
    fontSize: 12,
    marginTop: 12,
    textAlign: 'center',
  },
  assignedExamCard: {
    borderRadius: 14,
    padding: 14,
    marginBottom: 12,
    borderWidth: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  assignedExamInfo: {
    flex: 1,
    paddingRight: 12,
  },
  assignedExamTitle: {
    fontSize: 15,
    fontWeight: '600',
  },
  assignedExamMeta: {
    fontSize: 12,
    marginTop: 4,
  },
  assignedExamActions: {
    alignItems: 'flex-end',
  },
  assignedExamStatus: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 10,
    marginBottom: 8,
  },
  assignedExamStatusText: {
    fontSize: 11,
    fontWeight: '700',
    textTransform: 'capitalize',
  },
  assignedExamButton: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 10,
  },
  assignedExamButtonText: {
    fontSize: 12,
    fontWeight: '600',
  },

  // Add Card Button
  addCardButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderWidth: 1,
    borderColor: '#E91E63',
    borderRadius: 12,
    marginTop: 8,
    marginBottom: 16,
    borderStyle: 'dashed',
  },
  addCardButtonText: {
    color: '#E91E63',
    fontSize: 15,
    fontWeight: '500',
    marginLeft: 8,
  },

  // Study Topics Section Styles
  suggestedReadingCard: {
    backgroundColor: 'rgba(255, 152, 0, 0.1)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
  },
  suggestedReadingHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  suggestedReadingTitle: {
    color: '#FF9800',
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 8,
  },
  suggestedReadingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.05)',
  },
  suggestedReadingIcon: {
    width: 32,
    height: 32,
    borderRadius: 8,
    backgroundColor: 'rgba(0, 188, 212, 0.15)',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  suggestedReadingContent: {
    flex: 1,
  },
  suggestedReadingItemTitle: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '500',
    lineHeight: 20,
  },
  suggestedReadingMeta: {
    color: '#888',
    fontSize: 12,
    marginTop: 2,
  },
  browseTopicsCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
  },
  browseTopicsIcon: {
    width: 52,
    height: 52,
    borderRadius: 26,
    backgroundColor: 'rgba(0, 188, 212, 0.15)',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 16,
  },
  browseTopicsContent: {
    flex: 1,
  },
  browseTopicsTitle: {
    color: '#fff',
    fontSize: 17,
    fontWeight: '600',
    marginBottom: 4,
  },
  browseTopicsDesc: {
    color: '#888',
    fontSize: 13,
  },

  // Topics Browser Screen Styles
  topicsStatsCard: {
    flexDirection: 'row',
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 12,
    padding: 20,
    marginBottom: 20,
    justifyContent: 'space-around',
  },
  topicsStatItem: {
    alignItems: 'center',
  },
  topicsStatNumber: {
    color: '#00BCD4',
    fontSize: 24,
    fontWeight: 'bold',
  },
  topicsStatLabel: {
    color: '#888',
    fontSize: 12,
    marginTop: 4,
  },
  topicCategory: {
    marginBottom: 20,
  },
  topicCategoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  topicCategoryTitle: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
    textTransform: 'capitalize',
  },
  topicCategoryCount: {
    color: '#888',
    fontSize: 13,
  },
  topicItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 10,
    padding: 14,
    marginBottom: 8,
  },
  topicItemRead: {
    backgroundColor: 'rgba(76, 175, 80, 0.1)',
    borderWidth: 1,
    borderColor: 'rgba(76, 175, 80, 0.3)',
  },
  topicItemIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 188, 212, 0.15)',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  topicItemContent: {
    flex: 1,
  },
  topicItemTitle: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '500',
    lineHeight: 20,
    marginBottom: 4,
  },
  topicItemTitleRead: {
    color: '#aaa',
  },
  topicItemMeta: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  topicItemMetaText: {
    color: '#888',
    fontSize: 12,
    marginRight: 10,
  },
  topicEssentialBadge: {
    backgroundColor: 'rgba(244, 67, 54, 0.2)',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 4,
    marginRight: 8,
  },
  topicEssentialText: {
    color: '#F44336',
    fontSize: 10,
    fontWeight: '600',
  },
  topicCompletedBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(76, 175, 80, 0.2)',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 4,
  },
  topicCompletedText: {
    color: '#4CAF50',
    fontSize: 10,
    fontWeight: '600',
    marginLeft: 4,
  },
  noTopicsCard: {
    alignItems: 'center',
    padding: 40,
  },
  noTopicsTitle: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
    marginTop: 16,
    marginBottom: 8,
  },
  noTopicsText: {
    color: '#888',
    fontSize: 14,
    textAlign: 'center',
    lineHeight: 20,
  },

  // Results Suggested Reading Styles
  resultsSuggestedReading: {
    backgroundColor: 'rgba(0, 188, 212, 0.1)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
  },
  resultsSuggestedHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  resultsSuggestedTitle: {
    color: '#00BCD4',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  resultsSuggestedSubtitle: {
    color: '#888',
    fontSize: 13,
    marginBottom: 12,
  },
  resultsSuggestedItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.05)',
  },
  resultsSuggestedIcon: {
    width: 32,
    height: 32,
    borderRadius: 8,
    backgroundColor: 'rgba(0, 188, 212, 0.15)',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  resultsSuggestedContent: {
    flex: 1,
  },
  resultsSuggestedItemTitle: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '500',
    lineHeight: 20,
  },
  resultsSuggestedMeta: {
    color: '#888',
    fontSize: 12,
    marginTop: 2,
  },

  // Coming Soon Card
  comingSoonCard: {
    backgroundColor: 'rgba(50, 50, 80, 0.5)',
    borderRadius: 12,
    padding: 16,
    marginTop: 20,
    borderWidth: 1,
    borderColor: '#444',
    borderStyle: 'dashed',
  },
  comingSoonTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#888',
    marginBottom: 8,
  },
  comingSoonText: {
    fontSize: 13,
    color: '#666',
    lineHeight: 20,
  },

  // Navigation Header
  navHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    paddingTop: 10,
  },
  navTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#fff',
  },

  // Category Cards
  categoryCard: {
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
  },
  categoryCardDisabled: {
    opacity: 0.5,
  },
  categoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  categoryName: {
    fontSize: 18,
    fontWeight: '600',
    color: '#fff',
  },
  categoryCount: {
    fontSize: 14,
    color: '#4CAF50',
    fontWeight: '500',
  },
  subcategoryWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  subcategoryTag: {
    backgroundColor: '#1a1a2e',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    fontSize: 12,
    color: '#888',
    marginRight: 8,
    marginBottom: 8,
    overflow: 'hidden',
  },
  subcategoryMore: {
    fontSize: 12,
    color: '#666',
    alignSelf: 'center',
  },
  comingSoonBadge: {
    color: '#FF9800',
    fontSize: 12,
    fontStyle: 'italic',
    marginTop: 8,
  },

  // Question Screen
  questionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    paddingTop: 10,
  },
  questionHeaderRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  questionHeaderIconButton: {
    padding: 6,
    marginRight: 8,
  },
  progressContainer: {
    alignItems: 'center',
  },
  progressText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  timerText: {
    color: '#FF9800',
    fontSize: 14,
    marginTop: 4,
    fontWeight: '600',
  },
  flashcardModeText: {
    color: '#E91E63',
    fontSize: 12,
    marginTop: 2,
  },
  scoreContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  scoreCorrect: {
    color: '#4CAF50',
    fontSize: 18,
    fontWeight: 'bold',
  },
  scoreDivider: {
    color: '#666',
    marginHorizontal: 6,
  },
  scoreIncorrect: {
    color: '#f44336',
    fontSize: 18,
    fontWeight: 'bold',
  },
  progressBar: {
    height: 4,
    backgroundColor: '#333',
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#4CAF50',
  },
  questionContent: {
    flex: 1,
    padding: 20,
  },
  flashcardContent: {
    flexGrow: 1,
    justifyContent: 'center',
  },
  reviewLogBox: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 12,
  },
  reviewLogText: {
    fontSize: 12,
    lineHeight: 18,
  },
  leechNotice: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 14,
    marginBottom: 16,
  },
  leechNoticeText: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 10,
  },
  leechNoticeButton: {
    alignSelf: 'flex-start',
    backgroundColor: '#F44336',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 10,
  },
  leechNoticeButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  categoryBadgeRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 16,
    gap: 8,
  },
  categoryBadge: {
    backgroundColor: '#3282b8',
    paddingHorizontal: 12,
    paddingVertical: 5,
    borderRadius: 15,
  },
  categoryBadgeText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '500',
    textTransform: 'capitalize',
  },
  questionStem: {
    fontSize: 16,
    color: '#e0e0e0',
    lineHeight: 24,
    marginBottom: 16,
  },
  leadInBox: {
    backgroundColor: 'rgba(50, 130, 184, 0.15)',
    padding: 14,
    borderLeftWidth: 3,
    borderLeftColor: '#3282b8',
    borderRadius: 8,
    marginBottom: 20,
  },
  questionLeadIn: {
    fontSize: 15,
    color: '#bbe1fa',
    fontWeight: '600',
    lineHeight: 22,
  },
  optionsContainer: {
    marginBottom: 20,
  },
  option: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1a1a2e',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 2,
    borderColor: '#0f4c75',
  },
  optionSelected: {
    borderColor: '#3282b8',
    backgroundColor: 'rgba(50, 130, 184, 0.2)',
  },
  optionCorrect: {
    borderColor: '#4CAF50',
    backgroundColor: 'rgba(76, 175, 80, 0.2)',
  },
  optionIncorrect: {
    borderColor: '#f44336',
    backgroundColor: 'rgba(244, 67, 54, 0.2)',
  },
  optionLetter: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#0f4c75',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  letterCorrect: {
    backgroundColor: '#4CAF50',
  },
  letterIncorrect: {
    backgroundColor: '#f44336',
  },
  letterText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 14,
  },
  optionText: {
    flex: 1,
    fontSize: 15,
    color: '#e0e0e0',
    lineHeight: 22,
  },
  optionExplanationText: {
    fontSize: 13,
    lineHeight: 19,
    marginTop: 2,
    marginBottom: 6,
    marginHorizontal: 16,
    paddingTop: 6,
    paddingBottom: 2,
    fontStyle: 'italic',
  },

  // Explanation Card
  explanationCard: {
    backgroundColor: 'rgba(30, 58, 95, 0.9)',
    borderRadius: 16,
    padding: 24,
    marginTop: 20,
  },
  immediateFeedbackBox: {
    padding: 16,
    borderRadius: 10,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: 'rgba(255, 193, 7, 0.35)',
  },
  immediateFeedbackLabel: {
    fontSize: 12,
    fontWeight: '600',
    marginBottom: 6,
  },
  immediateFeedbackText: {
    fontSize: 14,
    lineHeight: 22,
  },
  keyPointBox: {
    backgroundColor: 'rgba(76, 175, 80, 0.15)',
    padding: 18,
    borderRadius: 10,
    borderLeftWidth: 3,
    borderLeftColor: '#4CAF50',
    marginBottom: 20,
  },
  explanationBox: {
    marginBottom: 20,
  },
  referencesBox: {
    backgroundColor: 'rgba(255, 152, 0, 0.1)',
    padding: 18,
    borderRadius: 10,
    borderLeftWidth: 3,
    borderLeftColor: '#FF9800',
  },
  explanationLabel: {
    fontSize: 15,
    fontWeight: '600',
    color: '#fff',
    marginBottom: 12,
  },
  keyPointText: {
    fontSize: 15,
    color: '#4CAF50',
    lineHeight: 24,
    fontWeight: '500',
  },
  explanationText: {
    fontSize: 15,
    color: '#ccc',
    lineHeight: 26,
  },
  referenceText: {
    fontSize: 12,
    color: '#999',
    lineHeight: 22,
    marginBottom: 6,
  },
  confidenceRow: {
    marginTop: 8,
    marginBottom: 12,
  },
  confidenceLabel: {
    fontSize: 13,
    fontWeight: '600',
    marginBottom: 8,
  },
  confidenceButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  confidenceButton: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: 'center',
    marginRight: 8,
  },
  confidenceLow: {
    backgroundColor: 'rgba(244, 67, 54, 0.2)',
    borderWidth: 1,
    borderColor: '#f44336',
  },
  confidenceMedium: {
    backgroundColor: 'rgba(255, 152, 0, 0.2)',
    borderWidth: 1,
    borderColor: '#FF9800',
  },
  confidenceHigh: {
    backgroundColor: 'rgba(76, 175, 80, 0.2)',
    borderWidth: 1,
    borderColor: '#4CAF50',
  },
  confidenceButtonText: {
    fontSize: 13,
    fontWeight: '600',
    color: '#fff',
  },

  // Add to Flashcards Button
  addToFlashcardsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(233, 30, 99, 0.15)',
    padding: 12,
    borderRadius: 10,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#E91E63',
  },
  addToFlashcardsText: {
    color: '#E91E63',
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 8,
  },

  // Rating Section (Spaced Repetition)
  ratingSection: {
    marginTop: 20,
    paddingTop: 20,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.1)',
  },
  ratingTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#fff',
    textAlign: 'center',
    marginBottom: 4,
  },
  ratingSubtitle: {
    fontSize: 12,
    color: '#888',
    textAlign: 'center',
    marginBottom: 16,
  },
  ratingButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  ratingButton: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 10,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  ratingHard: {
    backgroundColor: '#d32f2f',
  },
  ratingGood: {
    backgroundColor: '#4CAF50',
  },
  ratingEasy: {
    backgroundColor: '#2196F3',
  },
  ratingButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 15,
  },
  ratingInterval: {
    color: 'rgba(255,255,255,0.7)',
    fontSize: 11,
    marginTop: 2,
  },

  // Flashcard Styles
  flashcardContent: {
    paddingBottom: 32,
  },
  flashcardMetaRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginBottom: 6,
  },
  flashcardChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 14,
  },
  flashcardChipPrimary: {
    backgroundColor: 'rgba(233, 30, 99, 0.2)',
  },
  flashcardChipText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
    textTransform: 'uppercase',
    letterSpacing: 0.6,
  },
  flashcardTagRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginBottom: 10,
  },
  flashcardTagChip: {
    backgroundColor: 'rgba(255, 255, 255, 0.06)',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  flashcardTagText: {
    color: 'rgba(255,255,255,0.75)',
    fontSize: 11,
  },
  flashcardBox: {
    borderRadius: 18,
    padding: 26,
    marginVertical: 16,
    minHeight: 240,
    justifyContent: 'center',
    borderWidth: 1,
    shadowColor: '#000',
    shadowOpacity: 0.2,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 6 },
    elevation: 6,
  },
  flashcardPrompt: {
    fontSize: 12,
    textTransform: 'uppercase',
    letterSpacing: 2,
    textAlign: 'center',
    marginBottom: 12,
  },
  clozeText: {
    fontSize: 22,
    color: '#fff',
    lineHeight: 34,
    textAlign: 'center',
  },
  extraInfoBox: {
    marginTop: 20,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.1)',
  },
  extraInfoText: {
    fontSize: 14,
    color: '#aaa',
    lineHeight: 20,
    textAlign: 'center',
  },
  showAnswerButton: {
    backgroundColor: '#E91E63',
    paddingVertical: 16,
    borderRadius: 999,
    alignItems: 'center',
    marginTop: 8,
    shadowColor: '#E91E63',
    shadowOpacity: 0.35,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 6 },
    elevation: 4,
  },
  showAnswerText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  flashcardRatingSection: {
    marginTop: 10,
  },
  flashcardRatingButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  flashcardRatingButton: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 14,
    marginHorizontal: 3,
    alignItems: 'center',
  },
  ratingAgain: {
    backgroundColor: '#8e8e8e',
  },
  ratingEasyFlash: {
    backgroundColor: '#2f7ef8',
  },

  // Flashcard Results
  flashcardResultsSubtitle: {
    fontSize: 16,
    color: '#aaa',
    marginTop: 8,
  },

  // Results Screen
  resultsContent: {
    padding: 20,
    alignItems: 'center',
    paddingTop: 40,
  },
  resultsHeader: {
    alignItems: 'center',
    marginBottom: 32,
  },
  resultsTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 24,
    marginTop: 16,
  },
  scoreCircle: {
    width: 160,
    height: 160,
    borderRadius: 80,
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
    borderWidth: 4,
  },
  scorePercentage: {
    fontSize: 48,
    fontWeight: 'bold',
  },
  scoreLabel: {
    fontSize: 16,
    color: '#888',
  },
  resultsFeedback: {
    fontSize: 22,
    fontWeight: '600',
  },

  // Reminder Card
  reminderCard: {
    backgroundColor: 'rgba(30, 58, 95, 0.9)',
    borderRadius: 16,
    padding: 16,
    marginBottom: 16,
    width: '100%',
    borderLeftWidth: 4,
    borderLeftColor: '#9C27B0',
  },
  reminderTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: '#fff',
    marginBottom: 8,
  },
  reminderText: {
    fontSize: 14,
    color: '#aaa',
    lineHeight: 20,
  },

  // Mode Info Card
  modeInfoCard: {
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 12,
    padding: 14,
    marginBottom: 24,
    width: '100%',
  },
  modeInfoTitle: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '600',
  },
  modeInfoText: {
    color: '#4CAF50',
    fontSize: 13,
    marginTop: 4,
  },

  // Buttons
  primaryButton: {
    backgroundColor: '#4CAF50',
    paddingVertical: 16,
    paddingHorizontal: 32,
    borderRadius: 12,
    width: '100%',
    marginBottom: 12,
  },
  primaryButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
    textAlign: 'center',
  },
  secondaryButton: {
    backgroundColor: 'transparent',
    paddingVertical: 16,
    paddingHorizontal: 32,
    borderRadius: 12,
    width: '100%',
    borderWidth: 2,
    borderColor: '#4CAF50',
  },
  secondaryButtonText: {
    color: '#4CAF50',
    fontSize: 18,
    fontWeight: '600',
    textAlign: 'center',
  },

  // Modal Styles
  modalOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.8)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContent: {
    backgroundColor: '#1a1a2e',
    borderRadius: 20,
    padding: 24,
    width: '100%',
    maxWidth: 400,
    borderWidth: 1,
    borderColor: '#E91E63',
  },
  modalKeyboardAvoiding: {
    width: '100%',
    alignItems: 'center',
  },
  modalScrollableContent: {
    maxHeight: '80%',
  },
  reportModalContent: {
    maxHeight: '80%',
  },
  reportModalFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingBottom: 12,
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.08)',
  },
  reportModalScrollView: {
    width: '100%',
    maxHeight: height * 0.7,
  },
  reportModalScrollContent: {
    paddingBottom: 24,
  },
  modalTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#fff',
    textAlign: 'center',
    marginBottom: 8,
  },
  modalSubtitle: {
    fontSize: 13,
    color: '#888',
    textAlign: 'center',
    marginBottom: 20,
  },
  modalInput: {
    backgroundColor: '#16213e',
    borderRadius: 12,
    padding: 16,
    color: '#fff',
    fontSize: 15,
    minHeight: 120,
    textAlignVertical: 'top',
    borderWidth: 1,
    borderColor: '#0f4c75',
    marginBottom: 20,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  modalButtonCancel: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 10,
    marginRight: 8,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#666',
  },
  modalButtonCancelText: {
    color: '#888',
    fontSize: 16,
    fontWeight: '600',
  },
  modalButtonSave: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 10,
    marginLeft: 8,
    alignItems: 'center',
    backgroundColor: '#E91E63',
  },
  modalButtonSaveText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  modalButtonCompact: {
    marginLeft: 0,
    marginRight: 0,
    flexBasis: '30%',
  },
  modalActionsRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    flexWrap: 'wrap',
    gap: 10,
  },
  modalButtonSecondary: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 10,
    alignItems: 'center',
    backgroundColor: 'rgba(244, 67, 54, 0.15)',
  },
  modalButtonSecondaryText: {
    color: '#F44336',
    fontSize: 16,
    fontWeight: '600',
  },
  formRow: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 16,
  },
  formGroupHalf: {
    flex: 1,
  },
  formLabel: {
    fontSize: 12,
    color: '#888',
    marginBottom: 8,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  formInput: {
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: 'rgba(255,255,255,0.1)',
  },
  customModeRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  customModePill: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    borderWidth: 1,
  },
  customModePillActive: {
    backgroundColor: 'rgba(255,183,77,0.2)',
    borderColor: '#FFB74D',
  },
  customModeText: {
    fontSize: 12,
    fontWeight: '600',
  },
  tagPicker: {
    maxHeight: 220,
    marginTop: 8,
    marginBottom: 16,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(255,255,255,0.08)',
    padding: 8,
  },
  tagPickerContent: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  tagPill: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    borderWidth: 1,
  },
  tagPillActive: {
    backgroundColor: 'rgba(79, 140, 255, 0.2)',
    borderColor: '#4f8cff',
  },
  tagPillText: {
    fontSize: 12,
    fontWeight: '600',
  },
  categoryFilterRow: {
    marginBottom: 12,
  },
  categoryList: {
    maxHeight: 220,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(255,255,255,0.08)',
    padding: 8,
    marginBottom: 12,
  },
  modalSafeArea: {
    maxHeight: '85%',
    width: '100%',
  },
  modalScrollContent: {
    paddingBottom: 12,
  },
  modalFooterRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
    paddingTop: 8,
    borderTopWidth: 1,
    marginTop: 8,
    paddingBottom: 4,
    shadowColor: '#000',
    shadowOpacity: 0.12,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: -4 },
    elevation: 6,
  },
  categoryItem: {
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 10,
    borderWidth: 1,
    marginBottom: 8,
  },
  categoryItemActive: {
    backgroundColor: 'rgba(255,183,77,0.2)',
    borderColor: '#FFB74D',
  },
  categoryItemText: {
    fontSize: 13,
    fontWeight: '600',
  },
  presetRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  presetInfo: {
    flex: 1,
    marginRight: 8,
  },
  presetName: {
    fontSize: 13,
    fontWeight: '600',
  },
  presetMeta: {
    fontSize: 11,
    marginTop: 4,
  },
  presetActions: {
    flexDirection: 'row',
    gap: 8,
  },
  presetButton: {
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 8,
  },
  presetButtonText: {
    fontSize: 11,
    fontWeight: '600',
  },
  presetSaveButton: {
    alignSelf: 'flex-start',
    paddingVertical: 8,
    paddingHorizontal: 14,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: '#FFB74D',
    marginBottom: 14,
  },
  presetSaveText: {
    color: '#FFB74D',
    fontWeight: '600',
    fontSize: 12,
  },

  // Weakness Analysis Styles
  dashboardAssumptionCard: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 12,
    paddingVertical: 10,
    marginBottom: 12,
  },
  dashboardAssumptionText: {
    fontSize: 12,
    lineHeight: 18,
    marginLeft: 8,
    flex: 1,
  },
  dashboardKpiGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    gap: 10,
  },
  dashboardKpiTile: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 12,
    width: '48%',
  },
  dashboardKpiLabel: {
    fontSize: 11,
    textTransform: 'uppercase',
    marginBottom: 6,
    letterSpacing: 0.4,
  },
  dashboardKpiValue: {
    fontSize: 24,
    fontWeight: '700',
  },
  dashboardTrendBars: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    gap: 8,
  },
  dashboardTrendColumn: {
    alignItems: 'center',
    flex: 1,
  },
  dashboardTrendValue: {
    fontSize: 11,
    marginBottom: 6,
    minHeight: 15,
  },
  dashboardTrendTrack: {
    width: '100%',
    height: 74,
    borderRadius: 10,
    justifyContent: 'flex-end',
    overflow: 'hidden',
  },
  dashboardTrendFill: {
    width: '100%',
    borderRadius: 10,
  },
  dashboardTrendLabel: {
    fontSize: 11,
    marginTop: 6,
  },
  dashboardTable: {
    borderWidth: 1,
    borderRadius: 12,
    overflow: 'hidden',
  },
  dashboardTableHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    borderBottomWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 10,
  },
  dashboardTableHeaderText: {
    fontSize: 11,
    textTransform: 'uppercase',
    fontWeight: '700',
  },
  dashboardTableRow: {
    flexDirection: 'row',
    alignItems: 'center',
    borderTopWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 10,
  },
  dashboardTableTopicCell: {
    flex: 1.8,
  },
  dashboardTableMetricCell: {
    width: 54,
    textAlign: 'right',
  },
  dashboardTableTopicText: {
    fontSize: 13,
    fontWeight: '500',
  },
  dashboardTableMetricText: {
    fontSize: 12,
    fontWeight: '600',
  },
  dashboardFootnote: {
    fontSize: 12,
    marginTop: 10,
  },
  weakAreaCard: {
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
  },
  weakAreaHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 8,
  },
  weakAreaTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#fff',
  },
  weakAreaCategory: {
    fontSize: 12,
    color: '#888',
    marginTop: 2,
  },
  accuracyBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 8,
  },
  accuracyText: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  weakAreaStats: {
    marginBottom: 12,
  },
  weakAreaStatText: {
    fontSize: 13,
    color: '#888',
  },
  practiceWeakButton: {
    backgroundColor: '#FF572220',
    paddingVertical: 10,
    borderRadius: 8,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#FF5722',
  },
  practiceWeakButtonText: {
    color: '#FF5722',
    fontSize: 14,
    fontWeight: '600',
  },
  sectionSubtitle: {
    fontSize: 13,
    color: '#888',
    marginBottom: 16,
    marginTop: -8,
  },
  noDataCard: {
    backgroundColor: 'rgba(37, 37, 71, 0.5)',
    borderRadius: 16,
    padding: 30,
    alignItems: 'center',
    marginTop: 20,
  },
  noDataTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#fff',
    marginTop: 16,
    marginBottom: 8,
  },
  noDataText: {
    fontSize: 14,
    color: '#888',
    textAlign: 'center',
    lineHeight: 20,
  },

  // Resource Card Styles
  resourceCard: {
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 12,
    padding: 14,
    marginBottom: 12,
    flexDirection: 'row',
    alignItems: 'center',
  },
  resourceIcon: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(0, 188, 212, 0.15)',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  resourceContent: {
    flex: 1,
  },
  resourceTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: '#fff',
    marginBottom: 4,
  },
  resourceMeta: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
    flexWrap: 'wrap',
    gap: 8,
  },
  resourceMetaText: {
    fontSize: 12,
    color: '#888',
  },
  priorityBadge: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 6,
  },
  priorityText: {
    fontSize: 10,
    fontWeight: '600',
    textTransform: 'uppercase',
  },
  resourceRelevance: {
    fontSize: 12,
    color: '#00BCD4',
  },

  // Resource View Styles
  resourceHeader: {
    marginBottom: 24,
  },
  resourceViewTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#fff',
    lineHeight: 30,
    marginBottom: 12,
  },
  citationBox: {
    marginBottom: 12,
  },
  citationAuthors: {
    fontSize: 14,
    color: '#ccc',
    marginBottom: 4,
  },
  citationJournal: {
    fontSize: 13,
    color: '#888',
    fontStyle: 'italic',
  },
  resourceTags: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  resourceTag: {
    backgroundColor: 'rgba(0, 188, 212, 0.2)',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  resourceTagText: {
    fontSize: 12,
    color: '#00BCD4',
  },
  noteContent: {
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 16,
    padding: 20,
    marginBottom: 20,
  },
  noteText: {
    fontSize: 15,
    color: '#e0e0e0',
    lineHeight: 24,
  },
  abstractBox: {
    backgroundColor: 'rgba(37, 37, 71, 0.9)',
    borderRadius: 16,
    padding: 20,
    marginBottom: 20,
  },
  abstractLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#00BCD4',
    marginBottom: 10,
  },
  abstractText: {
    fontSize: 14,
    color: '#ccc',
    lineHeight: 22,
  },
  pubmedLinkButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(0, 188, 212, 0.15)',
    paddingVertical: 14,
    borderRadius: 12,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#00BCD4',
  },
  pubmedLinkText: {
    color: '#00BCD4',
    fontSize: 15,
    fontWeight: '600',
    marginLeft: 8,
  },
  relatedSection: {
    backgroundColor: 'rgba(30, 58, 95, 0.9)',
    borderRadius: 16,
    padding: 20,
  },
  relatedTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#fff',
    marginBottom: 8,
  },
  relatedText: {
    fontSize: 14,
    color: '#aaa',
    marginBottom: 16,
  },
  practiceRelatedButton: {
    backgroundColor: '#4CAF50',
    paddingVertical: 12,
    borderRadius: 10,
    alignItems: 'center',
  },
  practiceRelatedButtonText: {
    color: '#fff',
    fontSize: 15,
    fontWeight: '600',
  },

  // Report Issue Styles
  reportIssueButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 10,
    marginTop: 12,
  },
  reportIssueText: {
    color: '#888',
    fontSize: 13,
    marginLeft: 6,
  },
  reportTypeButtons: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'flex-start',
    marginBottom: 16,
    gap: 8,
  },
  reportTypeButton: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 8,
    alignItems: 'center',
    backgroundColor: '#16213e',
    borderWidth: 1,
    borderColor: '#0f4c75',
  },
  reportTypeActive: {
    borderColor: '#FF5722',
    backgroundColor: 'rgba(255, 87, 34, 0.2)',
  },
  reportTypeButtonText: {
    color: '#aaa',
    fontSize: 12,
    fontWeight: '500',
  },
  // Card Settings Styles
  cardOptionsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 16,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.1)',
  },
  cardOptionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 8,
    backgroundColor: 'rgba(255,255,255,0.05)',
  },
  cardOptionText: {
    color: '#888',
    fontSize: 13,
    marginLeft: 6,
  },
  cardSettingOption: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 12,
    backgroundColor: 'rgba(255,255,255,0.05)',
    marginBottom: 12,
  },
  cardSettingOptionActive: {
    backgroundColor: 'rgba(76, 175, 80, 0.15)',
    borderWidth: 1,
    borderColor: '#4CAF50',
  },
  cardSettingIconBox: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(255,255,255,0.1)',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  cardSettingInfo: {
    flex: 1,
  },
  cardSettingTitle: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  cardSettingDesc: {
    color: '#888',
    fontSize: 13,
  },
  customIntervalSection: {
    marginTop: 8,
    marginBottom: 16,
  },
  customIntervalLabel: {
    color: '#aaa',
    fontSize: 14,
    marginBottom: 8,
  },
  customIntervalRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  customIntervalInput: {
    flex: 1,
    backgroundColor: 'rgba(255,255,255,0.1)',
    borderRadius: 8,
    paddingHorizontal: 16,
    paddingVertical: 12,
    color: '#fff',
    fontSize: 16,
    marginRight: 10,
  },
  customIntervalButton: {
    backgroundColor: '#9C27B0',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  customIntervalButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 14,
  },
  clearIntervalButton: {
    marginTop: 10,
    paddingVertical: 8,
  },
  clearIntervalText: {
    color: '#FF9800',
    fontSize: 13,
    textAlign: 'center',
  },
  suspendedNote: {
    color: '#888',
    fontSize: 12,
    textAlign: 'center',
    marginTop: 8,
    fontStyle: 'italic',
  },
  lockedNote: {
    color: '#FF9800',
    fontSize: 12,
    textAlign: 'center',
    marginTop: 10,
  },
  debugInfo: {
    marginTop: 16,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.1)',
  },
  debugText: {
    color: '#666',
    fontSize: 11,
    fontFamily: 'monospace',
    marginBottom: 2,
  },
  // Exam Distribution Card
  examDistributionCard: {
    backgroundColor: 'rgba(156, 39, 176, 0.1)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: 'rgba(156, 39, 176, 0.3)',
  },
  examDistRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 6,
  },
  examDistLabel: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '500',
  },
  examDistPercent: {
    color: '#9C27B0',
    fontSize: 14,
    fontWeight: '600',
  },
  examDistSubRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 3,
    paddingLeft: 12,
  },
  examDistSubLabel: {
    color: '#aaa',
    fontSize: 13,
  },
  examDistSubPercent: {
    color: '#aaa',
    fontSize: 13,
  },
  examDistNote: {
    color: '#888',
    fontSize: 12,
    textAlign: 'center',
    marginTop: 10,
    fontStyle: 'italic',
  },
  // Study Topics Styles
  studyTopicCard: {
    backgroundColor: 'rgba(0, 188, 212, 0.08)',
    borderRadius: 12,
    padding: 14,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: 'rgba(0, 188, 212, 0.2)',
  },
  studyTopicCardRead: {
    backgroundColor: 'rgba(76, 175, 80, 0.08)',
    borderColor: 'rgba(76, 175, 80, 0.3)',
  },
  studyTopicHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  studyTopicIcon: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(0, 188, 212, 0.15)',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  studyTopicIconRead: {
    backgroundColor: 'rgba(76, 175, 80, 0.15)',
  },
  studyTopicInfo: {
    flex: 1,
  },
  studyTopicTitle: {
    color: '#fff',
    fontSize: 15,
    fontWeight: '600',
    marginBottom: 4,
  },
  studyTopicTitleRead: {
    color: '#aaa',
  },
  studyTopicMeta: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  studyTopicTime: {
    color: '#888',
    fontSize: 12,
  },
  studyTopicBadges: {
    flexDirection: 'row',
  },
  linkedBadge: {
    backgroundColor: 'rgba(0, 188, 212, 0.2)',
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 10,
    marginLeft: 6,
  },
  linkedBadgeText: {
    color: '#00BCD4',
    fontSize: 11,
    fontWeight: '600',
  },
  studyProgressCard: {
    backgroundColor: 'rgba(255,255,255,0.05)',
    borderRadius: 12,
    padding: 16,
    marginTop: 8,
    marginBottom: 16,
  },
  studyProgressTitle: {
    color: '#aaa',
    fontSize: 13,
    marginBottom: 10,
  },
  studyProgressBar: {
    height: 8,
    backgroundColor: 'rgba(255,255,255,0.1)',
    borderRadius: 4,
    marginBottom: 8,
    overflow: 'hidden',
  },
  studyProgressFill: {
    height: '100%',
    backgroundColor: '#4CAF50',
    borderRadius: 4,
  },
  studyProgressText: {
    color: '#888',
    fontSize: 12,
    textAlign: 'center',
  },
  // Question Marking Styles
  questionMarkButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  questionMarkButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    marginHorizontal: 6,
    borderRadius: 10,
    backgroundColor: 'rgba(255,255,255,0.05)',
    borderWidth: 1,
    borderColor: 'rgba(255,255,255,0.1)',
  },
  questionMarkButtonActive: {
    backgroundColor: 'rgba(255, 152, 0, 0.15)',
    borderColor: '#FF9800',
  },
  questionMarkButtonReview: {
    backgroundColor: 'rgba(244, 67, 54, 0.15)',
    borderColor: '#F44336',
  },
  questionMarkText: {
    color: '#888',
    fontSize: 13,
    fontWeight: '500',
    marginLeft: 8,
  },
  questionNavButtons: {
    flexDirection: 'row',
    gap: 10,
  },
  questionNavButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 10,
    gap: 6,
  },
  prevQuestionButton: {
    backgroundColor: '#555',
  },
  nextQuestionButton: {
    backgroundColor: '#4CAF50',
  },
  questionNavButtonDisabled: {
    backgroundColor: '#333',
    opacity: 0.5,
  },
  questionNavButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  // Question Count Selector Styles
  questionCountSection: {
    marginBottom: 20,
    padding: 16,
    backgroundColor: 'rgba(255,255,255,0.05)',
    borderRadius: 12,
  },
  questionCountLabel: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 12,
    textAlign: 'center',
  },
  questionCountOptions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  questionCountButton: {
    flex: 1,
    paddingVertical: 12,
    marginHorizontal: 4,
    borderRadius: 8,
    backgroundColor: 'rgba(255,255,255,0.1)',
    alignItems: 'center',
  },
  questionCountButtonActive: {
    backgroundColor: '#4CAF50',
  },
  questionCountText: {
    color: '#888',
    fontSize: 16,
    fontWeight: '600',
  },
  questionCountTextActive: {
    color: '#fff',
  },
  // Mode Selection Modal Styles
  modeSelectionOption: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 12,
    backgroundColor: 'rgba(255,255,255,0.05)',
    marginBottom: 12,
    borderWidth: 1,
    borderColor: 'rgba(255,255,255,0.1)',
  },
  modeSelectionIcon: {
    width: 56,
    height: 56,
    borderRadius: 28,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 14,
  },
  modeSelectionInfo: {
    flex: 1,
  },
  modeSelectionTitle: {
    color: '#fff',
    fontSize: 17,
    fontWeight: '600',
    marginBottom: 4,
  },
  modeSelectionDesc: {
    color: '#888',
    fontSize: 13,
    lineHeight: 18,
  },
  // Test Review Styles
  testReviewSection: {
    marginBottom: 20,
  },
  testReviewTitle: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 4,
  },
  testReviewSubtitle: {
    color: '#888',
    fontSize: 13,
    marginBottom: 16,
  },
  testReviewItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255,255,255,0.05)',
    borderRadius: 10,
    padding: 12,
    marginBottom: 8,
    borderLeftWidth: 3,
  },
  testReviewCorrect: {
    borderLeftColor: '#4CAF50',
  },
  testReviewIncorrect: {
    borderLeftColor: '#F44336',
  },
  testReviewNumber: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: 'rgba(255,255,255,0.1)',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 10,
  },
  testReviewNumberText: {
    color: '#aaa',
    fontSize: 12,
    fontWeight: '600',
  },
  testReviewContent: {
    flex: 1,
  },
  testReviewQuestionText: {
    color: '#ccc',
    fontSize: 13,
    lineHeight: 18,
    marginBottom: 4,
  },
  testReviewStatus: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  testReviewStatusText: {
    fontSize: 12,
    fontWeight: '500',
    marginLeft: 4,
  },
  testReviewMarkButton: {
    padding: 8,
    marginLeft: 8,
  },
  // Review Filter Styles
  reviewFilterRow: {
    flexDirection: 'row',
    marginBottom: 16,
  },
  reviewFilterButton: {
    flex: 1,
    paddingVertical: 10,
    marginHorizontal: 4,
    borderRadius: 8,
    backgroundColor: 'rgba(255,255,255,0.1)',
    alignItems: 'center',
  },
  reviewFilterButtonActive: {
    backgroundColor: '#2196F3',
  },
  reviewFilterButtonActiveCorrect: {
    backgroundColor: '#4CAF50',
  },
  reviewFilterButtonActiveIncorrect: {
    backgroundColor: '#F44336',
  },
  reviewFilterText: {
    color: '#888',
    fontSize: 13,
    fontWeight: '600',
  },
  reviewFilterTextActive: {
    color: '#fff',
  },
  // Review Modal Styles
  reviewModalOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.95)',
    justifyContent: 'center',
    padding: 16,
  },
  reviewModalContent: {
    flex: 1,
    backgroundColor: '#1a1a2e',
    borderRadius: 16,
    overflow: 'hidden',
  },
  reviewModalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255,255,255,0.1)',
  },
  reviewModalTitle: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
  reviewModalScroll: {
    flex: 1,
    padding: 16,
  },
  reviewModalStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
  },
  reviewModalStatusText: {
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  reviewModalQuestion: {
    color: '#fff',
    fontSize: 16,
    lineHeight: 24,
    marginBottom: 16,
  },
  reviewModalOptions: {
    marginBottom: 20,
  },
  reviewModalOption: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    padding: 12,
    borderRadius: 8,
    backgroundColor: 'rgba(255,255,255,0.05)',
    marginBottom: 8,
  },
  reviewModalOptionCorrect: {
    backgroundColor: 'rgba(76, 175, 80, 0.15)',
    borderWidth: 1,
    borderColor: '#4CAF50',
  },
  reviewModalOptionWrong: {
    backgroundColor: 'rgba(244, 67, 54, 0.15)',
    borderWidth: 1,
    borderColor: '#F44336',
  },
  reviewModalOptionLetter: {
    color: '#888',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 8,
    width: 20,
  },
  reviewModalOptionText: {
    flex: 1,
    color: '#ddd',
    fontSize: 14,
    lineHeight: 20,
  },
  reviewModalExplanation: {
    backgroundColor: 'rgba(33, 150, 243, 0.1)',
    borderRadius: 12,
    padding: 16,
    borderLeftWidth: 4,
    borderLeftColor: '#2196F3',
  },
  reviewModalExplanationTitle: {
    color: '#2196F3',
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 8,
  },
  reviewModalExplanationText: {
    color: '#ddd',
    fontSize: 14,
    lineHeight: 22,
  },
  reviewModalKeyPoint: {
    marginTop: 16,
    padding: 12,
    backgroundColor: 'rgba(76, 175, 80, 0.1)',
    borderRadius: 8,
  },
  reviewModalKeyPointTitle: {
    color: '#4CAF50',
    fontSize: 13,
    fontWeight: '600',
    marginBottom: 4,
  },
  reviewModalKeyPointText: {
    color: '#ccc',
    fontSize: 13,
    lineHeight: 20,
  },
  reviewModalNav: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.1)',
  },
  reviewModalNavButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 20,
  },
  reviewModalNavButtonDisabled: {
    opacity: 0.5,
  },
  reviewModalNavText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '500',
    marginHorizontal: 4,
  },

  // ============ PET SYSTEM STYLES ============

  // Header styles
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  coinDisplay: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 215, 0, 0.15)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
  },
  coinText: {
    color: '#FFD700',
    fontWeight: 'bold',
    fontSize: 16,
    marginLeft: 6,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  accountBar: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: 'rgba(37, 37, 71, 0.6)',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 8,
    marginTop: 12,
  },
  accountInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
    marginRight: 12,
  },
  accountEmail: {
    color: '#aaa',
    fontSize: 13,
    marginLeft: 8,
    flex: 1,
  },
  syncIcon: {
    marginLeft: 6,
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 6,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  logoutText: {
    color: '#888',
    fontSize: 12,
    marginLeft: 4,
  },
  settingsButton: {
    padding: 8,
    borderRadius: 8,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },

  // Settings Screen Styles
  settingsSection: {
    borderRadius: 16,
    padding: 16,
    marginBottom: 16,
  },
  settingsSectionTitle: {
    fontSize: 13,
    fontWeight: '600',
    color: '#888',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
    marginBottom: 16,
  },
  settingsSectionSubtitle: {
    fontSize: 13,
    color: '#9aa0a6',
    marginTop: -8,
    marginBottom: 12,
  },
  settingsUserInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
    marginBottom: 8,
  },
  settingsAvatar: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: 'rgba(76, 175, 80, 0.15)',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 14,
  },
  settingsUserDetails: {
    flex: 1,
  },
  settingsUserName: {
    fontSize: 18,
    fontWeight: '600',
    color: '#fff',
    marginBottom: 2,
  },
  settingsUserEmail: {
    fontSize: 14,
    color: '#888',
  },
  settingsItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 14,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.05)',
  },
  settingsItemLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  settingsIconBox: {
    width: 36,
    height: 36,
    borderRadius: 10,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 14,
  },
  settingsItemText: {
    fontSize: 16,
    color: '#fff',
  },
  settingsItemRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  settingsItemValue: {
    fontSize: 14,
    color: '#888',
    marginRight: 8,
  },
  settingsBadge: {
    backgroundColor: 'rgba(76, 175, 80, 0.2)',
    color: '#4CAF50',
    fontSize: 12,
    fontWeight: '600',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    marginRight: 8,
    overflow: 'hidden',
  },
  settingsStatsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 8,
  },
  settingsStatBox: {
    width: '50%',
    alignItems: 'center',
    paddingVertical: 12,
  },
  settingsStatNumber: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#4CAF50',
    marginBottom: 4,
  },
  settingsStatLabel: {
    fontSize: 12,
    color: '#888',
    textTransform: 'uppercase',
  },
  settingsToggle: {
    width: 52,
    height: 30,
    borderRadius: 15,
    backgroundColor: '#ccc',
    padding: 3,
    justifyContent: 'center',
  },
  settingsToggleActive: {
    backgroundColor: '#4CAF50',
  },
  settingsToggleKnob: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: '#fff',
  },
  settingsToggleKnobActive: {
    alignSelf: 'flex-end',
  },
  microTestSizeControls: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  microTestSizeButton: {
    width: 28,
    height: 28,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 4,
  },
  microTestSizeValue: {
    minWidth: 24,
    textAlign: 'center',
    fontSize: 14,
    fontWeight: '600',
  },
  settingsSignOutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(244, 67, 54, 0.1)',
    borderRadius: 12,
    paddingVertical: 16,
    marginBottom: 16,
  },
  settingsSignOutText: {
    color: '#F44336',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  settingsVersion: {
    textAlign: 'center',
    fontSize: 12,
    color: '#666',
    marginBottom: 32,
  },

  // Pet Widget on home
  petWidgetCard: {
    // No left border - clean design
  },
  petWidgetContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  petSpriteWrap: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  petAura: {
    position: 'absolute',
  },
  petShadow: {
    height: 8,
    borderRadius: 6,
    marginBottom: 4,
  },
  petBody: {
    position: 'relative',
  },
  petHighlight: {
    position: 'absolute',
    top: '18%',
    left: '20%',
    opacity: 0.6,
  },
  petEar: {
    position: 'absolute',
    top: '-8%',
  },
  petCrack: {
    position: 'absolute',
    bottom: '24%',
    alignSelf: 'center',
    opacity: 0.7,
  },
  petFace: {
    position: 'absolute',
    left: '24%',
    right: '24%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  petEye: {
    borderRadius: 8,
    backgroundColor: '#3b2f2f',
  },
  petCheek: {
    position: 'absolute',
    top: '55%',
    opacity: 0.6,
  },
  petMouth: {
    position: 'absolute',
    top: '58%',
    alignSelf: 'center',
    width: 12,
    height: 4,
    borderRadius: 2,
  },
  petSparkle: {
    position: 'absolute',
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: 'rgba(255,255,255,0.9)',
  },
  petWidgetLeft: {
    position: 'relative',
    marginRight: 12,
  },
  petMoodDot: {
    position: 'absolute',
    bottom: 0,
    right: 0,
    width: 12,
    height: 12,
    borderRadius: 6,
    borderWidth: 2,
    borderColor: '#16213e',
  },
  petWidgetInfo: {
    flex: 1,
  },
  petWidgetName: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  petWidgetStage: {
    color: '#aaa',
    fontSize: 14,
  },
  petXPBar: {
    height: 4,
    backgroundColor: 'rgba(255,255,255,0.2)',
    borderRadius: 2,
    marginTop: 6,
    overflow: 'hidden',
  },
  petXPFill: {
    height: '100%',
    backgroundColor: '#4CAF50',
    borderRadius: 2,
  },

  // Pet Screen
  petHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255,255,255,0.1)',
  },
  petHeaderTitle: {
    color: '#fff',
    fontSize: 20,
    fontWeight: 'bold',
  },
  backButton: {
    padding: 4,
  },

  // Room View
  roomContainer: {
    marginBottom: 16,
  },
  roomView: {
    height: 220,
    borderRadius: 16,
    marginBottom: 8,
    justifyContent: 'center',
    alignItems: 'center',
    overflow: 'hidden',
  },
  roomBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  roomBlob: {
    position: 'absolute',
    width: 220,
    height: 160,
    borderRadius: 90,
    top: -40,
    left: -40,
    opacity: 0.5,
  },
  roomBlobSecondary: {
    position: 'absolute',
    width: 160,
    height: 120,
    borderRadius: 70,
    bottom: -20,
    right: -20,
    opacity: 0.45,
  },
  roomFloor: {
    position: 'absolute',
    width: 220,
    height: 48,
    borderRadius: 24,
    bottom: 12,
    left: '50%',
    marginLeft: -110,
  },
  petDisplay: {
    alignItems: 'center',
  },
  petBigEmoji: {
    fontSize: 80,
  },
  petMoodBubble: {
    position: 'absolute',
    top: -10,
    right: -30,
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  petMoodEmoji: {
    fontSize: 18,
  },
  emptyRoomText: {
    color: '#888',
    marginTop: 8,
  },
  miniFurniture: {
    position: 'absolute',
  },

  // Room Selector
  roomSelector: {
    flexDirection: 'row',
  },
  roomTab: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: 'rgba(255,255,255,0.1)',
    borderRadius: 20,
    marginRight: 8,
  },
  roomTabActive: {
    backgroundColor: '#4CAF50',
  },
  roomTabText: {
    color: '#fff',
    fontSize: 14,
  },
  roomTabAdd: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: 'rgba(76, 175, 80, 0.2)',
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#4CAF50',
    borderStyle: 'dashed',
  },
  roomTabAddText: {
    color: '#4CAF50',
    fontSize: 12,
    marginLeft: 4,
  },

  // Pet Info Card
  petInfoCard: {
    backgroundColor: 'rgba(255,255,255,0.08)',
    borderRadius: 16,
    padding: 16,
    marginBottom: 16,
  },
  petInfoHeader: {
    marginBottom: 12,
  },
  petInfoName: {
    color: '#fff',
    fontSize: 22,
    fontWeight: 'bold',
  },
  petInfoStage: {
    color: '#aaa',
    fontSize: 14,
  },
  petStatRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  petStatLabel: {
    color: '#888',
    width: 50,
    fontSize: 12,
  },
  petProgressBar: {
    flex: 1,
    height: 8,
    backgroundColor: 'rgba(255,255,255,0.15)',
    borderRadius: 4,
    marginHorizontal: 8,
    overflow: 'hidden',
  },
  petProgressFill: {
    height: '100%',
    borderRadius: 4,
  },
  petStatValue: {
    color: '#fff',
    width: 60,
    fontSize: 12,
    textAlign: 'right',
  },

  // Pet Selector
  petSelectorContainer: {
    marginBottom: 16,
  },
  sectionLabel: {
    color: '#888',
    fontSize: 14,
    marginBottom: 8,
  },
  petSelectorItem: {
    alignItems: 'center',
    padding: 12,
    backgroundColor: 'rgba(255,255,255,0.08)',
    borderRadius: 12,
    marginRight: 12,
    minWidth: 80,
  },
  petSelectorItemActive: {
    backgroundColor: 'rgba(76, 175, 80, 0.3)',
    borderWidth: 2,
    borderColor: '#4CAF50',
  },
  petSelectorName: {
    color: '#fff',
    fontSize: 12,
  },

  // Claim Egg Button
  claimEggButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(76, 175, 80, 0.2)',
    borderWidth: 2,
    borderColor: '#4CAF50',
    borderRadius: 16,
    padding: 16,
    marginBottom: 16,
  },
  claimEggTitle: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  claimEggSubtitle: {
    color: '#aaa',
    fontSize: 14,
  },

  // Pet Actions
  petActions: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 8,
  },
  petActionButton: {
    alignItems: 'center',
    padding: 16,
    backgroundColor: 'rgba(255,255,255,0.1)',
    borderRadius: 16,
    minWidth: 80,
  },
  petActionText: {
    color: '#fff',
    marginTop: 4,
    fontSize: 12,
  },

  // Shop Styles
  shopCategoryTabs: {
    flexDirection: 'row',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255,255,255,0.1)',
  },
  shopCategoryTab: {
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    marginRight: 8,
    borderRadius: 12,
    backgroundColor: 'rgba(255,255,255,0.05)',
  },
  shopCategoryTabActive: {
    backgroundColor: 'rgba(76, 175, 80, 0.3)',
  },
  shopCategoryIcon: {
    fontSize: 20,
    marginBottom: 2,
  },
  shopCategoryName: {
    color: '#888',
    fontSize: 11,
  },
  shopCategoryNameActive: {
    color: '#fff',
  },
  shopGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    padding: 12,
  },
  shopItem: {
    width: (width - 48) / 2,
    backgroundColor: 'rgba(255,255,255,0.08)',
    borderRadius: 12,
    padding: 12,
    margin: 6,
    alignItems: 'center',
    position: 'relative',
  },
  shopItemDisabled: {
    opacity: 0.5,
  },
  shopItemRarity: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 3,
    borderTopLeftRadius: 12,
    borderTopRightRadius: 12,
  },
  shopItemEmoji: {
    fontSize: 36,
    marginBottom: 8,
  },
  shopItemName: {
    color: '#fff',
    fontSize: 14,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  shopItemDesc: {
    color: '#888',
    fontSize: 11,
    textAlign: 'center',
    marginVertical: 4,
  },
  shopItemPrice: {
    color: '#FFD700',
    fontSize: 14,
    fontWeight: 'bold',
    marginTop: 4,
  },
  shopItemOwned: {
    color: '#4CAF50',
    fontSize: 12,
    fontWeight: 'bold',
    marginTop: 4,
  },
  shopItemLocked: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  medicalBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: '#E91E63',
    borderRadius: 10,
    padding: 4,
  },

  // Decorator Styles
  decoratorRoom: {
    flex: 1,
    backgroundColor: '#2a2a4e',
    margin: 16,
    borderRadius: 16,
    position: 'relative',
    minHeight: 300,
  },
  placedFurniture: {
    position: 'absolute',
    padding: 8,
  },
  furnitureEmoji: {
    fontSize: 28,
  },
  decoratorHint: {
    position: 'absolute',
    bottom: 16,
    left: 0,
    right: 0,
    textAlign: 'center',
    color: '#666',
    fontSize: 12,
  },
  furnitureInventory: {
    backgroundColor: 'rgba(0,0,0,0.3)',
    padding: 16,
  },
  inventoryTitle: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  inventoryItem: {
    alignItems: 'center',
    padding: 12,
    backgroundColor: 'rgba(255,255,255,0.1)',
    borderRadius: 12,
    marginRight: 12,
    minWidth: 70,
  },
  inventoryItemSelected: {
    borderWidth: 2,
    borderColor: '#4CAF50',
    backgroundColor: 'rgba(76, 175, 80, 0.2)',
  },
  inventoryEmoji: {
    fontSize: 24,
  },
  inventoryName: {
    color: '#fff',
    fontSize: 10,
    marginTop: 4,
  },
  noFurnitureText: {
    color: '#888',
    fontStyle: 'italic',
    paddingVertical: 20,
  },
  decoratorRoomSelector: {
    flexDirection: 'row',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.1)',
  },

  // Coin Toast
  coinToast: {
    position: 'absolute',
    top: 100,
    alignSelf: 'center',
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.85)',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 25,
    borderWidth: 1,
    borderColor: '#FFD700',
  },
  coinToastText: {
    color: '#FFD700',
    fontSize: 20,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  coinToastSource: {
    color: '#fff',
    fontSize: 14,
    marginLeft: 8,
  },

  // Reading View Styles
  readingContent: {
    borderRadius: 16,
    padding: 28,
    marginBottom: 24,
    borderWidth: 1,
  },
  readingInfoRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginBottom: 12,
  },
  readingInfoPill: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
  },
  readingInfoText: {
    fontSize: 13,
  },
  readingProgressBar: {
    height: 3,
    borderRadius: 2,
    marginBottom: 8,
    overflow: 'hidden',
  },
  readingProgressFill: {
    height: 3,
    borderRadius: 2,
  },

  // MarkdownContent Styles
  readingText: {
    fontSize: 16,
    lineHeight: 28,
    marginBottom: 16,
  },
  readingH1: {
    fontSize: 24,
    fontWeight: '800',
  },
  readingH1Wrap: {
    marginTop: 32,
    marginBottom: 16,
    paddingBottom: 10,
    borderBottomWidth: 2,
  },
  readingH2: {
    fontSize: 20,
    fontWeight: '700',
  },
  readingH2Wrap: {
    marginTop: 28,
    marginBottom: 14,
    paddingLeft: 14,
    paddingVertical: 8,
    borderLeftWidth: 3,
    borderRadius: 4,
  },
  readingH3: {
    fontSize: 17,
    fontWeight: '600',
  },
  readingH3Wrap: {
    marginTop: 22,
    marginBottom: 10,
    paddingLeft: 12,
    borderLeftWidth: 2,
  },
  readingListItem: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 10,
    paddingLeft: 4,
  },
  readingListText: {
    fontSize: 16,
    lineHeight: 26,
    flex: 1,
  },
  readingListBullet: {
    width: 6,
    height: 6,
    borderRadius: 3,
    marginTop: 10,
    marginRight: 12,
  },
  readingQuote: {
    borderLeftWidth: 3,
    paddingLeft: 16,
    paddingVertical: 12,
    marginBottom: 16,
    borderRadius: 4,
  },
  readingQuoteText: {
    fontSize: 15,
    lineHeight: 24,
    fontStyle: 'italic',
  },
  readingTable: {
    flexDirection: 'column',
    borderWidth: 1,
    borderRadius: 8,
    overflow: 'hidden',
    marginBottom: 16,
  },
  readingTableRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
  },
  readingTableHeader: {},
  readingTableCell: {
    paddingVertical: 10,
    paddingHorizontal: 12,
    minWidth: 100,
    fontSize: 14,
    lineHeight: 20,
  },
  readingTableHint: {
    fontSize: 12,
    textAlign: 'center',
    marginBottom: 6,
    fontStyle: 'italic',
  },
  readingCalloutTitle: {
    fontSize: 15,
    fontWeight: '700',
    marginBottom: 6,
  },
});
